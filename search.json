[{"title":"ubuntu利用devstack搭建openstack","url":"/2022/03/30/ubuntu利用devstack搭建openstack/","content":"\n\n\n# 云计算技术实验报告\n\n\n\n### 实验目的\n\n在Linux环境下，熟悉Openstack环境\n\n具体包括：了解Openstack编程环境的配置和部署，完成实验环境及实验工具的熟悉，撰写试验报告\n\n<!-- more -->\n\n### 个人信息\n\n学号：201900130068\n\n姓名：曹玉雯\n\n班级：19.2\n\n实验题目：面向LaaS的Openstack部署\n\n实验日期：22.03.30\n\n\n\n## 了解Openstack\n\n\n\n### openstack历史\n\n时间回到2010年，当时的云计算场景是这样的，亚马逊的AWS稳坐大当家的地位。其他几家IaaS的公司分别是：Cloudstack、Eucalyptus、Nebula(NASA的云平台)和Rackspace Cloud 。\n\n当时NASA已经在云计算领域投入了大量的资金，使用了很多Eucalyptus的代码。他们在该平台上也进行了很多深度开发，但最后还是放弃了该平台。据说是NASA的工程师试图获取更多的Eucalyptus 代码，但是失败了。因为这个平台只是开放部分的源码。最初的问题仅仅是扩展性问题，后来Eucalyptu与NASA的裂痕发展到无法挽回的地步，是因为NASA发现Eucalyptus不愿向该项目提供解决扩展性问题的代码，即便是该项目并未与Eucalyptus Systems Inc(Eucalyptus幕后的实体公司)造成利益冲突。索性NASA的工程师就用Python开发了Nova，在2010年4月开始筹备OpenStack。2010年7月NASA贡献了自己的云计算管理平台Nova代码，并联合了当时第二大云计算厂商Rackspace(贡献了对象存储代码，也就是后来的Swift)发起了OpenStack开源项目。\n\n\n\n### 功能\n\nOpenStack是为云计算服务的，更确切地说，它是工作在IaaS这个层面的一套软件。\n\n我们知道，IaaS全称是“基础设施及服务”，目的是为用户灵活的提供各种资源，从而满足客户的需求。所谓的基础设施，主要就是计算，存储和网络三类资源。那为什么需要OpenStack呢？\n\n云计算的思想是将所有的资源“池”化，也即是说，不管你有多少台服务器，多少个硬盘，我先把它们做成池子，然后再灵活地分配给不同的用户。那么具体谁来做池子，做完池子以后怎么分配给用户，这就是OpenStack做的事情。它就好比电脑的操作系统，每个应用占用多少CPU，占用多少内存，由操作系统来分配。OpenStack就是云计算的操作系统。\n\n\n\n\n## 部署Openstack\n\n\n\n### **前置知识的了解**\n\nOpenStack介绍\n\nopenstack详细介绍及常用命令请查看[此文](https://blog.csdn.net/Q0717168/article/details/108099359)\n\n通过devstack部署OpenStack，官方文档点击[此处查看](https://docs.openstack.org/devstack/latest/)\n\n\n\n### **安装环境**\n\n由于本实验需要内存为8G以上，所以选择安装双系统\n\n- 镜像下载地址: https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04.4/\n- 安装教程: https://www.cnblogs.com/masbay/p/11627727.html\n\n内容与本实验关联性不大，不过多赘述\n\n操作系统：Ubuntu 21.10\n\n\n\n### **源和工具准备**\n\n部分参考教程推荐更换国内apt源，但经测试发现，国内源会出现一些奇怪的依赖性bug\n\n因此还是推荐使用ubuntu自带的apt源\n\n\n\n**升级git、pip、vim等必要工具**\n\n```\nsudo apt-get install git python-pip\nsudo pip install --upgrade pip\nsudo pip install -U os-testr\nsudo apt install vim\n```\n\n\n\n**更新python3的工具包**\n\n```\ncd /usr/lib/python3/dist-packages/\n\nrm -f pyasn1_modules-0.2.1.egg-info\n\nrm -f simplejson-3.16.0.egg-info\n\napt-get install bridge-utils git python3-pip -y\n```\n\n\n\n**更新pip源**\n\n`mkdir ~/.pip` #建立目录\n\n`sudo vim ~/.pip/pip.conf` #新建pip源配置文件，填入以下内容(下面是清华源，成功率较高)\n\n```\n[global]\n\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n\ntrusted-host = pypi.tuna.tsinghua.edu.cn\n```\n\n\n\n**修改host**\n\n由于openstack的大部分资源都是在github上clone下来的，但是github经常出现连接不稳定的情况，这会导致安装到一半显示error，因此需要修改host以保证能稳定clone\n\n方法不限于\n\n在`/etc/hosts`文件内添加\n\n```\n#github\n140.82.113.4 github.com\n199.232.5.194 github.global.ssl.fastly.net\n```\n\n或者设置代理软件也可以\n\n\n\n### 安装devstack\n\n\n\n**创建stack用户**\n\n```\nuseradd -s /bin/bash -d /opt/stack -m stack\n```\n\n授予stack用户sudo权限\n\n```\nuseradd -s /bin/bash -d /opt/stack -m stack\n```\n\n切换到stack用户\n\n```\nsudo su - stack\n```\n\n\n\n**下载devstack**\n\n注意不少的教程给出的git clone devstack的连接都不是最新的，这会导致一些访问失效问题，所以参阅官方手册clone devstack到`/opt`文件夹下，并修改文件夹权限\n\n```\nsudo git clone https://opendev.org/openstack/devstack /opt/devstack \n\nsudo chown -R stack:stack /opt/devstack\n\nsudo chmod -R 777 /opt/devstack \n```\n\n\n\n**添加local.conf文件**\n\n`cd /opt/devstack` #进入devstack目录\n\n网上其他教程都给出了自己local.conf文件，但我还是更推荐使用官网给出的local.conf文件（因为除了官网的，我都遇到过bug）\n\n链接如下：\n\n> There is a sample [`local.conf`](https://docs.openstack.org/devstack/latest/_downloads/d6fbba8d6ab5e970a86dd2ca0b884098/local.conf) file under the *samples* directory in the devstack repository.\n\n\n\n### 运行./stack.sh进行安装\n\n中间肯定会遇到各种错误，注意看error报错挨个解决\n\n解决错误后依次运行\n\n```\n./clean.sh./unstack.sh./stack.sh\n```\n\n推荐翻墙后用google查找错误原因\n\n\n\n\n\n### 安装成功\n\n安装成功后，命令行显示\n\n```\n=========================\nDevStack Component Timing (times are in seconds)  \n=========================\nwait_for_service      10\nasync_wait            72\nosc                  180\napt-get               37\ntest_with_retry        5\ndbsync                 5\npip_install           64\napt-get-update         3\nrun_process           19\n-------------------------\nUnaccounted time     246\n=========================\nTotal runtime        641\n================= Async summary================= \nTime spent in the background minus waits: 254 sec \nElapsed time: 641 sec Time \nif we did everything serially: 895 sec \nSpeedup:  1.39626\nThis is your host IP address: 172.25.177.58\nThis is your host IPv6 address: 2001:250:5800:1002::13:edb7\nHorizon is now available at http://172.25.177.58/\ndashboardKeystone is serving at http://172.25.177.58/identity/\nThe default users are: admin and demoThe \npassword: nomoresecret\nServices are running under systemd unit files.\nFor more information see: https://docs.openstack.org/devstack/latest/systemd.html\nDevStack Version: zedChange: aac6b6c7912b3feae4b68789508bee4bf1544731 Merge \"Drop setup.py and setup.cfg\" 2022-03-29 17:50:05 +0000OS \nVersion: Ubuntu 21.10 impish\n```\n\n打开提示的网址\n\n![image-20220330175232522](ubuntu利用devstack搭建openstack/image-20220330175232522.png)\n\n输入用户名和密码，进入oepnsack\n\n![image-20220330175332327](ubuntu利用devstack搭建openstack/image-20220330175332327.png)\n\n恭喜创建成功\n\n\n\n## 结论分析与体会\n\nOpenstack的部署确实不容易，经常出现很多奇怪的bug\n\n不过部署完成之后，对linux各种命令更加熟悉了\n\n\n\n## 参考\n\n[超详细ubuntu20安装搭建openstack](https://blog.csdn.net/qq_53348314/article/details/123021856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164861432216781683951230%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164861432216781683951230&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-123021856.142^v5^pc_search_result_cache,143^v6^control&utm_term=devstack%E9%83%A8%E7%BD%B2openstack&spm=1018.2226.3001.4187)\n\n[使用DevStack安装OpenStack在单机上组建私有云](https://blog.csdn.net/qq_41773806/article/details/116561060?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164862894416782089377664%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164862894416782089377664&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-116561060.142^v5^pc_search_result_cache,143^v6^control&utm_term=devstack%E9%83%A8%E7%BD%B2openstack&spm=1018.2226.3001.4187)\n\n[devstack官方手册](https://docs.openstack.org/devstack/latest/)\n","tags":["费劲巴拉的"],"categories":["云计算"]},{"title":"云计算作业二","url":"/2022/03/21/云计算作业二/","content":"\n\n\n# 作业2\n\n+ 列举威胁作用者有哪些，并简要说明\n+ 列举云安全威胁有哪些，并简要说明\n\n\n\n<!--more-->\n\n## 威胁作用者\n\n定义：威胁作用者(threat agent)：是引发威胁的实体，因为它能够实施攻击。\n\n+ 内部 / 外部\n+ 人 / 软件程序\n\n\n\n主要威胁作用者\n\n+ 匿名攻击者(anonymous attacker)：是云中没有权限、不被信任的云服务用户。\n+ 恶意服务作用者(malicious service agent)：能截取并转发云内的网络流量。\n+ 授信的攻击者(trusted attacker)：又称恶意租户(malicious tenant)，与同一云环境中的云用户共享IT资源，试图利用合法的证书来把云提供者、以及与他们共享IT资源的云租户作为攻击目标。\n+ 恶意的内部人员(malicious insider)：是人为的威胁作用者，他们的行为代表云提供者，或者与之有关。\n\n\n\n## 云安全威胁\n\n+ 流量窃听(traffic eavesdropping)：指当数据在传输到云中或在云内部传输时（通常是从云用户到云提供者），被恶意的服务作用者被动地截获，用于非法的信息收集。\n+ 恶意媒介(malicious intermediate)：是指消息被恶意服务作用者截获并篡改，因此可能会破坏消息的保密性和完整性。\n\n+ 拒绝服务(DoS)：攻击的目标是使IT资源过载至无法正确运行，发起形式包括：\n\n  –云服务上的负载由于伪造的消息或重复的通信请求不正常的增加。\n\n  –网络流量过载，降低了响应性，性能下降。\n\n  –发出多个云服务请求，每个请求都设计成消耗过量的内存和处理资源。\n\n+ 授权不足：是指错误的授予了攻击者访问权限，或是授权太宽泛，导致攻击者能够访问本应该受到保护的IT资源。\n  + 变种：弱认证，使用弱密码或共享账户\n+ 虚拟化攻击(Virtualization attack)：利用虚拟化平台的漏洞来危害虚拟化平台的保密性、完整性和可用性。\n+ 信任边界重叠：如果云中的物理IT资源是由不同的云服务共享的，那么这些云服务用户的信任边界是重叠的。恶意的云服务用户可以把目标设定为共享的IT资源，意图损害其他共享同样信任边界的云服务用户或IT资源\n\n","tags":["作业"],"categories":["云计算"]},{"title":"文章的发布","url":"/2022/03/14/文章的发布/","content":"\n# 云计算实验报告\n\n### 实验目的\n\n完成作业一，并发布到个人博客上\n\n个人博客的发布\n\n<!-- more -->\n\n### 个人信息\n\n学号：201900130068\n\n姓名：曹玉雯\n\n班级：19.2\n\n实验题目：Github + Hexo搭建个人博客系统\n\n实验日期：22.03.09\n\n\n\n### 硬件环境\n\n联网计算机一台\n\n### 软件环境\n\nWindows 10\n\n\n\n### 实验步骤与内容\n\n\n\n#### 新建一个md文档\n\n```\nhexo n 云计算作业一\n```\n\n\n\n#### 编写作业内容\n\n通过上网查询和翻阅ppt的方式完成作业\n\n\n\n#### 优化博客框架\n\n下载一个新的主题\n\n进入 `hexo` 的博客目录，然后将 `next` 仓库克隆至 `themes` 目录下：\n\n```\n$ cd Blog\n$ git clone https://github.com/theme-next/hexo-theme-next.git themes/next\n```\n\n打开站点配置文件 `_config.yml` (Blog目录下) ，找到 `theme`，修改为 `next`\n\n\n\n设置菜单界面\n\n在主题配置文件中找到 `Menu Settings` 部分，然后将 `categories`, `tags`、`schedule` 前面的注释去掉\n\n在 `next` 主题中手动生成这三个界面(`pages`)\n\n```\n$ hexo new page categories tags schedule\n```\n\n\n\n修改md文档头，为文档添加分类\n\n```\ntitle: 云计算作业一\ndate: 2022-03-14 16:17:00\ncatelories: 云计算\ntags\n```\n\n\n\n图片显示问题\n\n下载插件\n\n```\nnpm install hexo-asset-image --save\n```\n\n在md文档中编辑时建立同名文件夹用于存储照片，并使用相对路径索引\n\n\n\n#### 生成并发布博客内容\n\n```\nhexo g\nhexo d\n```\n\n期间遇到了hexo d时，github连接不稳定的情况\n\n通过科学上网设置代理解决\n\n```\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:7890\ngit config --global https.https://github.com.proxy socks5://127.0.0.1:7890\n```\n\n\n\n### 结论分析与体会\n\nhexo文档支持各种不同主题和文件分类等功能\n\nmd的文档本身也有很丰富且强大的编辑功能\n\n","categories":["云计算"]},{"title":"云计算作业一","url":"/2022/03/14/云计算作业一/","content":"\n\n\n### 作业1\n\n1. 云使能技术包括哪些技术组件？用一句话简要概括说明其关键特征\n2. 列举至少3种虚拟化软件，并用一句话概括其特点\n\n<!-- more -->\n\n\n\n####  云使能技术包括哪些技术组件？用一句话简要概括说明其关键特征\n\n+ 宽带网络和Internet架构\n  + 互联网或Internet允许远程供给IT资源，并直接支持无处不在的网络接入。\n+ 数据中心技术\n  + 现代数据中心是指一种特殊的IT基础设施，用于集中放置IT资源，包括：**服务器（services）、数据库（data-bases）、网络与通信设备（networking and telecommunication devices）**以及**软件系统（software system）**。\n+ 虚拟化技术\n  + 服务器虚拟化是指利用虚拟化软件将IT硬件抽象为虚拟服务器。\n  + 虚拟化提供了硬件无关性、服务器整合、资源复制、对资源池更强的支持和灵活的可扩展性。\n  + 实现虚拟服务器既可以采用基于操作系统的虚拟化，也可以采用基于硬件的虚拟化。\n+ Web技术\n  + Web技术经常被用于云服务的实现，并在前段用于远程管理云IT资源。\n  + Web架构的基本技术包括URL、HTTP、HTML和XML。\n+ 多租户技术\n  + 使多个用户在逻辑上同时访问同一个应用，每个用户对其使用、管理和定制的应用程序都有自己的视图，是该软件的一个专有实例，同时每个租户都意识不到还有其他租户在使用该应用。\n+ 服务技术\n  + 基于Web的服务(如Web服务和REST服务)依靠非专有通信和技术接口定义来建立基于Web技术的标准通信框架。\n  + 服务代理提供事件驱动运行时处理，适用于云中大量的功能。许多代理都自动部署在操作系统和基于云的产品中。\n  + 服务中间件(如ESB和业务流程平台)可以在云上部署。\n\n\n\n#### 虚拟化软件\n\nCitrix XenServer\n微软 Windows Server 2008 Hyper-V\nVMware ESX Server 这是最常用的\n\n总特点：\n将服务器物理资源抽象成逻辑资源，让一台服务器变成几台甚至上百台相互隔离的虚拟服务器，或者让几台服务器变成一台服务器来用，我们不再受限于物理上的界限，而是让CPU、内存、磁盘、I/O等硬件变成可以动态管理的“资源池”，从而提高资源的利用率，简化系统管理，实现服务器整合，让IT对业务的变化更具适应力\n\n各自特点\n\n+ VMware ESX ServerESX Server\n  运行在服务器裸机上，是基于硬件之上的架构。属于企业级应用。用同一台服务器底层硬件，划分出若干虚机，集中管理，很方便的做集群，负载均衡，热迁移等功能。\n\n+ XenCenter\n\n  是Citrix的虚拟化图形接口管理工具，可在同一界面，管理多台的XenServer服务器。管理上，通常会先在XenCenter建立一个服务器群组(Pool)，然后将位于同一机房内的XenServer服务器加入。\n  和大多数服务器半虚拟化产品相同的是，当数台XenServer服务器连接到同一台共享磁盘驱动器，且将虚拟档案放置于此的前提下，可以通过Xen-Motion这项功能，将虚拟机以手动方式在线转移到其它的XenServer服务器，从事主机的维护，或者降低硬件资源的消耗。\n\n+ 微软Hyper-V虚拟化平台，\n\n  以Xen的虚拟化技术为基础开发而成的，而这个虚拟化平台目前已整合在64位的Windows Server 2008操作系统\n","tags":["作业"],"categories":["云计算"]},{"url":"/2022/03/14/操作系统课设/","content":"# 操作系统课设\n\n\n\n# Nachos系统总结\n\n\n\n## 中断控制器\n\n1、几个供外部程序使用的调用接口； \n\n（1）Interrupt::SetLevel(IntOff)：用于关中断； \n\n（2）Interrupt::SetLevel(IntOn)：用于开中断，并返回原中断的开关状态；外部程 序可通过调用这两个接口实现一些原子操作； \n\n（3）Interrupt::Halt()：实现停机操作； \n\n（4）Interrupt::Idle()：相当于一般操作系统中的 idle 进程；\n\n\n\n### 中断响应时机\n\n（1）中断状态从关到开； \n\n（2）Nachos 的 CPU 执行完一条应用程序指令； \n\n因为只有上述两种情况发生时，系统时钟才增量（Interrupt::OneTick()，对于第一 种情况，增 10 个 ticks，第二种情况增 1 个 ticks），这时 Nachos 中断控制器才检查是 否有中断到期，如果有，则响应之；\n\n\n\n## 线程的状态\n\nNachos的进程在生命其中包括5个状态\n\nJUST_CREADT：刚new\n\nRUNNING：\n\nREADY：\n\nBLOCKED：\n\n\n\nJUST_CREAT->READY\n\n```\nReadyToRun()\n```\n\nBLOCKED->READY\n\n```\nSemaphore::V()\n```\n\nRUNNING->READY\n\n```\nThread::Yield()\n```\n\n\n\nRUNNING->BOLOCKED\n\n```\nThread::Sleep()\n```\n\n\n\n\n\n# 实验一 Nachos系统的安装与调试\n\n\n\n## 目的\n\n（1）安装编译 Nachos 系统，理解 Nachos 系统的组织结构与安装过程； \n\n（2）安装测试 gcc MIPS 交叉编译器； \n\n（3）掌握利用 Linux 调试工具 GDB 调试跟踪 Nachos 的执行过程； \n\n（4）安装成功后，根据 Nachos 的输出结果，分析分析跟踪 Nachos 的 C++程序及汇编代码，理解 Nachos 中线程的创建方法以及上下文切换的过程。 \n\n（5）阅读 Nachos 的相关源代码，理解 Nachos 内核的启动与停机过程。 \n\n（6）理解 Nachos 的运行参数的含义与使用。\n\n\n\n## 任务\n\n（1） 安装 Linux 操作系统； \n\n（2） 安装 Nachos 及 gcc mips 交叉编译程序； \n\n（3） 编译测试 Nacho，并理解 Nachos 的运行参数的含义与使用； \n\n（4） 运行 Nachos，根据 Nachos 的输出，理解 Nachos 中第一个线程是如何产生的。理解并掌握 Nachos 中其它内核线程的创建方法；理解 idle 线程的创建与作用。 进而理解一个实际的操作系统（如 Windows、Linux 等）的第一个进程是 如何产生的，以及 ideler 进程的创建与使用。 \n\n（5） 理解 Nachos 中的上下文切换过程； \n\n（6） 熟悉 gdb 调试工具；\n\n\n\n## 实验步骤\n\n### 安装nachos\n\n根据指导书操作\n\n最终结果\n\n![image-20220312173117116](操作系统课设/image-20220312173117116.png)\n\n\n\n## 问题\n\n（1）在你所生成的 Nachos 系统中，下述函数的地址是多少？并说明找到这些函\n数地址的过程及方法。\ni. InterruptEnable()\nii. SimpleThread()\niii. ThreadFinish()\niv. ThreadRoot()\n\n（2）下述线程对象的地址是多少？并说明找到这些对象地址的过程及方法。\ni. the main thread of the Nachos\nii. the forked thread created by the main thread\n\n（3）当主线程第一次运行 SWITCH()函数，执行到函数 SWITCH()的最后一条指\n令 ret 时，CPU 返回的地址是多少？ 该地址对应程序的什么位置？\n\n（4）当调用 Fork()新建的线程首次运行 SWITCH()函数时，当执行到函数\nSWITCH()的最后一条指令 ret 时，CPU 返回的地址是多少？ 该地址对应程序的什么\n位置？\n\n\n\n### 查询函数地址\n\n```\n(gdb) b InterruptEnable\nBreakpoint 1 at 0x3027: file thread.cc, line 242.\n(gdb) b SimpleThread\nBreakpoint 2 at 0x3275: file threadtest.cc, line 26.\n(gdb) b ThreadFinish\nBreakpoint 3 at 0x2ffc: file thread.cc, line 241.\n(gdb) b ThreadRoot\nBreakpoint 4 at 0x4e7c\n```\n\n\n\n### 查询对象地址\n\n主线程对象的地址\n\n```\n(gdb) p currentThread\n$1 = (Thread *) 0x56563ca0\n```\n\n\n\n主线程 fork的线程地址\n\n```\n42\tThreadTest()\n43\t{\n44\t    DEBUG('t', \"Entering SimpleTest\");\n45\t\n46\t    Thread *t = new Thread(\"forked thread\");\n47\t\n(gdb) l\n48\t    t->Fork(SimpleThread, 1);\n49\t    SimpleThread(0);\n50\t}\n51\t\n(gdb) b 48\nBreakpoint 9 at 0x56558327: file threadtest.cc, line 48.\n(gdb) print *t\n$2 = {stackTop = 0x8e30, machineState = {0, 0, -137625168, -135911936, \n    -137581328, -137541952, -137580576, -137789584, -137623792, -137623952, \n    -138281536, -135921024, -137160944, -135911792, -138496512, -138170064, \n    -138392816, -137958928}, stack = 0xf7e60250 <operator delete(void*)>, \n  status = 4156468720, \n  name = 0xf7c01220 <ssignal> \"\\363\\017\\036\\373S\\213D$\\b\\350K\"}\n(gdb) p t\n$3 = (Thread *) 0x5655df40\n\n```\n\n\n\n### 查询SWITCH函数返回地址\n\nSWITCH汇编代码\n\n```\n(gdb) disass SWITCH\nDump of assembler code for function SWITCH:\n=> 0x56559e86 <+0>:\tmov    %eax,0x5655e054\n   0x56559e8b <+5>:\tmov    0x4(%esp),%eax\n   0x56559e8f <+9>:\tmov    %ebx,0x8(%eax)\n   0x56559e92 <+12>:\tmov    %ecx,0xc(%eax)\n   0x56559e95 <+15>:\tmov    %edx,0x10(%eax)\n   0x56559e98 <+18>:\tmov    %esi,0x18(%eax)\n   0x56559e9b <+21>:\tmov    %edi,0x1c(%eax)\n   0x56559e9e <+24>:\tmov    %ebp,0x14(%eax)\n   0x56559ea1 <+27>:\tmov    %esp,(%eax)\n   0x56559ea3 <+29>:\tmov    0x5655e054,%ebx\n   0x56559ea9 <+35>:\tmov    %ebx,0x4(%eax)\n   0x56559eac <+38>:\tmov    (%esp),%ebx\n   0x56559eaf <+41>:\tmov    %ebx,0x20(%eax)\n   0x56559eb2 <+44>:\tmov    0x8(%esp),%eax\n   0x56559eb6 <+48>:\tmov    0x4(%eax),%ebx\n   0x56559eb9 <+51>:\tmov    %ebx,0x5655e054\n   0x56559ebf <+57>:\tmov    0x8(%eax),%ebx\n   0x56559ec2 <+60>:\tmov    0xc(%eax),%ecx\n   0x56559ec5 <+63>:\tmov    0x10(%eax),%edx\n   0x56559ec8 <+66>:\tmov    0x18(%eax),%esi\n   0x56559ecb <+69>:\tmov    0x1c(%eax),%edi\n   0x56559ece <+72>:\tmov    0x14(%eax),%ebp\n--Type <RET> for more, q to quit, c to continue without paging--ret\n   0x56559ed1 <+75>:\tmov    (%eax),%esp\n   0x56559ed3 <+77>:\tmov    0x20(%eax),%eax\n   0x56559ed6 <+80>:\tmov    %eax,(%esp)\n   0x56559ed9 <+83>:\tmov    0x5655e054,%eax\n   0x56559ede <+88>:\tret    \n   0x56559edf <+89>:\tnop\nEnd of assembler dump.\n\n```\n\neax中存储着新旧线程地址\n\n\n\n在<5>之后查看寄存器内容\n\n```\n(gdb) ni\n0x56559e8f in SWITCH ()\n(gdb) info r\neax            0x56563ca0          1448492192\necx            0xc                 12\nedx            0x9                 9\nebx            0x5655df40          1448468288\nesp            0xffffce6c          0xffffce6c\nebp            0xffffce98          0xffffce98\nesi            0x5655a2e3          1448452835\nedi            0x56563d00          1448492288\neip            0x56559e8f          0x56559e8f <SWITCH+9>\neflags         0x296               [ PF AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n```\n\n\n\n\n\n在<44>之后查看寄存器信息\n\n```\n(gdb) ni\n0x56559eb6 in SWITCH ()\n(gdb) info r\neax            0x56563d00          1448492288\necx            0xc                 12\nedx            0x9                 9\nebx            0x56556a26          1448438310\nesp            0xffffce6c          0xffffce6c\nebp            0xffffce98          0xffffce98\nesi            0x5655a2e3          1448452835\nedi            0x56563d00          1448492288\neip            0x56559eb6          0x56559eb6 <SWITCH+48>\neflags         0x296               [ PF AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n```\n\n\n\n<77>行后查看寄存器信息\n\n```\n(gdb) ni\n0x56559ed6 in SWITCH ()\n(gdb) info r\neax            0x56559e78          1448451704\necx            0x56558027          1448443943\nedx            0x1                 1\nebx            0x0                 0\nesp            0x56568d50          0x56568d50\nebp            0x0                 0x0\nesi            0x56558275          1448444533\nedi            0x56557ffc          1448443900\neip            0x56559ed6          0x56559ed6 <SWITCH+80>\neflags         0x296               [ PF AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n```\n\n\n\n在<88>后查看下一条指令执行的地址，与<77>中eax存储的地址相同\n\n```\n(gdb) ni\n0x56559e78 in ThreadRoot ()\n```\n\n该地址为函数ThreadRoot的第一条汇编指令地址\n\n\n\n### Fork后运行SWICH的返回地址\n\n输入c后继续运行，查看第二次switch函数的返回地址\n\n```\n0x56559ede in SWITCH ()\n(gdb) ni\n0x56556a26 in Scheduler::Run (this=0x56563c80, nextThread=0x56563d00)\n    at scheduler.cc:116\n116\t    SWITCH(oldThread, nextThread);\n(gdb) l\n111\t    // This is a machine-dependent assembly language routine defined \n112\t    // in switch.s.  You may have to think\n113\t    // a bit to figure out what happens after this, both from the point\n114\t    // of view of the thread and from the perspective of the \"outside world\".\n115\t\n116\t    SWITCH(oldThread, nextThread);\n117\t    \n118\t    DEBUG('t', \"Now in thread \\\"%s\\\"\\n\", currentThread->getName());\n119\t\n120\t    // If the old thread gave up the processor because it was finishing,\n(gdb) \n\n```\n\n查看run的汇编代码\n\n```\ndisass Run\nDump of assembler code for function Scheduler::Run(Thread*):\n   0x56556996 <+0>:\tendbr32 \n   0x5655699a <+4>:\tpush   %ebp\n   0x5655699b <+5>:\tmov    %esp,%ebp\n   0x5655699d <+7>:\tpush   %esi\n   0x5655699e <+8>:\tpush   %ebx\n   0x5655699f <+9>:\tsub    $0x10,%esp\n   0x565569a2 <+12>:\tcall   0x565562f0 <__x86.get_pc_thunk.bx>\n   0x565569a7 <+17>:\tadd    $0x7599,%ebx\n   0x565569ad <+23>:\tlea    0xf4(%ebx),%eax\n   0x565569b3 <+29>:\tmov    (%eax),%eax\n   0x565569b5 <+31>:\tmov    %eax,-0xc(%ebp)\n   0x565569b8 <+34>:\tsub    $0xc,%esp\n   0x565569bb <+37>:\tpushl  -0xc(%ebp)\n   0x565569be <+40>:\tcall   0x56557c8c <Thread::CheckOverflow()>\n   0x565569c3 <+45>:\tadd    $0x10,%esp\n   0x565569c6 <+48>:\tlea    0xf4(%ebx),%eax\n   0x565569cc <+54>:\tmov    0xc(%ebp),%edx\n   0x565569cf <+57>:\tmov    %edx,(%eax)\n   0x565569d1 <+59>:\tlea    0xf4(%ebx),%eax\n   0x565569d7 <+65>:\tmov    (%eax),%eax\n   0x565569d9 <+67>:\tsub    $0x8,%esp\n   0x565569dc <+70>:\tpush   $0x1\n--Type <RET> for more, q to quit, c to continue without paging--ret\n   0x565569de <+72>:\tpush   %eax\n   0x565569df <+73>:\tcall   0x56556ade <Thread::setStatus(ThreadStatus)>\n   0x565569e4 <+78>:\tadd    $0x10,%esp\n   0x565569e7 <+81>:\tsub    $0xc,%esp\n   0x565569ea <+84>:\tpushl  0xc(%ebp)\n   0x565569ed <+87>:\tcall   0x56556afc <Thread::getName()>\n   0x565569f2 <+92>:\tadd    $0x10,%esp\n   0x565569f5 <+95>:\tmov    %eax,%esi\n   0x565569f7 <+97>:\tsub    $0xc,%esp\n   0x565569fa <+100>:\tpushl  -0xc(%ebp)\n   0x565569fd <+103>:\tcall   0x56556afc <Thread::getName()>\n   0x56556a02 <+108>:\tadd    $0x10,%esp\n   0x56556a05 <+111>:\tpush   %esi\n   0x56556a06 <+112>:\tpush   %eax\n   0x56556a07 <+113>:\tlea    -0x3e7c(%ebx),%eax\n   0x56556a0d <+119>:\tpush   %eax\n   0x56556a0e <+120>:\tpush   $0x74\n   0x56556a10 <+122>:\tcall   0x565581e8 <DEBUG(char, char const*, ...)>\n   0x56556a15 <+127>:\tadd    $0x10,%esp\n   0x56556a18 <+130>:\tsub    $0x8,%esp\n   0x56556a1b <+133>:\tpushl  0xc(%ebp)\n   0x56556a1e <+136>:\tpushl  -0xc(%ebp)\n   0x56556a21 <+139>:\tcall   0x56559e86 <SWITCH>\n--Type <RET> for more, q to quit, c to continue without paging--ret\n=> 0x56556a26 <+144>:\tadd    $0x10,%esp\n   0x56556a29 <+147>:\tlea    0xf4(%ebx),%eax\n   0x56556a2f <+153>:\tmov    (%eax),%eax\n   0x56556a31 <+155>:\tsub    $0xc,%esp\n   0x56556a34 <+158>:\tpush   %eax\n   0x56556a35 <+159>:\tcall   0x56556afc <Thread::getName()>\n   0x56556a3a <+164>:\tadd    $0x10,%esp\n   0x56556a3d <+167>:\tsub    $0x4,%esp\n   0x56556a40 <+170>:\tpush   %eax\n   0x56556a41 <+171>:\tlea    -0x3e51(%ebx),%eax\n   0x56556a47 <+177>:\tpush   %eax\n   0x56556a48 <+178>:\tpush   $0x74\n   0x56556a4a <+180>:\tcall   0x565581e8 <DEBUG(char, char const*, ...)>\n   0x56556a4f <+185>:\tadd    $0x10,%esp\n   0x56556a52 <+188>:\tlea    0xf8(%ebx),%eax\n   0x56556a58 <+194>:\tmov    (%eax),%eax\n   0x56556a5a <+196>:\ttest   %eax,%eax\n   0x56556a5c <+198>:\tje     0x56556a90 <Scheduler::Run(Thread*)+250>\n   0x56556a5e <+200>:\tlea    0xf8(%ebx),%eax\n   0x56556a64 <+206>:\tmov    (%eax),%esi\n   0x56556a66 <+208>:\ttest   %esi,%esi\n   0x56556a68 <+210>:\tje     0x56556a84 <Scheduler::Run(Thread*)+238>\n   0x56556a6a <+212>:\tsub    $0xc,%esp\n--Type <RET> for more, q to quit, c to continue without paging--\n\n```\n\n发现返回地址对应于run中调用函数SWITCH后紧跟着的一条指令\n\n重复上述过程发现，SWITCH返回地址均与第二次运行后结果相同\n\n\n\n通过阅读源码可知\n\n```\nvoid\nSimpleThread(_int which)\n{\n    int num;\n    \n    for (num = 0; num < 5; num++) {\n\tprintf(\"*** thread %d looped %d times\\n\", (int) which, num);\n        currentThread->Yield();\n    }\n}\n```\n\nSWITCH函数用于交替执行这个函数\n\n子线程第一次返回时，返回进入函数头部\n\n之后交替执行\n\n\n\n# 实验二 Nachos的MAKEFILES\n\n目的与任务\n该实验在目录 lab2 中完成。\n（1）熟悉 Nachos 的 makefiles 的结构；\n（2）熟悉如何在几个 lab 文件目录中构造相应的 Nachos 系统；\n\n\n\n## 学习总结\n\n1. code/下子目录中的Makefile文件主要内容\n\n   + include Makefile.local\n\n   + include ../Makefile.common\n\n     将父目录下的 Makefile.common 包含了进来\n\n2. makefile.local文件\n\n   + 主要作用：对一些编译、链接及运行时所使用的宏进行定义\n   + CCFILES：指明在该目录下生成Nachos时所涉及到的C++源文件\n   + INCPATH：指明所涉及的C++源程序中的头文件（.h文件）所在路径\n   + DEFINES：传递g++的一些标号或宏\n\n3. Makefile.dep文件\n\n   + 获取操作平台\n   + 给出gcc mips交叉编译器所在的路径及前缀\n   + arch文件下三个文件夹分别存放\n     + 可执行文件（nachos）\n     + 依赖文件（dependence files，如xxxx.d）\n     + 目标文件（object files，如xxx.o）\n   + code/子目录下生成可执行文件的链接文件\n\n4. Makfile.common文件，定义了编译链接生成一个完整的Nachos可执行文件所需要的所有规则\n\n\n\n### 在其他目录中修改Nachos代码并生成系统\n\nlab1和lab2在code/thread下完成\n\nlab3在code/monitor下完成\n\nlab4和lab5在code/filesys下完成\n\nlab、lab7和lab8在code/userprog下完成\n\n\n\n### 修改INPATH\n\n如若不修改INPATH\n\n若修改xxxx.h文件，重新编译后只有同文件夹下的xxxx.cc文件会关联\n\n其他文件中的头文件若包含xxxx.h文件，会优先寻找本文件夹下的xxxx.h文件\n\n然后从 -I../threads -I../machine  两个文件夹下寻找\n\n修改为\n\n```\nINCPATH += -I../<文件夹名> -I../threads -I../machine\n```\n\n找不到文件就从该路径左至右寻找。\n\n但该方法仍会导致只有目录lab2下的scheduler.cc使用lab2下的scheduler.h，其他目录中的.cc源文件仍然使用目录../threads下的scheduler.h\n\n\n\n### 寻找包含修改的.h文件的最小文件集\n\n```\ngrep scheduler.h *\nGrep选项：\n* : 表示当前目录所有文件，也可以是某个文件名\n-r 是递归查找\n-n 是显示行号\n-R 查找所有文件包含子目录\n-i 忽略大小写\n```\n\n可以检查哪些文件中包含字符串\n\n查找出包含修改后的.h文件的所有文件放入新建的文件夹中\n\n\n\n使用touch命令更新所修改的的文件\n\n```\n1．命令格式：\ntouch [选项]... 文件...\n2．命令参数：\n-a   或--time=atime或--time=access或--time=use 　只更改存取时间。\n-c   或--no-create 　不建立任何文档。\n-d 　使用指定的日期时间，而非现在的时间。\n-f 　此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。\n-m   或--time=mtime或--time=modify 　只更改变动时间。\n-r 　把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。\n-t 　使用指定的日期时间，而非现在的时间。\n3．命令功能：\ntouch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。 \n```\n\nmake\n\n再touch未修改的其他文件目录下的原文件\n\n重新make，观察nachos是否会被更新\n\n\n\n# 实验三 利用信号量实现线程同步\n\n## 目的 \n\n（1）进一步理解 Nachos 中如何创建线程； \n\n（2）理解 Nachos 中信号量与 P、V 操作是如何实现的 \n\n（3）如何创建与使用 Nachos 的信号量 \n\n（4）理解 Nachos 中是如何利用信号量实现 producer/consumer problem；\n\n（5）理解 Nachos 中如何测试与调试程序； \n\n（6）理解 Nachos 中轮转法（RR）线程调度的实现；\n\n\n\n## 设计步骤与要求\n\n1. 在 code/lab3 目录中， \n   + 详细阅读并深刻理解 ring.h 及 ring.cc 中的所有代码； \n   + 阅读并理解 main.cc 的功能；\n   + 详细阅读并深刻理解 prodcons++.cc 的程序结构，在 prodcons++.cc 中添加或 修改相应的代码，满足设计要求。（可依据其中的注释添加相应的代码） \n   + 利用 make 编译生成新的 Nachos，并测试其功能是否满足设计要求；\n\n2. 分析../threads/threadtest.cc，理解利用 Thread::Fork()创建线程的方法； \n\n   分析 Thread::Fork() ，理解内核创建线程的过程\n\n   分析../threads/synch.cc，理解 Nachos 中信号量是如何实现的； \n\n   分析../monitor/prodcons++.cc，理解信号量的创建与使用方法； \n\n   分析 Thread::Fork() , Thread::Yiled(), Thread::Sleep(), Thread::Finish() ,, Scheduler::  Scheduler::ReadyToRun(), Scheduler::FindNextToRun(), Scheduler::Run()等相关函数，理解线程调度及上下文切换的工作过程；\n\n3. 在理解上述 Nachos 工作机理的基础上，补充或修改目录 lab3 中 prodcons++.cc 中的代码，利用 Nachos 实现的线程与信号量机制完善一个 producer/consumer problem 测试程序。 \n4.  根据生产者/消费者问题的功能定义，你的实现应该满足如下条件: \n   + 生产者线程所产生的所有的消息，都应该被消费者接收并保存到输出文件 中（tem_0，temp_1，…） \n   + 每个消息只能被接收一次且在文件保存一次 \n   + 来自于同一个生产者的消息，以及被同一个消费者接收到的消息，在文件保存的顺序应该按其序号升序排列；\n\n\n\n## 实验过程\n\n```\n#define BUFF_SIZE 3  // the size of the round buffer\n#define N_PROD    2  // the number of producers \n#define N_CONS    2  // the number of consumers\n#define N_MESSG   4  // the number of messages produced by each producer\n```\n\n阅读代码可得\n\n+ 缓冲区大小为：3\n+ 生产者个数：2\n+ 消费者个数：2\n+ 每个生产者发送信息数：4\n\n\n\n### 理解信号量的实现\n\n```\nclass Semaphore {\n  public:\n    Semaphore(char* debugName, int initialValue);\t// 设置初值\n    ~Semaphore();   \t\t\t\t\t// de-allocate semaphore\n    char* getName() { return name;}\t\t\t// debugging assist\n    \n    void P();\t // 判断value是否大于0，否则加入queue队尾，睡眠当前线程\n    void V();\t // 返回队首线程，并设置状态为ready\n    \n  private:\n    char* name;        // debug的名字\n    int value;         // 信号量的值\n    List *queue;       // value为0时的等待队列\n};\n```\n\n信号量的实现\n\n关键操作为P、V操作\n\n+ P()的实现\n  + 判断value是否为0\n  + 若为0，则将当前线程加入queue队尾，并调用sleep函数睡眠\n  + 不为0，value--\n+ v()的实现\n  + 从queue队首拿出一个线程\n  + 若线程不为空，将其状态设置为READY\n  + value++\n\n\n\n### 修改prodcons++.cc的程序\n\n+ 参照monitor文件下prodcons++.cc文件的内容\n\n+ 根据生产者消费者模型\n\n修改程序如下（简要显示）\n\n```\nnempty = new Semaphore(\"nempty\",BUFF_SIZE);\nnfull = new Semaphore(\"nfull\",0);\nmutex = new Semaphore(\"mutex\",1);\n    \nring = new Ring(BUFF_SIZE);\n\nproducer {\n    for (num = 0; num < N_MESSG ; num++) {\n    \n      message->thread_id = which;\n      message->value = num;\n      \n      nempty->P();\n      mutex->P();\n\n      ring->Put(message);\n      printf(\"producer %d produce thread %d ---> valude d\\n\",which,which,num);\n\n      mutex->V();\n      nfull->V();\n\n    }\n}\n\nconsumer {\n    for (; ; ) {\n\n      nfull->P();\n      mutex->P();\n\n      ring->Get(message);\n      printf(\"consumer %d get thread %d ---> value %d\\n\",which,message->thread_id,message->value);\n\n      mutex->V();\n      nempty->V();\n}\n```\n\n修改文件\n\n可得实验结果\n\n![image-20220312220345657](操作系统课设/image-20220312220345657.png)\n\n\n\n### 分析并理解，Thread::Fork()创建线程的方法\n\n```\nvoid Thread::Fork(VoidFunctionPtr func, _int arg)\n{\n\n    DEBUG('t', \"Forking thread \\\"%s\\\" with func = 0x%x, arg = %d\\n\",  name, (int) func, arg);//设置debug信息\n    \n    StackAllocate(func, arg);//为线程分配栈\n\n    IntStatus oldLevel = interrupt->SetLevel(IntOff);//关中断\n    scheduler->ReadyToRun(this);\t// 将线程状态设置为ready并加入就绪队列\n    \n    (void) interrupt->SetLevel(oldLevel);//开中断\n}    \n```\n\nfork()\n\n新建一个线程并设置状态为ready（放入准备就绪队列）\n\n\n\n\n\nStackAllocate(func, arg);//为线程分配栈\n\n```\n\tmachineState[PCState] = (_int) ThreadRoot;//函数入口\n    machineState[StartupPCState] = (_int) InterruptEnable;\n    machineState[InitialPCState] = (_int) func;//函数运行体\n    machineState[InitialArgState] = arg;\n    machineState[WhenDonePCState] = (_int) ThreadFinish;//函数结束出口\n```\n\n\n\n其他Thread和scheduler的函数分析请见备注\n\n### -rs轮转调度\n\n```\nelse if (!strcmp(*argv, \"-rs\")) {\n\t    ASSERT(argc > 1);\n\t    RandomInit(atoi(*(argv + 1)));\t// initialize pseudo-random\n\t\t\t\t\t\t// number generator\n\t    randomYield = TRUE;\n\t    argCount = 2;\n\t}\n```\n\n-rs后可跟数字，作为随机数初始化种子\n\n![image-20220313005518934](操作系统课设/image-20220313005518934.png)\n\n可以看到与上次运行结果确实不同，在producer0产生的消息未填满缓冲区时就发生了调度\n\n通过阅读Interrupt的源码可知，nachos中断响应的时机\n\n+ 中断状态从关到开\n+ Nachos的CPU执行完一条应用程序指令\n\n上述两种情况发生时，系统时钟调用Interrupt::OneTick()。\n\n同时检查是否有中断到期，有则响应\n\n```\nif (yieldOnReturn) {\t\t// if the timer device handler asked \n\t\t\t\t\t// for a context switch, ok to do it now\n\tyieldOnReturn = FALSE;\n \tstatus = SystemMode;\t\t// yield is a kernel routine\n\tcurrentThread->Yield();\n\tstatus = old;\n    }\n```\n\n此时发生程序调度，当前进程转为READY状态，运行下一个就绪进程\n\n\n\n## 备注\n\n### C语言函数\n\nsprintf\n\n```\nint sprintf(char *str, const char *format, ...) \n发送格式化输出到 str 所指向的字符串\n```\n\n实例\n\n```\n#include <stdio.h>\n#include <math.h>\n\nint main()\n{\n   char str[80];\n\n   sprintf(str, \"Pi 的值 = %f\", M_PI);\n   puts(str);\n   \n   return(0);\n}\n\nPi 的值 = 3.141593\n```\n\n\n\natoi\n\n```\nint atoi(const char *str)\n```\n\n把参数 **str** 所指向的字符串转换为一个整数（类型为 int 型）。\n\n```\nint main()\n{\n   int val;\n   char str[20];\n   \n   strcpy(str, \"98993489\");\n   val = atoi(str);\n   printf(\"字符串值 = %s, 整型值 = %d\\n\", str, val);\n\n   strcpy(str, \"runoob.com\");\n   val = atoi(str);\n   printf(\"字符串值 = %s, 整型值 = %d\\n\", str, val);\n\n   return(0);\n}\n\n字符串值 = 98993489, 整型值 = 98993489\n字符串值 = runoob.com, 整型值 = 0\n```\n\n\n\n## 上下文切换相关函数实现的分析\n\n### Thread::Yield()\n\n```\nvoid\nThread::Yield ()\n{\n    Thread *nextThread;\n    IntStatus oldLevel = interrupt->SetLevel(IntOff);//关中断\n    \n    ASSERT(this == currentThread);//判断本进程是否为当前进程\n    \n    DEBUG('t', \"Yielding thread \\\"%s\\\"\\n\", getName());//设置debug信息\n    \n    nextThread = scheduler->FindNextToRun();//在就绪队列中找到下一个可运行进程\n    if (nextThread != NULL) {//若下一个可运行进程不为空\n\t\tscheduler->ReadyToRun(this);//设置本进程状态为READY\n\t\tscheduler->Run(nextThread);//运行下一个进程\n    }\n    (void) interrupt->SetLevel(oldLevel);//开中断\n}\n```\n\n\n\n### Scheduler::Run (Thread *nextThread)\n\n```\nvoid\nScheduler::Run (Thread *nextThread)\n{\n    Thread *oldThread = currentThread;\n    \n    oldThread->CheckOverflow();\t\t    // 检查旧进程是否有不可删除的栈溢出\n\t\t\t\t\t    // had an undetected stack overflow\n\n    currentThread = nextThread;\t\t    // 宏变量当前进程设置为即将运行的进程\n    currentThread->setStatus(RUNNING);      // 设置本进程状态为RUNNING\n    \n    DEBUG('t', \"Switching from thread \\\"%s\\\" to thread \\\"%s\\\"\\n\",\n\t  oldThread->getName(), nextThread->getName());\n    \n    //阅读汇编代码\n    SWITCH(oldThread, nextThread);//交换两个进程的状态\n    //返回nextThread的执行\n    \n    DEBUG('t', \"Now in thread \\\"%s\\\"\\n\", currentThread->getName());\n\n    // 处理完成运行的旧线程\n    if (threadToBeDestroyed != NULL) {\n        delete threadToBeDestroyed;\n\t\tthreadToBeDestroyed = NULL;\n    }\n    \n}\n```\n\n\n### Thread::finish()\n\n```\nvoid\nThread::Finish ()\n{\n    (void) interrupt->SetLevel(IntOff);\t\t\n    ASSERT(this == currentThread);\n    \n    DEBUG('t', \"Finishing thread \\\"%s\\\"\\n\", getName());\n    \n    threadToBeDestroyed = currentThread;\n    Sleep();\t\t\t\t\t// invokes SWITCH\n    // not reached\n}\n```\n\n\n\n### Thread::sleep()\n\n```\nvoid\nThread::Sleep ()\n{\n    Thread *nextThread;\n    \n    ASSERT(this == currentThread);\n    ASSERT(interrupt->getLevel() == IntOff);\n    \n    DEBUG('t', \"Sleeping thread \\\"%s\\\"\\n\", getName());\n\n    status = BLOCKED;\n    while ((nextThread = scheduler->FindNextToRun()) == NULL)\n\tinterrupt->Idle();\t// no one to run, wait for an interrupt\n        \n    scheduler->Run(nextThread); // returns when we've been signalled\n}\n```\n\n+ 当前进程设置状态为 BLOCKED\n\n+ 寻找下一个可执行进程并运行\n+ 若找不到可执行进程，等待一个中断\n\nThread::Sleep()只是将当前线程的状态设置为 BLOCKED，然后调度下一 个线程执行；\n\n（目前 Sleep()在信号量的 P、V 操作、Thread::Finish()调用）；\n\n\n\n### Thread::FindNextToRun()\n\n```\nThread *\nScheduler::FindNextToRun ()\n{\n    return (Thread *)readyList->Remove();\n}\n```\n\n在就绪队列中返回队首的就绪线程，并将该线程在就绪队列中移除\n\n\n\n\n\n# 实验四 Nachos 的文件系统\n\n\n\n## 实验目的\n\n1. 理解 Nachos 硬盘是如何创建的； \n2. 熟悉查看 Nachos 硬盘上的内容的方法； \n3. 理解硬盘初始化的过程（如何在硬盘上创建一个文件系统）； \n4. 了解 Nachos 文件系统提供了哪些命令，哪些命令已经实现，哪些需要你自 己实现； \n5. 理解已经实现的文件系统命令的实现原理； \n6. 理解硬盘空闲块的管理方法； \n7. 理解目录文件的结构与管理；\n8.  理解文件的结构与文件数据块的分配方法； \n9. 了解一个文件系统命令执行后，硬盘的布局； \n10. 分析目前 Nachos 不能对文件进行扩展的原因，考虑解决方案；\n\n\n\n\n\n## 任务\n\nNachos实现了两个版本的文件系统\n\n+ FILESYS_STUB：直接利用UNIX所提供的系统调用实现\n+ FILESYS：通过Openfile类对DISK上的文件进行操作，尽管最终也是使用系统调用\n\n\n\n### 硬盘初始化\n\n（1）../lab5/main.cc 调用了../threads/system.cc 中的 Initialize()创建了硬盘 DISK。 分析../threads/synchdisk.cc 及../machine/disk.cc，理解 Nachos 创建硬盘的过程与方法；\n\n```\nDisk::Disk(char* name, VoidFunctionPtr callWhenDone, _int callArg)\n{\n    int magicNum;\n    int tmp = 0;\n\n    DEBUG('d', \"Initializing the disk, 0x%x 0x%x\\n\", callWhenDone, callArg);\n    handler = callWhenDone;\n    handlerArg = callArg;\n    lastSector = 0;\n    bufferInit = 0;\n    \n    fileno = OpenForReadWrite(name, FALSE);\n    if (fileno >= 0) {\t\t \t// 文件存在，检查magicNum\n\t\tRead(fileno, (char *) &magicNum, MagicSize);//获取前四个字节 Sizeof(int)\n\t\tASSERT(magicNum == MagicNumber);\n    } else {\t\t\t\t// 文件不存在，创建文件\n        fileno = OpenForWrite(name);\n\t\tmagicNum = MagicNumber;  \n\t\tWriteFile(fileno, (char *) &magicNum, MagicSize); // 写入magicNum\n\n\t// need to write at end of file, so that reads will not return EOF\n        Lseek(fileno, DiskSize - sizeof(int), 0);\t\n\t\tWriteFile(fileno, (char *)&tmp, sizeof(int));  \n    }\n    active = FALSE;\n}\n```\n\n创建一个文件用来当硬盘\n\n+ 若文件存在，检查magicNum\n+ 若文件不存在，创建文件\n\n\n\n### 硬盘大小\n\n```\n#define SectorSize \t\t128\t// 每个扇区的字节数\n#define SectorsPerTrack \t32\t// 每道的扇区数\n#define NumTracks \t\t32\t// 硬盘的道数\n#define NumSectors \t\t(SectorsPerTrack * NumTracks)\n\n#define MagicNumber \t0x456789ab\n#define MagicSize \tsizeof(int) //4字节大小\n\n#define DiskSize \t(MagicSize + (NumSectors * SectorSize))\n```\n\n总扇区数：32*32=1024\n\n硬盘大小：（4+32*32*128）B/1024=0x80KB\n\n\n\n### Nachos的文件系统命令\n\n（2）分析../lab5/main.cc，了解 Nachos 文件系统提供了哪些命令，对每个命令进行测试，根据执行结果观察哪些命令已经实现（正确运行），哪些无法正确运行（尚未 完全实现，需要你自己完善）；\n\n| 命令                                     | 作用                                                         |\n| ---------------------------------------- | ------------------------------------------------------------ |\n| -d f                                     | 可选参数[-d f]的作用是打印出所有与文件系统有关的调试信息。   |\n| nachos –cp UNIX_filename nachos_filename | 将一个 Unix 文件系统中的文 件 UNIX_filename 复制到 Nachos 文件系统中，重新命名为 nachos_filename |\n| nachos [-d f] –p nachos_filename         | 该命令输出 nachos 文件 nachos_filename 的内容，类似于 UNIX 中的 cat 命令 |\n| nachos [-d f] –r nachos_filename         | 删除 Nachos 文件 nachos_filename，类似于 UNIX 中的 rm 命令   |\n| nachos [-d f] -l                         | 输出当前目录中的文件名，类似于 DOS 中的 dir，UNIX 中的 ls    |\n| nachos [-d f] -t                         | 测试 Nachos 文件系统的性能（目前尚未实现）                   |\n| nachos [-d f] -D                         | 输出 Nachos 的文件系统在磁盘上的组织。打印出整个文件系统 的所有内容，包括位图文件（bitmap）、文件头（file header）、目录文件（directory） 和普通文件（file） |\n\n\n\n### 文件系统FileSystem的初始化\n\n（3）分析../filesys/filessys.cc，特别是构造函数 FileSystem::FileSystem(..)，理解 Nachos 硬盘”DISK”的创建及硬盘格式化（创建文件系统）的处理过程；\n\n```\n// 通过宏定义确定位示图文件头和文件目录表文件头的扇区位置\n#define FreeMapSector \t\t0\n#define DirectorySector \t1\n\nFileSystem::FileSystem(bool format)\n{ \n    DEBUG('f', \"Initializing the file system.\\n\");\n    if (format) {\n        BitMap *freeMap = new BitMap(NumSectors); //位示图\n        Directory *directory = new Directory(NumDirEntries); //文件目录表\n\t\tFileHeader *mapHdr = new FileHeader; //位示图的文件头\n\t\tFileHeader *dirHdr = new FileHeader; //文件目录表的文件头\n\n        DEBUG('f', \"Formatting the file system.\\n\");\n\n    // 首先，标记0号和1号扇区已被使用\n\t\tfreeMap->Mark(FreeMapSector);\t    \n\t\tfreeMap->Mark(DirectorySector);\n\n\t// 然后，为位示图数据块和根目录表分配空间，确保有足够的空间\n\t\tASSERT(mapHdr->Allocate(freeMap, FreeMapFileSize));\n\t\tASSERT(dirHdr->Allocate(freeMap, DirectoryFileSize));\n\n    // 将位图和文件目录表的文件头刷新回磁盘\n    // 在打开文件前就需要做这一步，否则在打开文件时，磁盘是脏的\n        DEBUG('f', \"Writing headers back to disk.\\n\");\n\t\tmapHdr->WriteBack(FreeMapSector);    \n\t\tdirHdr->WriteBack(DirectorySector);\n\n    // 现在可以打开位示图和文件目录表\n    // 文件系统操作假设在Nachos运行时这两个文件是打开的\n        freeMapFile = new OpenFile(FreeMapSector); \n        directoryFile = new OpenFile(DirectorySector);\n     \n\t// 当我们打开文件时，我们可以写每个文件的最初版本到硬盘上\n\t// 此时文件目录表是空的，但位示图会被改变（由于扇区已经被分配给了文件头\n        DEBUG('f', \"Writing bitmap and directory back to disk.\\n\");\n\t\tfreeMap->WriteBack(freeMapFile);\t // 写回硬盘\n\t\tdirectory->WriteBack(directoryFile);\n\n\t\tif (DebugIsEnabled('f')) {\n\t    \tfreeMap->Print();\n\t    \tdirectory->Print();\n\n       \t\tdelete freeMap; \n\t\t\tdelete directory; \n\t\t\tdelete mapHdr; \n\t\t\tdelete dirHdr;\n\t\t}\n    } else {\n    // 如果不是在建立硬盘的话，我们只需要打开文件就好\n        freeMapFile = new OpenFile(FreeMapSector);\n        directoryFile = new OpenFile(DirectorySector);\n    }\n}\n```\n\n### Nachos文件系统布局\n\n（4）利用命令 hexdump –C DISK 查看硬盘格式化后硬盘的布局，理解格式化硬盘所完成的工作，以及文件系统管理涉及到的一些数据结构组织与使用，如文件头 （FCB）、目录表与目录项、空闲块管理位示图等；\n\n​\t\t结合输出结果，分析 FileSystem::FileSystem(..)初始化文件系统时涉及到的几个模 块 ， 如 ../filesys/filehdr.h(filehdr.cc) ， directory.h(directory.cc) ， ../userprog/bitmap.h （bitmap.cc），**理解文件头（FCB）的结构与组织、硬盘空闲块管理使用的位示图文件、目录表文件及目录下的组织与结构**，以及它们在硬盘上的位置；\n\n| **扇区号** | **起止字节** | **内容描述**         | **内容**         | **大小** |\n| ---------- | ------------ | -------------------- | ---------------- | -------- |\n|            | 0x0~0x3      | 磁盘标识（魔数）     | 0x456789ab       | 4字节    |\n| 0          | 0x4~0x83     | 位示图文件头         | Class FileHeader | 128字节  |\n| 1          | 0x84~0x103   | 目录表文件头         | Class FileHeader | 128字节  |\n| 2          | 0x104~0x183  | 位示图文件数据块     | Class BitMap     | 128字节  |\n| 3          | 0x184~0x203  | 根目录表（目录文件） | Class Directory  | 128字节  |\n| 4          | 0x204~0x283  | 根目录表（目录文件） | Class Directory  | 128字节  |\n| 5          | 0x284~0x303  | 第一个文件的文件头   | Class FileHeader | 128字节  |\n| 6          | 0x304~0x383  | 第一个文件的数据块   |                  | 128字节  |\n| 7          |              | (文件需要的块数不定) | …….              |          |\n|            |              | 第二个文件的文件头   | Class FileHeader | 128字节  |\n|            |              | 第二个文件的数据块   |                  | 128字节  |\n|            |              | ……                   | ……               |          |\n|            |              | 第三个文件的文件头   | Class FileHeader | 128字节  |\n|            |              | 第三个文件的数据块   |                  | 128字节  |\n|            |              | …..                  | ……               |          |\n|            |              | 以此类推             |                  |          |\n|            |              |                      |                  |          |\n|            |              |                      |                  |          |\n\n\n\n在系统初始化后查看硬盘内容\n\n![image-20220314004009009](操作系统课设/image-20220314004009009.png)\n\n此时对应查看\n\n![image-20220314005505549](操作系统课设/image-20220314005505549.png)\n\n与DISK文件内容一致\n\n总结其布局\n\n文件系统 FileSystem\n\n+ 位示图 OpenFile* freeMapFile;\n+ 根目录 OpenFile* directoryFile;\n+ 打开文件 OpenFile 结构\n  + FileHeader *hdr;\t\t\t// 文件头\n  + int seekPosition;\t\t\t// 文件内的当前位置\n  + int hdrSector;\t\t\t\t// 文件头所在扇区\n    + FileHeader 文件头结构\n      + int numBytes;\t\t\t// 文件大小，单位：字节\n      + int numSectors;\t\t\t// 文件的逻辑块数\n      + int dataSectors[NumDirect];\t\t// 数据块所在扇区列表\n\n#### 三元组信息\n\n+ 文件头\n  + 文件大小 int\n  + 占用扇区数 int\n  + 数据块所在扇区列表  int*30\n\n+ 位示图\n+ 文件目录项\n  + inUse bool （但为了对齐，编译器分配了4字节\n  + 扇区号 int\n  + 名字 9+1=10 字节\n  + 为了对齐 共20字节\n\n\n\n### 更多的验证\n\n（5）利用命令 nachos –cp ../test/small samll 复制文件../test/small 到硬盘 DISK 中； \n\n![image-20220314010620035](操作系统课设/image-20220314010620035.png)\n\n可以看到3号扇区增加一个文件目录项small\n\n| 文件名 | inUse | 文件头（索引节点）所在的扇区号 |\n| ------ | ----- | ------------------------------ |\n| small  | 1     | 5                              |\n\n5号扇区内保存small文件头内容\n\n5号扇区文件头\n\n+ 文件大小：54字节\n+ 分配扇区个数：1\n+ 扇区位置：6号扇区\n\n![image-20220314010126127](操作系统课设/image-20220314010126127.png)\n\n验证可得相同内容\n\n\n\n（6）利用命令 hexdump –C DISK 查看硬盘格式化后硬盘的布局，理解创建一个 文件后相关的结构在硬盘上的存储布局； \n\n![image-20220314011027327](操作系统课设/image-20220314011027327.png)\n\n文件目录表、位示图全部初始化为初始信息。\n\n（7）复制更多的文件到 DISK 中，然后删除一个文件，利用 hexdump –C DISK 查看文件的布局，分析文件系统的管理策略。\n\n复制small、big文件到DISK中，删除small文件，查看DISK内容\n\n![image-20220314010728426](操作系统课设/image-20220314010728426.png)\n\n删除文件samll后\n\n更改\n\n+ 位示图中扇区变为空闲\n+ 目录项变为空闲  isUse置0\n\n未更改\n\n+ 文件名、头文件所占扇区号均未清除\n+ 文件头信息、文件内容未清除\n\n\n\n分析文件管理策略：\n\n+ 删除文件时，并非真的物理性初始化文件信息，只需修改位示图和文件目录表\n+ 文件所在扇区标记为空闲、文件目录表中被删除文件信息无效化便可视为文件已删除\n\n\n\n## 备注\n\n### Linux命令\n\n#### od命令用于输出文件内容。\n\nod指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来。\n\n| 缩写 | 格式规范 | 说明 |\n| ---- | -------- | ---- |\n|-a|\t-t a\t|输出命名字符。|\n|-b\t|-t o1\t|输出八进制字节。|\n|-c\t|-t c\t|输出可打印的单字节字符，C反斜杠转义或3位八进制序列。|\n|-d|\t-t u2\t|输出无符号十进制数（双字节）。|\n|-f|\t-t fF\t|输出浮点型。|\n|-i|\t-t dI（大写I）|\t输出十进制整数。|\n|-l|\t-t dL\t|输出十进制长整型。|\n|-o|\t-t o2\t|输出八进制字节（双字节）。|\n|-s|\t-t d2\t|输出十进制数（双字节）。|\n|-x|\t-t x2\t|输出十六进制数（双字节）。|\n\n\n\n#### hexdump命令**主要用来查看“二进制”文件的十六进制编码**\n\n- **语法**\n\n  **hexdump [选项] [文件]…**\n\n- **选项**\n\n  - -**n length**：格式化输出文件的前length个字节\n  - -**C**：输出规范的十六进制和ASCII码\n  - **-b**：单字节八进制显示\n  - **-c**：单字节字符显示\n  - **-d**：双字节十进制显示\n  - **-o**：双字节八进制显示\n  - **-x**：双字节十六进制显示\n  - **-s**：从偏移量开始输出\n\n\n\n### 位示图\n\n```\nclass BitMap {\n  private:\n    int numBits;\t\t\t// 扇区数 固定不变 初始化来的\n    int numWords;\t\t\t// 位示图存储的字节数\n\t\t\t\t\t// 不是字的倍数可以舍入\n    unsigned int *map;\t\t\t// bit storage\n};\n```\n\n\n\n标记whitch扇区被使用，左移赋值\n\nBitsInWord=32\n\n```\nvoid\nBitMap::Mark(int which) \n{ \n    ASSERT(which >= 0 && which < numBits);\n    map[which / BitsInWord] |= 1 << (which % BitsInWord);\n}\n```\n\n其他函数的实现规则类似\n\n\n\n### 文件目录\n\n文件目录的定义\n\n```\nclass Directory {\n  private:\n    int tableSize;\t\t\t// 目录项的数量\n    DirectoryEntry *table;\t\t// 目录项数组\n\n    int FindIndex(char *name);\t\t// 根据文件名寻找下标\n};\n```\n\n\n\n\n\n目录项的定义\n\n```\nclass DirectoryEntry {\n  public:\n    bool inUse;\t\t\t\t// 该目录项是否已经分配 1字节  编译器出于对其原则分配4字节\n    int sector;\t\t\t\t// 文件头所在的扇区号 4字节\n\t\t\t\t\t//   文件头未FCB或i-node \n    char name[FileNameMaxLen + 1];\t// 文件名 最长为9个字节\n\t\t\t\t\t// +1 末尾 '\\0'\n};\n```\n\n+ 目录文件\n  + 文件头\n  + 目录表\n\n| 文件名  | inUse | 文件头（索引节点）所在的扇区号 |\n| ------- | ----- | ------------------------------ |\n| main.cc | 1     | 4                              |\n\n\n\n+ 文件\n  + 文件头\n  + 数据块\n\n\n\n```\n// Sectors containing the file headers for the bitmap of free sectors,\n// and the directory of files.  These file headers are placed in well-known \n// sectors, so that they can be located on boot-up.\n#define FreeMapSector \t\t0\n#define DirectorySector \t1\n\n// Initial file sizes for the bitmap and directory; until the file system\n// supports extensible files, the directory size sets the maximum number \n// of files that can be loaded onto the disk.\n#define FreeMapFileSize \t(NumSectors / BitsInByte)\n#define NumDirEntries \t\t10\n#define DirectoryFileSize \t(sizeof(DirectoryEntry) * NumDirEntries)\n```\n\n\n\n\n\n\n\n文件头相当于FCB\n\n### 文件头\n\n```\nclass FileHeader {\n  public:\n    bool Allocate(BitMap *bitMap, int fileSize);// 初始化文件头\n\t\t\t\t\t\t//  包括在硬盘上分配数据块\n    void Deallocate(BitMap *bitMap);  \t\t// 回收数据块\n\n    void FetchFrom(int sectorNumber); \t// 在硬盘上初始化文件头\n    void WriteBack(int sectorNumber); \t// 向硬盘写回文件头的修改内容\n\n    int ByteToSector(int offset);\t// Convert a byte offset into the file\n\t\t\t\t\t// to the disk sector containing\n\t\t\t\t\t// the byte\n\t\t\t\t\t//将文件中的字节偏移量转换为包含该字节的扇区编号\n\n    int FileLength();\t\t\t// 以字节为单位返回文件长度\n\n    void Print();\t\t\t// 输出文件内容\n\n  private:\n    int numBytes;\t\t\t// 文件大小，单位：字节\n    int numSectors;\t\t\t// 文件的逻辑块数\n    int dataSectors[NumDirect];\t\t// 直接块数组，依次存储文件的每个数据块所对应的扇区号\n};\n```\n\n\n\n### 文件大小\n\n```\n#define NumDirect \t((SectorSize - 2 * sizeof(int)) / sizeof(int)) \n#define MaxFileSize \t(NumDirect * SectorSize)\n```\n\n每个文件最多包含30个扇区，最大为3780字节（3KB=30*128B）\n\n\n\n确定方式\n\n目标：使文件头大小刚好为一个数据块大小\n\n文件头包含=numBytes(int) + numSectores(int) + dataSectors[]\n\n使得dataSectors数组大小填满剩下的区域\n\nsize=(128-4*2)/4=30\n\n\n\n### 硬盘空闲块的管理\n\n位示图（BitMap）\n\n位示图也是一个文件，由文件头+数据块组成，文件头保存在第0号扇区中\n\n1024个扇区对应   1024/8=128字节\n\n\n\n目录文件（根目录）的文件头存储在第1号扇区\n\n文件的大小在创建后无法改变\n\n\n\n\n\n# 实验五 扩展Nachos的文件系统\n\n## 目的\n\n理解文件系统中文件操作的实现方法，如文件打开、读、写、扩展、定位、关闭等； \n\n理解如何管理硬盘空闲块； \n\n创建文件时，如何为文件分配目录项及文件头（FCB）；\n\n理解文件扩展时，如何为要扩展的数据查找并分配空闲块； \n\n理解文件扩展后，文件大小是如何记录与保存的； \n\n文件被删除后，如何回收为其分配的资源，如文件头、目录项、硬盘块等； \n\n拓展：有精力的同学可进一步尝试多级目录（目录树）的设计与实现方法。根据上述工作，总结操作系统（如 Nachos）读写文件，以及对文件追加数据的过程与步骤（如操作系统需要操作哪些文件系统的控制信息，如何操作的等）。\n\n\n\n## 任务\n\n让你修改 Nachos 的文件系统，以满足： \n\n1. 文件创建时，其大小可初始化为 0； \n\n2. 当一个文件写入更多的数据时，其大小可随之增大； \n\n3. 要求能够在从一个文件的任何位置开始写入数据，即能够正确处理命令行参数 \n\n   -ap, -hap,及-nap；\n\n\n\n例子\n\n如果一个文件的大小为 100 字节，当从其偏移量 50（第一个字节的偏移量 是 0）开始写入 100 个字节后，该文件的大小应该为 150 字节\n\n![image-20220314194850745](操作系统课设/image-20220314194850745.png)\n\n\n\n## 实验过程\n\n### 分析\n\n确定需要修改的文件和函数\n\n首先阅读源码可知，\n\n+ OpenFile::WriteAt(char *from, int numBytes, int position)函数实现了从任意位置插入内容，但是并不可以扩展文件大小，修改其内部代码，增加扩展文件大小的函数调用\n\n+ Openfile::WriteBack()  实现将新的文件头写回硬盘\n  + FileHeader::void WriteBack(int sectorNumber);FileHeader类本身拥有将自身写回硬盘sectorNumber扇区的函数，但是我们缺少原文件头所在扇区号的参数\n  + Openfile增加私有变量hdrSector用于记录文件头所在扇区，并在初始化时更新\n+ 新函数 Openfile::ExtendSpace(int NumByte) 增加NumByte的空间\n  + 实现方式通过调用FileHeader *hdr;的内部函数实现\n  + FileHeader::ExtendSpace(BitMap *bitMap,int NumByte)  增加NumByte的字节，并修改位示图\n+ OpenFile类的新函数\n  + BitMap* getBitMap();   获取位示图\n  + void setBitMap(BitMap* freeMap);  写回位示图\n\n### 实现\n\n修改OpenFile，增加初始化私有成员hdrSector\n\n```\nOpenFile::OpenFile(int sector)\n{ \n    hdr = new FileHeader;\n    hdr->FetchFrom(sector);\n    seekPosition = 0;\n    hdrSector = sector;\n}\n```\n\n获得扇区号后，增加函数WriteBack，将头文件写回硬盘\n\n```\nint OpenFile::WriteBack(){\n    hdr->WriteBack(hdrSector);\n    return hdrSector;\n}\n```\n\n扩展文件大小\n\n函数实现模仿`bool Allocate(BitMap *bitMap, int fileSize);`\n\n```\nint FileHeader::ExtendSpace(BitMap *bitMap,int NewByteNum){\n    int NewSectorNum; //新扇区数量\n    int OriginalRemainingSpace = SectorSize*numSectors - numBytes; //原剩余空间\n    int ExtendByteNum = NewByteNum - OriginalRemainingSpace; \n    \t\t\t\t\t\t\t\t//扩展空间= 新增字节数 - 原剩余空间\n    NewSectorNum = divRoundUp(ExtendByteNum,SectorSize); //新增扇区数\n\n\t//若新增扇区数小于等于0，简单增加文件长度后直接返回\n    if (NewSectorNum <= 0){ \n        numBytes += NewByteNum;\n        return 0;\n    }\n\n\t// 硬盘剩余扇区数小于新增扇区数，扩展失败，返回-1\n    if(bitMap->NumClear()<NewSectorNum){ \n        return -1;\n    }\n\t\n\t// 超过可分配的最大扇区数量，扩展失败\n\tif((NewSectorNum+numSectors)>30){\n        return -1;\n    }\n\t\n\t//最初匹配，寻找第一个空闲扇区，放入文件头的扇区分配数组\n    for(int i = numSectors;i < numSectors+NewSectorNum ; i++){\n        dataSectors[i] = bitMap->Find();\n    }\n    \n    //更新文件头信息\n    numSectors += NewSectorNum;\n    numBytes += NewByteNum;\n\n    return NewSectorNum;\n}\n```\n\n实现OpenFile::ExtenByte(int)函数，这个函数主要是帮助FileHead::ExtendSpace()函数准备位示图并将更新后的位示图写回DISK\n\n```\nint\nOpenFile::ExtendSpace(int NumByte){\n    \n    BitMap* bitMap = fileSystem->getBitMap();\n\n    int ExtendSectorNum = hdr->ExtendSpace(bitMap,NumByte);\n    \n    fileSystem->setBitMap(bitMap);\n    return ExtendSectorNum;\n}\n```\n\n\n\n更新WriteAt函数\n\n```\nint\nOpenFile::WriteAt(char *from, int numBytes, int position)\n{\n    int fileLength = hdr->FileLength();\n    int i, firstSector, lastSector, numSectors;\n    bool firstAligned, lastAligned;\n    char *buf;\n\n//以下修改的内容\n    if (numBytes <= 0)\n\t    return 0;\t\t\t\t// 判断写入字节数\n    if ((position + numBytes) > fileLength){\n        //判断写入后的位置是否大于文件长度\n        int incrementBytes = (position + numBytes) - fileLength;\n        int Extend = ExtendSpace(incrementBytes);\n        //扩展文件长度\n    }\n//以上为修改内容\n\n    DEBUG('f', \"Writing %d bytes at %d, from file of length %d.\\n\", \t\n\t\t\tnumBytes, position, fileLength);\n\n    firstSector = divRoundDown(position, SectorSize);\n    lastSector = divRoundDown(position + numBytes - 1, SectorSize);\n    numSectors = 1 + lastSector - firstSector;\n\n    buf = new char[numSectors * SectorSize];\n\n    firstAligned = (bool)(position == (firstSector * SectorSize));\n    lastAligned = (bool)((position + numBytes) == ((lastSector + 1) * SectorSize));\n\n// read in first and last sector, if they are to be partially modified\n    if (!firstAligned)\n        ReadAt(buf, SectorSize, firstSector * SectorSize);\t\n    if (!lastAligned && ((firstSector != lastSector) || firstAligned))\n        ReadAt(&buf[(lastSector - firstSector) * SectorSize], \n\t\t\t\tSectorSize, lastSector * SectorSize);\t\n\n// copy in the bytes we want to change \n    bcopy(from, &buf[position - (firstSector * SectorSize)], numBytes);\n\n// write modified sectors back    \n    for (i = firstSector; i <= lastSector; i++)\t\n        synchDisk->WriteSector(hdr->ByteToSector(i * SectorSize), \n\t\t\t\t\t&buf[(i - firstSector) * SectorSize]);\n    delete [] buf;\n\n    //printf(\"NumByte: %d\\n\",numBytes);\n    return numBytes;\n}\n```\n\n\n\n## 实验结果\n\n![image-20220315235407884](操作系统课设/image-20220315235407884.png)\n\n可以看到big的文件内容被添加在了medium后面\n\n\n\n## 扩展\n\n==目前 Nachos 文件系统仅仅实现了单级目录结构，只有一个根目录。可以尝试采用目录树对文件进行管理。==\n\n\n\n\n\n## 备注\n\nfseek()\n函数名: fseek\n功 能: 重定位流上的文件指针\n\n```\n int fseek(FILE *stream, long offset, int fromwhere);\n```\n\n描 述: 函数设置文件指针stream的位置。\n\n+ 如果执行成功，stream将指向以fromwhere为基准，偏移offset个字节的位置。\n\n+ 如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置。\n+ 返回值: 成功，返回0，否则返回其他值。\n\n第一个参数stream为文件指针\n第二个参数offset为偏移量，整数表示正向偏移，负数表示负向偏移\n第三个参数origin设定从文件的哪里开始偏移,可能取值为：SEEK_CUR、 SEEK_END 或 SEEK_SET\nSEEK_SET： 文件开头     0\nSEEK_CUR： 当前位置   1\nSEEK_END： 文件结尾   2\n其中SEEK_SET,SEEK_CUR和SEEK_END和依次为0，1和2.\n\n\n\nftell()\n\n```\nlong ftell(FILE *fp);\n```\n\n函数功能：返回当前文件指针的位置。这个位置是指当前文件指针相对于文件开头的位移量\n\n返回值：返回文件指针的位置，若出错则返回-1L\n\n\n\nfread()\n\n```\nsize_t  fread( void  *buffer, size_t  size, size_t  count, FILE  *stream  ) \n```\n\nbuffer  读取的数据存放的内存的指针，可以是数组，也可以是新开辟的空间，buffer就是一个索引\n\nsize    每次读取的字节数  \n\ncount   读取次数  \n\nstrean  要读取的文件的指针  \n\n返回值为读取元素个数\n\n\n\nbcopy()\n\n```\nextern void bcopy(const void *src, void *dest, int n);\n```\n\n 用法：#include <string.h>\n\n 功能：将字符串src的前n个字节复制到dest中\n\n 说明：bcopy不检查字符串中的空字节NULL，函数没有返回值。\n\n\n\n类作用总结\n\n```\nclass OpenFile {\n  public:\n    OpenFile(int sector);\t\t// 根据扇区号打开文件 文件头\n    ~OpenFile();\t\t\t// 关闭文件\n\n    void Seek(int position); \t\t// 文件内指针重定位\n\n    int Read(char *into, int numBytes); // 隐含位置开始读\n    int Write(char *from, int numBytes);// 隐含位置开始写\n\n    int ReadAt(char *into, int numBytes, int position);\n    \t\t\t\t\t// 传递位置开始读\n    int WriteAt(char *from, int numBytes, int position);\n\n    int Length(); \t\t\t// 返回文件长度\n    \n  private:\n    FileHeader *hdr;\t\t\t// Header for this file \n    int seekPosition;\t\t\t// Current position within the file\n    int hdrSector;              // 文件头所在扇区\n};\n```\n\n\n\n```\nclass FileHeader {\n  public:\n    bool Allocate(BitMap *bitMap, int fileSize);// 初始化文件头，在位示图中分配空间\n    void Deallocate(BitMap *bitMap);  \t\t// 删除文件\n\n    void FetchFrom(int sectorNumber); \t// 根据扇区号初始化文件头\n    void WriteBack(int sectorNumber); \t// 写回修改后的文件头\n\n    int ByteToSector(int offset);\t// 将字节偏移量转化为扇区号\n\n    int FileLength();\t\t\t// 文件的字节长度\n\n    void Print();\t\t\t// 打印文件内容\n\n  private:\n    int numBytes;\t\t\t// 字节数\n    int numSectors;\t\t\t// 扇区数\n    int dataSectors[NumDirect];\t\t// 扇区数组\n};\n```\n\n\n\n```\nclass FileSystem {\n  public:\n    FileSystem(bool format);\t\t// Initialize the file system.\n\t\t\t\t\t// Must be called *after* \"synchDisk\" \n\t\t\t\t\t// has been initialized.\n    \t\t\t\t\t// If \"format\", there is nothing on\n\t\t\t\t\t// the disk, so initialize the directory\n    \t\t\t\t\t// and the bitmap of free blocks.\n\n    bool Create(char *name, int initialSize);  \t\n\t\t\t\t\t// Create a file (UNIX creat)\n\n    OpenFile* Open(char *name); \t// 打开一个文件\n\n    bool Remove(char *name);  \t\t// 删除一个文件\n\n    void List();\t\t\t// 列出文件系统中的所有文件\n    void Print();\t\t\t// 打印出所有文件及其内容\n\n  private:\n   OpenFile* freeMapFile;\t\t// 位示图\n   OpenFile* directoryFile;\t\t// 根部目录文件表\n};\n```\n\n\n\n```\nclass BitMap {\n  public:\n    BitMap(int nitems);\t\t// 初始化位示图，参数：扇区数\n    ~BitMap();\t\t\t// De-allocate bitmap\n    \n    void Mark(int which);   \t// 标记which扇区\n    void Clear(int which);  \t// 清楚whitch扇区\n    bool Test(int which);   \t// witch扇区是否使用\n    int Find();            \t// 寻找并分配第一个空闲扇区 失败返回-1\n    int NumClear();\t\t// 返回未使用扇区数\n\n    void Print();\t\t// 打印位示图信息\n    \n    // These aren't needed until FILESYS, when we will need to read and \n    // write the bitmap to a file\n    void FetchFrom(OpenFile *file); \t// fetch contents from disk \n    void WriteBack(OpenFile *file); \t// write contents to disk\n\n  private:\n    int numBits;\t\t\t// number of bits in the bitmap\n    int numWords;\t\t\t// number of words of bitmap storage\n\t\t\t\t\t// (rounded up if numBits is not a\n\t\t\t\t\t//  multiple of the number of bits in\n\t\t\t\t\t//  a word)\n    unsigned int *map;\t\t\t// bit storage\n};\n```\n\n\n\n\n\n# 实验六 Nachos用户程序与系统调用\n\n## 目的\n\n为后续实验中实现系统调用 Exec()与 Exit()奠定基础 \n\n理解 Nachos 可执行文件的格式与结构； \n\n掌握 Nachos 应用程序的编程语法，了解用户进程是如何通过系统调用与操作系统内核进行交互的； 掌握如何利用交叉编译生成 Nachos 的可执行程序； \n\n理解系统如何为应用程序创建进程，并启动进程； \n\n理解如何将用户线程映射到核心线程，核心线程执行用户程序的原理与方法； \n\n理解当前进程的页表是如何与 CPU 使用的页表进行关联的；\n\n\n\n### 任务\n\n该实验将体验 Nachos 的用户程序、应用进程进程及 Nachos 系统调用的相关概念；\n\n（1）阅读../bin/noff.h，分析 Nachos 可执行程序.noff 文件的格式组成； \n\n（2）阅读../test 目录下的几个 Nachos 应用程序，理解 Nachos 应用程序的编程语法，了解用户进程是如何通过系统调用与操作系统内核进行交互的； \n\n（3）阅读../test/Makefile，掌握如何利用交叉编译生成 Nachos 的可执行程序； \n\n（4）阅读../threads/main.cc，../userprog/ progtest.cc，根据对命令行参数-x 的处理 过程，理解系统如何为应用程序创建进程，并启动进程的； \n\n（5）阅读../userprog/ progtest.cc，../threads/scheduler.cc（Run()），理解如何将用户线程映射到核心线程，以及核心线程执行用户程序的原理与方法；\n\n（6）阅读../userprog/ progtest.cc，../machine/translate.cc，理解当前进程的页表是如何与CPU使用的页表进行关联的；\n\n\n\n## 实验步骤\n\nNachos 实现的文件系统实现了两个版本，\n\n+  FILESYS_STUB：直接利用 UNIX 所提供的系统调用实现，操作的不是硬盘 DISK 上的文件\n+ FILESYS：FILESYS 实现的文件系统是通过 OpenFile 类对 DISK 上的文件进行操作（尽管最终也是使用 UNIX 的系统调用实现）\n\n考察../userprog/makefile 与 makefile.local 的内容可以看出，实验 6、7、8 默认使用的是 FILESYS_STUB 定义的相关实现，即不是对 DISK 上的文件进行操作，而是直接对 UNIX 文件进行操作；\n\n\n\n### .noff文件格式\n\n```\n#define NOFFMAGIC\t0xbadfad \t/* 表示Nachos的魔数\n\t\t\t\t\t * object code file \n\t\t\t\t\t */\n\ntypedef struct segment {\n  int virtualAddr;\t\t/* 虚拟空间的段地址 */\n  int inFileAddr;\t\t/* 本文件的段地址 */\n  int size;\t\t\t/* 段长度 */\n} Segment;\n\ntypedef struct noffHeader {\n   int noffMagic;\t\t/* 应为NOFFMAGIC */\n   Segment code;\t\t/* 可执行段代码 */ \n   Segment initData;\t\t/* 初始化过的数据段 */\n   Segment uninitData;\t\t/* 未初始化过的数据段 --\n\t\t\t\t * should be zero'ed before use \n\t\t\t\t */\n} NoffHeader;\n```\n\n分析：Nachos 的应用程序是作者自己定义的一种文件类型，文件头部分结构相对简单，编程方便。\n\nNachos文件主要由3部分构成\n\n+ 可执行代码段\n+ 初始化过的数据段：一般为初始化的全局变量等\n+ 未初始化的数据段：一般指程序运行时才会分配的动态内存、静态变量、未初始化的全局变量\n\n\n\n每个段有自己的信息\n\n+ 文件中的位置\n+ 大小\n+ 程序入口地址\n\n\n\n### 将noff文件装入内存\n\n系统要运行一个应用程序，需要\n\n+ 为该程序创建一个用户进程\n+ 为程序分配内存空间，将用户程序（代码段与数据段，数据段包括初始化的全局变量与未初始化的全局变量，以及静态变量）装入所分配的内存空间\n+ 创建相应的页表，建立虚页与实页（帧）的映射关系；（参见 AddressSpace:: AddressSpace()）；\n\n\n\n通过noff.h的各种信息，我们可以得知读取noff文件的规则，并定义好相关的数据结构\n\nAddress::Address()初始化将noff文件读入内存\n\n```\nAddrSpace::AddrSpace(OpenFile *executable)\n{\n    NoffHeader noffH;\n    unsigned int i, size;\n\n// 检查魔数是否正确\n    executable->ReadAt((char *)&noffH, sizeof(noffH), 0);\n    if ((noffH.noffMagic != NOFFMAGIC) && \n\t\t(WordToHost(noffH.noffMagic) == NOFFMAGIC))\n    \tSwapHeader(&noffH);\n    ASSERT(noffH.noffMagic == NOFFMAGIC);\n\n// 计算地址空间大小\n    size = noffH.code.size + noffH.initData.size + noffH.uninitData.size \n\t\t\t+ UserStackSize;\t// we need to increase the size   增加栈空间\n\t\t\t\t\t\t// to leave room for the stack\n    numPages = divRoundUp(size, PageSize);\n    size = numPages * PageSize;\n\n    ASSERT(numPages <= NumPhysPages);\t\t// 检查所需页数不会超过实际内存页数 64页\n\n    DEBUG('a', \"Initializing address space, num pages %d, size %d\\n\", \n\t\t\t\t\tnumPages, size);\n\n// 设置页表\n    pageTable = new TranslationEntry[numPages];\n    for (i = 0; i < numPages; i++) {\n\t    pageTable[i].virtualPage = i;\t// 现在虚拟页号等于物理页号\n\t    pageTable[i].physicalPage = i;\n\t    pageTable[i].valid = TRUE;\n\t    pageTable[i].use = FALSE;\n\t    pageTable[i].dirty = FALSE;\n\t    pageTable[i].readOnly = FALSE;  // 若代码段在独立的页中，设置为只读\n    }\n    \n// 将整个地址空间置零, 未初始化数据段和栈段\n    bzero(machine->mainMemory, size);\n\n// 将代码和数据段复制进入内存\n    if (noffH.code.size > 0) {\n        DEBUG('a', \"Initializing code segment, at 0x%x, size %d\\n\", \n\t\t\tnoffH.code.virtualAddr, noffH.code.size);\n        executable->ReadAt(&(machine->mainMemory[noffH.code.virtualAddr]),\n\t\t\tnoffH.code.size, noffH.code.inFileAddr);\n    }\n    if (noffH.initData.size > 0) {\n        DEBUG('a', \"Initializing data segment, at 0x%x, size %d\\n\", \n\t\t\tnoffH.initData.virtualAddr, noffH.initData.size);\n        executable->ReadAt(&(machine->mainMemory[noffH.initData.virtualAddr]),\n\t\t\tnoffH.initData.size, noffH.initData.inFileAddr);\n    }\n\n}\n```\n\n程序的执行流程为\n\n+ 读入NoffHeader结构，获取文件的基本信息\n\n+ 检查noffMagic\n\n+ 计算所需空间大小\n\n  + size = noffH.code.size + noffH.initData.size + noffH.uninitData.size + UserStackSize\n\n  + 代码段+初始化数据段+未初始化数据段+用户栈空间\n\n+ 设置页表\n\n  + 用于实现虚拟地址到物理地址的转换\n\n+ 将整个地址空间置零, 包括未初始化数据段和栈段\n\n+ 将代码和数据段复制进入内存\n\n\n\n页表结构\n\n```\nclass TranslationEntry {\n  public:\n    int virtualPage;  \t// 虚拟页号\n    int physicalPage;  \t// 物理页号\n    bool valid;         // 有效位\n\t\t\t// 表示本页表项是否被初始化过\n    bool readOnly;\t// 是否只读\n    bool use;           // 页被硬件引用或修改\n    bool dirty;         // 脏位\n};\n```\n\n主要为页表项结构，记录本页的相关信息\n\n\n\n### Nachos应用程序的启动过程\n\n用户进程需要映射到核心进程才能得到执行：本质上是替换掉地址空间\n\n```\nvoid\nStartProcess(char *filename)\n{\n    OpenFile *executable = fileSystem->Open(filename);\n    AddrSpace *space;\n\n    if (executable == NULL) {\n\t    printf(\"Unable to open file %s\\n\", filename);\n\t    return;\n    }\n\n    // 将用户进程映射到核心进程\n    space = new AddrSpace(executable);    \n    currentThread->space = space;\n\n    delete executable;\t\t\t// close file\n\n    space->InitRegisters();\t\t// 设置初始寄存器值\n    space->RestoreState();\t\t// 加载页表寄存器\n\n    machine->Run();\t\t\t// 运行用户程序\n    ASSERT(FALSE);\t\t\t// machine->Run 从不返回，若返回则必定错误\n\t\t\t\t\t// the address space exits\n\t\t\t\t\t// by doing the syscall \"exit\"\n}\n```\n\n为使该核心线程能够执行用户进程的代码，需要核心在调度执行该线程时，根据用户进程的页表读取用户进程指令；\n\n因此需要将用户页表首地址传递给核心的地址变换机构；（machine.h 中维护一个 pageTable 指针，指向当前正在 运行的 Nachos 应用 进程的页表）\n\n如此一来，我们完成了\n\n+ 文件的读取\n+ 内存的加载\n+ 用户进程映射到核心进程\n\n\n\n### 上下文切换的完成\n\n为便于上下文切换时保存与恢复寄存器状态，Nachos 设置了两组寄存器，\n\n+  CPU 使用的寄存器 int registers[NumTotalRegs]（参见 Machine 类 in Machine.h），用于保存执行完一条机器指令时该指令的执行状态；\n+ 运行用户程序时使用的用户寄存器 int userRegisters[NumTotalRegs]，用户保存执行完一条用户程序指令后的寄存器状态（参见 Thread.h）；\n\n\n\n当用户进程进行上下文切换时（实质上是执行用户进程的核心线程发生上下文切换）\n\n将老进程的 CPU 的寄存器状态保存到用户寄存器 userRegisters[]中\n\n将新用户进程的寄存器状态恢复到 CPU 的寄存器中，以便 CPU 能够继续执行上次被中断的用户程序；参见 Scheduler::Run()中核心进程切换时对 CPU 寄存器与用户寄存器的保存与恢复；\n\n```\nvoid\nScheduler::Run (Thread *nextThread)\n{\n    Thread *oldThread = currentThread;\n    \n#ifdef USER_PROGRAM\t\t\t//单独对用户进程进行的额外处理\n    if (currentThread->space != NULL) {\t// 如果进程为用户进程,\n        currentThread->SaveUserState(); // 保存用户的CPU寄存器到用户寄存器\n    }\n#endif\n```\n\n若是用户进程\n\n\n\n\n\n### 运行指令\n\nmachine::Run() （ ./machine/mipssim.cc 中 实 现 ）\n\n 循环调用 Machine::OneInstruction(Instruction *instr) 执行程序指令，直到程序退出或遇到一个异常；\n\n```\nvoid\nMachine::Run()\n{\n    Instruction *instr = new Instruction;  // 存储指令\n\n    if(DebugIsEnabled('m'))\n        printf(\"Starting thread \\\"%s\\\" at time %d\\n\",\n\t       currentThread->getName(), stats->totalTicks);\n    \tinterrupt->setStatus(UserMode);\n    for (;;) {\n        OneInstruction(instr); //运行一条指令\n\t\tinterrupt->OneTick(); // 中断完成一次跳动\n\t\tif (singleStep && (runUntilTime <= stats->totalTicks))\n\t  \t\tDebugger();\n    }\n}\n```\n\n其中指令的格式为\n\n```\nclass Instruction {\n  public:\n    void Decode();\t// 解码指令的二进制表示\n\n    unsigned int value; // 指令的二进制表示\n\n    char opCode;     // 指令类型  This is NOT the same as the 与opcode不同\n    \t\t     // opcode field from the instruction: see defs in mips.h\n    char rs, rt, rd; // 指令的三个寄存器\n    int extra;       // Immediate or target or shamt field or offset.\n                     // Immediates are sign-extended.\n};\n```\n\n\n\n\n\n\n\n### 机器硬件设置\n\n```\n#define PageSize \tSectorSize \t// y\n\n#define NumPhysPages    64 //32\n#define MemorySize \t(NumPhysPages * PageSize)\n#define TLBSize\t\t4\t\t// if there is a TLB, make it small\n```\n\n\n\n\n\n\n\n## 备注\n\nvoid bzero（void *s, int n）；\n\n头文件：#include <string.h>\n\n功能：将字符串s的前n个字节置为0，一般来说n通常取sizeof(s),将整块空间清零。\n\n返回值：无返回值\n\n\n\n\n\n# 实验7 地址空间的扩展\n\n\n\n## 目的\n\n通过考察系统加载应用程序过程，如何为其分配内存空间、创建页表并建立虚页与实页帧的映射关系，理解 Nachos 的内存管理方法； \n\n理解如何系统对空闲帧的管理； \n\n理解如何加载另一个应用程序并为其分配地址空间，以支持多进程机制； \n\n理解进程的 pid； \n\n理解进程退出所要完成的工作；\n\n\n\n## 任务\n\n该实验与下一个实验（实验 8）可在目录../lab7-8 中完成，参照实验 2 介绍的方法将该实验中需要修改的模块、头文件，以及依赖这些头文件的模块复制到该目录中。 如将需要的模块从../userprog 目录复制到该目录中，还要复制 arch 目录及其子目录、Makefile、Makefile.local 等文件，并对 Makefile 及 Makefile.local 做相应 的修改。 该实验中，你需要完成： \n\n（1）阅读../prog/protest.cc，深入理解 Nachos 创建应用程序进程的详细过程 \n\n（2）阅读理解类 AddrSpace，然后对其进行修改，使 Nachos 能够支持多进 程机制，允许 Nachos 同时运行多个用户线程； \n\n（3）在类 AddrSpace 中添加完善 Print()函数（在实验 6 中已经给出） \n\n（4）在类 AddrSpace 中实例化类 Bitmap 的一个全局对象，用于管理空闲帧； \n\n（5）如果将 SpaceId 直接作为进程号 Pid 是否合适？如果感觉不是很合适， 应该如何为进程分配相应的 pid？ \n\n（6）为实现 Join(pid)，考虑如何在该进程相关联的核心线程中保存进程号； \n\n（7）根据进程创建时系统为其所做的工作，考虑进程退出时应该做哪些工 作； \n\n（8）考虑系统调用 Exec()与 Exit()的设计实现方案； \n\n（9）拓 展 ： 可 以 进 一 步 考 虑 如 何 添 加 自 己 所 需 要 的 系 统 调 用 ，即../userprog/syscall.h 中没有定义的系统调用，如 Time，以获取当前的系统时间。\n\n"},{"title":"博客的搭建","url":"/2022/03/10/博客的搭建/","content":"\n\n\n# 云计算技术实验报告\n\n\n\n### 实验目的\n\n熟悉个人博客系统的搭建。\n\n具体包括：注册Github账号，搭建Hexo环境并实现个人博客搭建，撰写实验报告。\n\n<!-- more -->\n\n### 个人信息\n\n学号：201900130068\n\n姓名：曹玉雯\n\n班级：19.2\n\n实验题目：Github + Hexo搭建个人博客系统\n\n实验日期：22.03.09\n\n\n\n### 硬件环境\n\n联网计算机一台\n\n### 软件环境\n\nWindows 10\n\n\n\n### 实验步骤与内容\n\n1. 安装GitHub\n\n   之前已经安装过git\n\n2. 安装node.js\n\n   进入官网下载后，无脑next\n\n3. 下载hexo框架\n\n   npm install -g hexo-cli\n\n4. 建立Hexo博客框架\n\n   新建文件夹 blog\n\n   初始化框架 \n\n   ```\n   hexo init\n   ```\n\n   启动博客\n\n   ```\n   hexo server\n   ```\n\n     小插曲：默认的4000端口无法访问 \n\n   ```\n   hexo s -p 5000 切换到5000端口\n   ```\n\n\n\n#### 部署至GitHub仓库\n\n1. 创建名为yourname.github.io的仓库\n\n   安装hexo插件 \n\n```\nnpm install --save hexo-deployer-git\n```\n\n2. 修改站点配置文件\n\n```\n$ vim _config.yml  //我是使用的vim编辑器打开,你也可以使用记事本\n\n//定位到文件末尾找到下面这个地方：deploy，\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: \n  repo: \n```\n\n修改为\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: https://github.com/ yourname/yourname.github.io.git\n  branch: master\n\n```\n\n3. 部署到github上\n\n```\nhexo d\n```\n\nps：错误最常见于这一步，很多人出现了无法访问github的问题\n\n​\t\t根本原因是因为之前没有使用过github，未配置ssh密匙，配置一下就好了\n\n​\t\tgithub连接也不是很稳定\n\n4. 访问\n\n[Const_Point (pipixia23333.github.io)](https://pipixia23333.github.io)\n\n完成目标\n\n![image-20220310001047156](/云计算实验三/image-20220310001047156.png)\n\n#### 对已搭建好的博客进行主题优化\n\n使用GitHub上标星最多的NexT主题\n\n设置头像和分组标签等内容进行美化\n\n\n\n### 体会\n\nhexo确实很方便的实现了博客的搭建，可以说几乎零代码知识。\n\n但是想要扩展更多内容，实现自定义，还是要阅读源码。\n\n\n\n### 参考来源\n\n[ hexo之环境搭建篇_每天进步一点点-CSDN博客_hexo环境](https://blog.csdn.net/weixin_42119041/article/details/104101170)\n\n[文档 | Hexo](https://hexo.io/zh-cn/docs/)\n\n[开始使用 - NexT 使用文档 (iissnan.com)](http://theme-next.iissnan.com/getting-started.html)\n","categories":["云计算"]},{"title":"hellow cloudCalculation","url":"/2022/03/07/hellow-cloudCalculation/","content":"\n操作系统复习\n\n\n\n# OS的发展简史\n\n## 早期的OS-简单的监控程序+人工操作\n\n缺点\n\n+ 用户独占全机，资源浪费\n+ CPU等待人工操作\n+ CPU既负责计算，又负责传输（单控制方式\n\n矛盾\n\n+ 人机矛盾：人工操作方式与机器利用率的矛盾\n+ CPU与I/O设备间速度不匹配的矛盾\n\n解决方法：\n\n+ 通道技术\n+ 脱机输入输出方式\n\n<!-- more -->\n\n## 批处理系统\n\n工作方式：\n\n+ 系统操作员奖用户作业组成一批作业输入计算机，\n+ 系统形成一个自动转接的作业流\n+ 系统自动、依次执行每个作业\n+ 操作员交付作业结果给用户\n\n单道批处理系统\n\n多道批处理系统\n\n\n\n+ 单道程序系统\n  + 系统只能同时运行一个作业\n  + 单个用户独享内存空间\n+ 多道程序系统\n  + 系统同时运行多个作业\t\n  + 运行作业等待时切换至内存另一个作业\n  + 多用户共享内存空间\n\n需要解决的问题\n\n+ 同步互斥、内存保护、文件管理、设备管理\n\n管理程序的功能\n\n+ 存储器、处理机、设备、文件管理\n\n新的概念\n\n+ 存储器管理、CPU调度\n\n多道程序系统特点\n\n+ 优点：作业自动调度执行、缩短了作业之间的间隔时间、资源利用率高、系统吞吐量大\n+ 缺点：作业平均周转时间长、对小型作业不利 ==无交互能力==\n\n\n\n### 单道批处理系统小结\n\n工作流程\n\n+ 作业合成一批输入到外存上，同时在系统中配上监控程序\n+ 监控程序将作业逐个送入内存并运行\n\n特征\n\n+ 自动性\n+ 顺序性\n+ 单道性\n\n优点\n\n+ 减少了人工操作的时间、提高机器的利用率和系统吞吐量\n\n缺点：\n\n+ 对某些作业来说，当它发出I/O请求之后，CPU必须等待I/O的完成，因为I/O设备的低俗性，从而使得机器的利用率很低\n\n### 多道批处理系统\n\n特征：\n\n+ 调度性\n+ 无序性\n+ 多道性\n\n优点\n\n+ 资源的利用率高\n+ 系统吞吐量大\n+ 作业流程自动化\n\n缺点：\n\n+ 平均周转周期长 ==平均周转周期长是什么意思==\n+ 无交互能力  \n+ 调试程序困难\n\n需解决的问题\n\n+ 处理器管理、内存管理、I/O设备管理、文件及作业管理问题\n\n操作系统的形成\n\n+ 为解决上述问题、在多道程序系统中增设一组软件加以解决，同时增设方便用户使用的计算机的软件，形成了操作系统\n\n\n\n操作系统：是一组控制和管理计算机硬件和软件资源，合理的组织计算工作流程，以方便用户使用的程序集合\n\n\n\n## 分时系统\n\n时间片：\n\n+ 操作系统将CPU的时间划分为若干个片段，称为时间片\n+ 操作系统以时间片为单位，轮流为每个终端用户服务\n+ 每次为一个终端服务一个时间片\n  + 利用人的错觉，使人感觉不到系统是在分时为自己提供服务\n\n工作特点\n\n+ CPU通过在作业之间的切换来执行多个位于内存中或物理存储器上的作业\n  + CPU只能分配给那些在内存中的作业\n\n+ 作业在内存和物理存储器之间来回切换\n+ 允许用户与系统之间的联机通信（交互）\n  + 当OS执行完一条命令之后，他将接受用户通过键盘输入的下一条控制指令\n\n+ 联机系统必须提供给用户访问数据和代码\n\n+ 多道性、同时性、独立性、及时性、交互性\n\n响应时间：终端用户发出命令到处理机运行完毕返回结果给终端的时间\n\n虚拟内存：允许作业的执行不完全在物理内存中，而是暂时放在磁盘上，根据需要调入调出，所以允许运行比物理内存大的程序\n\nMULTICS：公用计算服务系统\n\n### UNIX：现代操作系统的代表\n\n促使其成功的因素：\n\n+ C语言编写，可移植\n+ 系统源代码非常有效，系统用以适应特殊需求\n+ 是一个良好的、通用的、多用户、多任务、分时操作系统\n\n## 桌面系统\n\nCP/M操作系统\n\n针对个人计算机操作系统的需求，设计了CP/M操作系统\n\n+ Control Program/Microprocessor or Microcomputer\n\n其具有良好的层次结构\n\n+ 利用BIOS把操作系统的其他模块与硬件配置分隔开，所以他的可移植性好，具有较好的可适应性和易学易用性\n  + BIOS: Basic Input Output System\n\n## 并行系统\n\n这类操作系统有多个紧密通信的处理器，也称为多处理器系统或紧耦合系统\n\n紧耦合系统：处理器共享计算机总线、内存、时钟；通信常通过共享内存的方式来实现\n\n主要优点：\n\n+ 增加吞吐量\n+ 经济节约\n+ 增加可靠性\n  + 功能退化\n  + 容错系统\n\n\n\n非对称处理\n\n+ 每个处理器被赋予一个特定的任务，主处理器为从处理器调度和安排工作\n+ 类似于超大型系统\n\n对称处理\n\n+ 每个处理器都运行同一个操作系统的拷贝，这些拷贝需要互相通信\n+ 许多处理器可能同时运行而性能上不会有多大损失\n\n\n\n若干个位于不同位置的处理器之间组成分布式计算\n\n紧耦合系统：每个处理器都有自己的内存；处理器互相之间通过不同的通信线路进行通信，如高速总线或电话线\n\n## 集群系统\n\n服务器可按照体系架构分为\n\n+ RISC（精简指令集计算）架构服务器\n+ CISC（复杂指令集计算）的IA架构服务器\n\nCluster集群技术定义如下：一组想互独立的服务器在网络中表现为单一的系统，并以单一系统的模式加以管理，此单一系统为客户工作站提供高可靠的服务\n\nIA：通常将采用英特尔处理器的服务器称为IA（Intel Architecture）架构服务器\n\n\n\n集群就是一组计算机，他们作为一个整体向用户提供一组网络资源\n\n\n\n## 实时系统\n\n对处理器操作或对数据流动有严格时间要求\n\n+ 软实时系统\n  + 关键实时任务优先级高于其他任务优先级\n+ 硬实时系统\n  + 对系统内所有延迟都有限制\n\n\n\n# 操作系统介绍\n\n\n\n计算机系统的四个组成部分\n\n+ 计算机硬件\n+ 操作系统\n+ 系统程序\n+ 用户程序、用户\n\n什么是 操作系统\n\n+ 用户视角\n  + 执行用户程序，使解决用户问题更容易。\n  + 便于使用计算机系统\n\n+ 系统视角\n  + 以一种高效的方式利用硬件资源\n  + 操作系统看作资源分配器\n  + 操作系统管理这些资源\n  + 解决冲突请求，以有效和公平的使用资源\n\n\n\n操作系统是：\n\n为应用程序提供基础的程序\n\n管理计算机硬件的程序。\n\n充当计算机和计算机硬件的用户之间的中介的程序。\n\n\n\n## 计算机系统操作\n\n现代计算机系统由一个或多个CPU和若干个设备控制器通过共同的总线相连而成，提供对共享内存的访问\n\n打开电源或重启——运行初始化程序（引导程序）——定位操作系统并将其装入内存——执行第一个进程\n\n### 启动\n\n==引导程序==：通常位于ROM或EEPROM，成为计算机硬件中的固件。用来初始化系统的所有部分（CPU寄存器，设备控制器和内存\n\n计算机的启动过程一般是指计算机从加电到加载操作系统的过程\n\n* 加电\n* 自检\n  * 进行POST（Power-On Self Test，加电后自检\n* 初始化设备\n  * 系统BIOS 查找显卡的BIOS\n* 测试设备\n  * 标准设备检测完毕后，开始检测和配置系统中安装的即插即用设备\n* 更新ESCD（扩展系统配置数据\n  * nESCD 是系统BIOS 用来与操作系统交换硬件配置信息的一种手段\n* 启动操作系统\n  * 将启动盘的主引导扇区读入到内存\n\n###  中断\n\n中断：硬件可随时通过系统总线向CPU发出信号，触发中断。软件通过系统调用（或者其他别的特别操作）触发中断\n\n软件 trap：是由错误或用户请求引起的软件生成的中断（例如，系统调用）。\n\n发生中断：调用一个通用子程序检查中断信息——使用中断处理指针表（中断向量）——间接调用中断处理子程序\n\n现代操作都是以中断为驱动的\n\n+ 若无事，操作系统等待事件发生\n+ 事件的发生通常由硬件或软件的中断发出信号\n\n\n\n中断处理会保存但子程序调用不用保存的内容：程序状态字寄存器\n\n内部异常处理后不会返回到发生异常的指令继续执行\n\n### 存储结构\n\n内存是处理器可以直接访问的唯一的大容量存储区域\n\n辅存：一般是磁盘，主存储器的扩展，提供大的非易失性存储容量\n\n* 磁盘表面划分为轨道，轨道又细分为扇区\n* 磁盘控制器决定设备和计算机之间的逻辑交互\n\n\n\n## I/O结构\n\nI/O设备有缓冲区\n\nDMA（直接内存访问\n\n用于高速IO设备，能以接近内存速度传送信息\n\n设备控制器无需CPU干预直接将数据块从缓冲存储器传输到主存\n\n每个块只产生一个中断，而不是每个字节一个中断\n\n\n\n## 计算机体系结构\n\n+ 单处理器系统\n  + 只有一个通用CPU能够执行通用指令集，包括来自用户进程的指令\n  + 所有其它系统也有其他专用处理器\n\n+ 多处理器系统\n\n  + 有多个紧密通信的CPU，共享计算机总线，有时还包括时钟、内存和外设等\n  + 也被称为紧耦合系统\n  + 优点\n    + 增加吞吐量、规模经济、增加可靠性\n\n  + 非对称多处理：每个处理器都有各自特定的任务，主处理器分配任务给从处理器，IO只有主处理器完成\n  + 对称多处理：所有处理器一视同仁，可以在任何CPU上处理IO\n\n+ 集群系统\n  + 将多台计算机组合成一个系统\n  + 有两个或多个耦合在一起的单独系统组成\n  + 集群计算机共享存储，并通过局域网连接或更快的内部连接\n\n\n\n## 操作系统结构\n\n操作系统拥有多道程序处理能力，多道程序设计通过组织作业（编码或数据）使CPU总有一个作业在执行，从而提高了CPU利用率\n\n系统中的总作业子集被保存在内存中，选择一个工作并通过作业调度运行\n\n三种基本类型\n\n+ 批处理系统\n+ 分时系统，分时系统-交互式计算\n+ 实时系统，硬实时系统、软实时系统\n\n\n\n## 操作系统的操作\n\n操作系统必须保证错误的或者恶意的用户程序不能导致操作系统和其他程序的错误执行\n\n问题\n\n+ 无限循环、占用资源的进程（CPU保护\n+ 进程互相修改或修改操作系统（内存保护\n+ 直接发出IO指令或执行非法IO指令的用户（IO保护\n\n\n\n两种独立的操作模式，为区分操作系统代码和用户定义代码的执行\n\n+ 用户模式\n+ 监督程序模式（内核模式、管理模式、特权模式、系统模式）\n\n\n\n将能引起损害的机器指令作为**特权指令**。用户模式下想要执行特权指令，硬件不会执行，会认为是非法指令，并以陷阱的形式通知给操作系统。\n\n特权指令只能在操作系统代码中执行，而不是在用户程序中执行\n\n系统引导时，硬件开始处于**内核模式**。接着装入操作系统，开始进入用户模式。出现陷阱或中断，会进入内核模式\n\nPSW：内核（0）用户（1）提供系统运行用户代码或内核代码时区分的能力\n\n### 系统调用\n\n操作系统提供了一系列预定功能，通过一组称为**系统调用**的接口呈现给编程人员，系统调用把应用的请求传递给内核，系统调用相应的内核函数完成所需处理，并将结果返回给应用程序\n\n对操作系统的保护：硬件检测，软件处理\n\n系统调用服务程序是操作系统的一部分，执行系统调用时，它被硬件视为一个软件中断\n\n\n\n+ 为操作系统的中断向量和中断服务程序提供内存保护，涉及到存储器管理的寄存器不允许用户设置，特权指令\n+ 几乎所有的IO指令都是特权指令\n+ Load-Timer是一个特权指令，保护以防止无限循环\n\n操作系统的功能\n\n+ 进程管理、内存管理、存储管理、IO子系统\n\n\n\n## 操作系统结构\n\n两个服务器的两个接口\n\n+ 命令界面\n  + 命令行CLI\n  + 图形用户界面\n  + Batch\n\n+ 编程界面\n  + 系统调用\n  + API\n\n![image-20211204152441903](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211204152441903.png)\n\n操作系统服务为用户提供有用功能\n\n+ 用户界面\n+ 程序执行\n+ IO操作\n+ 文件系统操作\n+ 通信\n+ 错误检测\n\n另一组操作系统功能通过资源共享来确保系统本身的高效运行\n\n+ 资源分配\n+ 统计account：跟踪那些用户使用多少和使用何种计算机资源\n+ 保护和安全\n\n\n\n用户界面\n\n+ 命令行CLI\n  + CLI允许直接命名条目\n  + 命令解释器（Unix中被称为shell\n\n+ 用户图形界面GUI\n\n+ Batch\n  + 批处理文件（batch file）是包含一系列命令的文本文件，有命令解释器解释执行\n  + 扩展名一般是 .bat\n\n\n\n## 系统调用\n\n系统调用时用户程序和操作系统内核之间的接口\n\n该接口以系统编程语言（如C或汇编语言）中的普通函数的形式存在\n\n系统调用的目的\n\n+ 从操作系统内核获得服务，这些服务在没有底层操作系统操作时无法完成\n+ 这些任务由运行在系统模式下的内核来完成。\n+ 这样，对关键共享硬件(如内存、磁盘和中断)的访问就可以免受错误用户的影响，因为用户程序只能在用户模式下运行。\n\nAPI是什么\n\n+ 对操作系统提供的服务的编程接口，通常以高级语言编写\n+ 程序主要通过高级应用编程接口（API）而不是系统调用\n+ 好处\n  + 编程更方便\n  + 系统调用更难使用\n  + 对于某些基于OS的设备效率更高\n\n\n\n## 系统调用的实现\n\n通常，每个系统调用与某个数字相关联\n\n+ 系统调用接口根据这些数字维护一个索引表\n+ 类似于中断向量\n\n系统调用接口调用操作系统内核中预期的系统调用，并返回系统调用的状态和返回值\n\n\n\n执行系统调用的过程\n\n传递系统调用参数->执行陷入（trap）指令->执行相应的服务程序->返回用户态\n\n\n\n## 系统调用的类型\n\nProcess control 进程控制\n\nFile management 文件管理\n\nDevice management 设备管理\n\nInformation maintenance 信息维护\n\nCommunications 通信\n\n\n\n## 操作系统结构\n\n简单结构、分层方法、微内核、模块、虚拟机\n\n\n\n### 简单结构\n\nMS-DOS、原始的Unix操作系统\n\n用最少的空间提供最多的功能\n\n未划分模块\n\n\n\n### 分层方法\n\n操作系统分成若干层，最底层（层0）为硬件，最高层（层N）为用户接口。每层只考虑较低层的功能和服务\n\n优点\n\n+ 每层都是利用较低层所提供的功能实现的，并为较高层隐藏了一定的数据结构、操作和硬件的存在\n\n缺点\n\n+ 主要困难为对层的详细定义\n+ 与其他方法相比效率较差\n\n\n\nUnix\n\n主要分为两层：系统程序、内核\n\n\n\n### 微内核\n\n微内核方法将所有非基本部分从内核中移走，并将它们实现为系统或用户程序，这样得到了更小的内核。\n\n主要功能：使客户程序和运行在用户空间的各种服务之间进行通信\n\n![image-20211204162248069](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211204162248069.png)\n\n优点：\n\n+ 便于扩充操作系统\n+ 很容易从一种硬件平台一直到另一种硬件平台设计\n+ 安全可靠\n\n缺点：由于系统功能总开销的增加导致系统性能下降（用户空间到内核空间通信的性能开销\n\n\n\n### 模块\n\n大多数现代操作系统实现内核模块\n\n+ 采用面向对象的办法\n+ 每个核心组件是分开的\n+ 每部分与已知接口的其他部分通信\n+ 每部分根据需要加载到内核\n\n类似于层，但更加灵活\n\n![image-20211204162902774](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211204162902774.png)\n\n\n\n### 虚拟机\n\n指可以像真实机器一样运行程序的计算机的软件实现，是通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统\n\n+ 基于宿主操作系统上实现（Host Operating System ）\n\n+ 提供一个虚拟层，将一套真实的硬件系统虚拟成多套硬件系统\n\n+ 在每套虚拟硬件上可以安装不同的操作系统\n\n\n\n# 进程\n\n概念：进程是执行中的程序。包含了程序代码和当前活动（通过程序计数器和处理器寄存器内容表示）两个部分，当可执行文件加载到内存时，程序变为进程\n\n进程是程序在一个数据集合上的运行活动，是系统进行资源分配和调度的一个独立单位；（汤子赢版）\n\n具体有：\n\n+ 文本段（代码段\n+ 数据段（全局变量、静态变量\n+ 栈（stack）包含临时数据\n  + 函数参数、返回地址、局部变量，随函数调用和返回而增长或缩小\n+ 堆（heap）进程运行期间动态分配的内存\n  + malloc或new\n+ 当前活动：程序计数器、堆栈指针、处理器寄存器\n+ PCB：进程控制块\n\n程序是被动实体、进程是活动实体\n\n\n\n一个程序不能两次属于同一个进程\n\n+ 一个程序可被执行多次\n+ 每次运行都是一个可执行程序不同的运行活动——OS为其创建的进程也不同\n+ 即使每次运行的代码段相同，但处理的数据可能不同\n+ 代码段相同、数据段相同，但PCB、进程号、堆、栈等系统分配资源肯定不同\n\n一个程序可对应多个进程，一个进程也可以有多个程序段共同完成一项任务\n\n## 进程的五个基本特征\n\n+ 动态性\n  + 动态性是进程最基本的特征，表现为：进程由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡\n  + 进程具有一定的生命期\n+ 独立性\n  + 进程实体是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调度的基本单位\n  + 在不支持多线程的系统中，进程是CPU独立调度的基本单位\n    + 进程拥有资源，因此在上下文切换时耗时大、运行效率低\n    + 支持线程的系统中，进程是独立获得资源的基本单位，线程是独立调度的基本单位\n+ 并发性\n  + 多个进程能在一段时间内同时执行\n+ 异步性\n  + 进程按各自独立的、不可预知的速度向前推进，进程按照异步方式运行\n  + OS中必须采取措施包整个程序之间能协调运行\n+ 结构特征\n  + 从结构上看，进程实体由程序段、数据段、堆、栈、PCB等组成\n\n## 进程状态\n\n进程有五种状态\n\n+ new：进程正在创建中\n+ running：正在执行指令\n+ waiting：进程等待某些事件发生（如IO完成或接收信号\n+ ready：等待分配给处理器\n+ terminated：进程已完成执行\n\n![image-20211204170256611](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211204170256611.png)\n\n\n\n+ new：进程运行所需信息不完整，尚无法执行\n\n用户登陆系统：创建新进程\n\n\n\n## PCB\n\n系统为了管理进程设置的一个专门的数据结构，用来记录进程的外部特征，描述进程的运动变化过程\n\n系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志\n\n进程和PCB是一一对应的\n\nPCB内保存的信息\n\n+ 进程状态\n+ 程序计数器：进程要执行的下个指令的地址\n+ CPU寄存器：与程序计数器一起，在出现中断时状态信息需要保存\n+ CPU调度信息：优先级、调度队列指针\n+ 存储管理信息\n+ 记账信息：使用 CPU，启动后时钟消耗时间，时间限制\n+ IO状态信息\n+ 下一个PCB的指针\n\n![image-20211204171624058](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211204171624058.png)\n\nCPU在进程间的切换\n\n\n\n### PCB表\n\nPCB表：系统把所有PCB组织在一起，并把它们放在内存的固定区域，就构成了一个系统全局的PCB表\n\nPCB表的大小决定了系统中最多可同时存在的进程个数，称为系统的并发度\n\n一个进程与一个PCB是一一映射\n\n\n\n链接结构：同一状态进程的PCB组成一个链表，不同状态的进程对应多个不同链表\n\n索引结构：对具有相同状态的进程，分别设置各自的PCB索引表，表明PCB在PCB表中的地址\n\n\n\n单处理机中，进程间不可并行（不是并发）\n\n\n\n## 进程调度\n\n目的：使CPU的利用最大化，需要优化进程调度的方法\n\n进程调度程序选择一个进程到CPU上执行（一个CPU一个时间段只能执行一个程序，其余程序需要等待CPU空闲重新调度\n\n\n\n### 调度队列\n\n+ 作业（Job）队列：包含系统中所有的进程\n\n+ 就绪（ready）队列：包含了系统中的，驻留在内存中就绪的，准备运行的进程。\n+ 设备（Device）队列：包含了等待特定IO设备的进程列表\n  + 进程可能会有IO请求，请求时可能IO设备在处理其他请求，所以需要等待\n\n![image-20211204201307469](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211204201307469.png)\n\n![img](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70.png)\n\n### 调度程序\n\n+ 长期调度程序（long-term schedule）/作业调度程序（job schedule）\n  + 负责从缓冲池中选择进程，装入内存以便执行\n  + 常用于批处理系统（提交的进程比可立即执行的进程多\n  + 不常用（秒、分钟级别\n  + 控制进内存中进程的数量\n  + 争取IO为主和CPU为主的进程良好混合，以平衡CPU和IO设备的利用率\n\n+ 短期调度程序（short-term schedule）/CPU调度程序（CPU schedule）\n  + 从执行的进程中选择进程，并为之分配CPU\n  + 频繁调用短期调度（毫秒级\n  + 控制CPU的利用率和系统吞吐量\n+ 中期调度程序\n  + 将进程从内存（或CPU竞争中）移出，从而降低多道程序设计的难度，之后，进程可被重新调入内存，并从中断处执行\n\n+ 进程的类型\n  + IO为主（主要是IO传输、许多的CPU bursts\n  + CPU为主（主要是计算，很少的CPU bursts\n\n### 上下文切换\n\n出现原因\n\n+ 中断使CPU从当前任务改变为运行内核子程序，因此当发生中断时，系统需要保存当前程序的上下文，在恢复程序时需要恢复程序的上下文\n+ 将CPU切换到另一个进程需要保存当前程序的状态并恢复另一个程序的状态，任务：上下文切换\n+ 进程的上下文就是进程的PCB\n\n类型：\n\n+ 状态保存：保存当前CPU状态（不论是内核模式还是用户模式\n+ 状态恢复：重新开始之前保存的状态\n\n上下文切换是额外开销，切换时系统不能做其他任何有用的工作。\n\n时间消耗为几毫秒，具体的时间消耗与硬件支持密切相关\n\n有的操作系统提供了多组寄存器集合，上下文切换只需要改变当前寄存器组指针\n\n## 进程操作\n\n\n\n### 进程创建\n\n进程树：进程执行过程中，能够继续创建进程（系统调用），父进程创建子进程，以此类推形成进程树\n\n一般系统有一个根进程，负责创建其他所有进程，只有一棵\n\n通过进程标识符（PID）识别和管理进程\n\nUNIX的进程0和1\n\n+ 0进程：一个特殊进程，在系统引导时被创建\n+ 1进程：当0进程fork一个子进程1后，0进程就变成了对换进程（swaper\n+ 1进程被称为init进程，是系统中其他每个进程的祖先\n+ 进程0是系统中唯一一个不通过fork创建的进程\n\n\n\n资源共享选项\n\n+ 父子进程共享所有资源\n+ 子进程获得父进程资源的子集\n+ 不共享任何资源\n\n地址空间选项\n\n+ 父进程的副本（有相同的程序和数据\n+ 子进程内装入一个新程序\n\n执行选项\n\n+ 父子进程并发执行\n+ 父进程等待子进程执行完毕\n\n关于fork和exec\n\n+ fork命令创建一个新的进程\n+ exec命令在fork命令后执行，用于将新的程序装入进程的内存空间\n\n\n\nUNIX进程创建\n\n+ fork：\n  + 内核为子进程做一个父进程的上下文的拷贝\n  + 子进程与父进程共享子进程创建之前父进程的所有资源\n  + 父进程和子进程在不同的地址空间上运行\n\n+ 资源共享\n  + 继承创建之前父进程拥有的所有资源\n  + 创建之后，父子进程开始资源分离\n\n+ 一般情况下父进程等待子进程结束，并回收子进程\n  + 收集子进程相关信息，如占用的CPU时间等，归到父进程\n  + 进程结束后，其进程表等资源不会被系统释放，父进程回收子进程后才会释放\n  + 如果父进程由于执行错误等某种原因被强行终止，会将子进程归属到1号进程\n\n\n\n内核为系统调用fork完成下列操作：\n\n+ 为子进程在进程表中分配一个空项（empty slot）(PCB)\n\n+ 为子进程赋予一个唯一的进程标识号(PID)\n\n+ 为子进程分配独立的（内存）地址空间\n\n+ 复制父进程的上下文到子进程的地址空间\n\n  + 将父进程的PCB、数据、栈、PC等内容到子进程的相应地址空间中\n\n  + 对于代码：子进程可能调用exec()装入一个新的程序而覆盖父进程的代码，因此有的系统不真正将父进程的**代码**复制到一个新的内存物理区，只是增加该取的引用数即可。\n\n  + **注**：子进程的**PCB**中有父进程访问的文件、设备、运行环境等，如打开的文件，PC等；栈中有局部变量；\n\n+ **对父进程返回**子进程的进程号**，对子进程**返回零。\n\n\n\nfork的返回值\n\n+ 正确执行\n  + 父进程返回子进程的进程号，非零的正整数\n  + 子进程，返回0\n+ 未成功创建\n  + 返回-1\n\nfork的功能\n\n+ 内核为子进程做一个父进程的上下文拷贝\n  + 复制父进程的PCB为子进程的PCB\n  + 在新的地址空间中复制父进程的一个拷贝（有不同的实现\n+ 关于资源\n  + 创建子进程之前父进程的资源：子进程继承\n  + 创建子进程之后进程的资源：各自独立\n+ 父进程和子进程在不同的地址空间上运行\n\n\n\n注意：\n\n子进程会继承父进程的缓冲区、文件、设备描述符\n\nPCB：除进程号以外的所有内容\n\n\n\n进程退出时均自动清理缓存\n\n注：“\\n”, fflush(stdout)都有清空输出缓存的功能\n\n\n\nclose（fd）的作用\n\n+ 释放系统为打开文件所分配的资源，如：文件描述符、文件控制块、文件表中所占用的表项\n+ 清空释放读写缓存，将最后写入到缓存的内容物理写入到磁盘的文件中，避免导致副作用\n\n系统调用execve\n\n+ 执行成功：将用path所指定的可执行文件的副本覆盖调用execve的进程空间，进程号不变，它绝对不会再返回到调用进程\n+ 调用失败返回-1\n+ 系统调用exec之后，子进程不再执行原来的代码，而是执行新程序\n+ 进程中在系统调用exec之后的语句不会被执行\n\n系统调用wait\n\n+ 如果没有子进程，wait直接返回\n+ 子进程结束，父进程尚在运行并且未调用wait，子进程处于zombie僵死状态，并没有被系统撤销，等待父进程回收\n  + 子进程僵死，执行的累计时间加到父进程PCB相应字段中\n  + 释放进程表项，可被分配给新进程\n+ 子进程尚在运行，父进程未调用wait，而是结束执行退出，子进程成为孤儿进程，将给1号进程代管\n  + 父进程进入睡眠，并在子进程执行完毕后被唤醒\n\n\n\n创建多个子进程形成进程树的问题\n\n![image-20211207150907900](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211207150907900.png)\n\n![image-20211207150923157](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211207150923157.png)\n\n\n\n内核为打开文件维护的3个数据结构\n\n+ 进程级的文件描述符表\n  + 每一条目记录了单个文件描述符的相关信息\n+ 系统级的（打开）文件表\n  + 给出了一个打开文件相关的全部信息\n    + 当前文件读写偏移量\n    + 文件访问模式\n    + 对该文件i-node对象的引用\n+ 系统级的（文件系统）i-node表（FCB，索引节点表\n  + 文件索引节点表\n  + 打开一个文件时，将磁盘上的文件的索引节点装入到内核维护的索引节点表中\n  + 设置访问文件是的一些控制信息，如引用数，表示一个文件目前被打开的次数\n\n\n\n子进程使用相同的文件描述符而继承的存取父进程在创建子进程之前已经打开和创建的文件，因此对于同一个文件也就是用相同的文件表项\n\n\n\nsignal\n\n+ 可以在进程中利用signal()系统调用注册自己定义的信号处理函数，当进程收到该信号后，就执行注册的信号处理函数\n+ 如果不注册，则当进程收到该信号后，就执行系统默认的信号处理函数\n\n\n\n### 进程终止\n\n进程终止时间：\n\n+ 执行完最后语句，并使用系统调用exit请求操作系统删除自身\n+ 一个进程通过适当的系统调用终止另一个进程（通常这个进程需要是被终止进程的父进程，并且需要知道被终止进程的标识符\n\n父进程终止子进程的原因一般有\n\n+ 子进程使用的资源超过了父进程分配的资源\n+ 分配给子进程的任务不再需要\n+ 父进程退出，在这种情况下，操作系统不允许子进程继续\n  + 在有些操作系统中，如果一个进程终止，那么它的所有子进程都终止。这叫做级联终止\n\n\n\n进程终止后：\n\n+ 进程会返回状态值（通常为整数）到父进程，所有进程资源都会被操作系统释放\n+ 如果此时父进程终止，那么所有子进程都会以1号进程作为父进程\n\n\n\n## 进程间通信\n\n独立进程：不能影响其他进程且不被其他进程影响\n\n协作进程：能影响其他进程或被其他进程影响\n\n优点：\n\n+ 信息共享\n+ 提高计算速度：将一个任务分解为子任务，并将多个子任务并行执行\n+ 模块化：以模块化方式构建系统，将系统功能划分为独立的进程或线程\n+ 方便\n\n因此需要一个进程间的通信机制（IPC）来允许进程相互交换数据与信息。\n\n+ 共享内存\n+ 信息传递\n\n\n\n在UNIX中有管道，类似于信息传递\n\n\n\n+ 共享内存\n  + 共享内存应该同时属于要共享该存储区的所有进程的地址空间，否则无法访问\n  + 读写时需要进程之间同步\n  + 通信结束后需要将共享内存鱼其地址空间剥离\n\n+ 消息传递\n  + 两个操作：发送（消息大小固定或可变），接受\n  + P和Q想要沟通需要并通过发送、接受交换消息\n  + 通信链路的实现\n    + 物理的：共享内存、硬件总线或网络\n    + 逻辑的：逻辑属性\n  + 直接通信\n  + 间接通信\n\n\n\n消息传递可以是阻塞的，也可以是非阻塞的\n\n+ 阻塞是同步的\n+ 非阻塞是异步的\n\n\n\nint shmget (key_t key, int size, int shmflg)：新建或获取一段键值为key，大小为size，标志为shmflg的共享内存，返回共享内存标识符\n\nint **msgget**(key_t key, int msgflg)：新建或获取一个消息队列，返回消息队列标识符。\n\n\n\n# 线程\n\n![image-20211207164353520](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211207164353520.png)\n\n+ 隶属关系\n  + 一个进程至少需要一个线程，可以拥有多个线程，这些线程运行在其所属进程的上下文中\n  + 线程隶属于进程，线程不能脱离进程而独立存在\n  + 一个线程只能属于一个进程\n\n+ 拥有资源\n  + 进程是拥有资源的基本单位，隶属于同一个进程的多个线程共享该进程的代码、数据、堆、打开的文件（包括标准设备）等IO资源\n  + 线程不能共享进程（主线程）的栈\n  + 因此线程只拥有其运行所必需的资源，如寄存器、栈、程序计数器等\n+ CPU调度与分派的基本单位\n  + 线程是进程的实体，线程运行在其所属进程的上下文中\n  + 线程是CPU调度与分派的基本单位（CPU调度\n  + 进程不再是一个可执行的实体\n\n\n\n线程拥有独立的栈和寄存器集的原因\n\n+ 栈和寄存器集是定义程序执行的动态上下文的组件\n+ 栈会随着函数的调用和返回而增长和收缩，并且每次执行指令后寄存器内容都会发生变化\n+ 栈（stack）包含临时数据\n  + 函数参数、返回地址、局部变量，随函数调用和返回而增长或缩小\n\n\n\n引入进程的原因\n\n+ 多个程序并发执行，提高资源利用率，提高系统吞吐量\n\n引入线程的原因\n\n+ 隶属于同一个进程的多个线程可以并发执行，缩短了进程任务执行时间\n+ 减少进程并发执行时所付出的时空开销（如上下文切换），使操作系统有更好的并发性\n+ 进一步提高了资源利用率\n\n\n\n进程的劣势\n\n+ 进程是资源的拥有者，因此在进程的创建、撤销以及切换中，系统必须为之付出很大地时空开销\n\n+ 进程切换的频率不宜过高\n\n+ 系统中设置的进程数目不宜过多\n+ 限制了并发程度的进一步提高\n\n将进程的两个属性分开，作为独立分配资源的单位，不作为调度和分派的基本单位\n\n\n\n调度\n\n+ 同一进程中，线程的切换不会引起进程切换\n+ 不同进程中的线程之间的切换要引起进程的切换\n\n并发性\n\n+ 引入线程的系统中，同一进程的多个线之间可以并发执行，使系统具有更好的并发性，进一步提高了资源利用率和系统吞吐量\n\n优点\n\n+ 响应性：允许程序在某些部分被阻塞或长时间操作的情况下继续运行\n+ 资源共享：线程共享他们所隶属的内存和资源\n+ 经济：为创建进程分配的内存和资源是相同的，上下文切换也是一样的\n+ MP架构的使用：单线程进程只能运行在一个CPU上，而属于一个进程的线程可以运行在不同的CPU上\n\n\n\n拥有资源\n\n+ 进程是拥有资源的独立单位；\n+ 线程仅拥有比不可少的资源，可以访问其隶属进程的资源；例如进程的代码段、数据段及系统资源，如已打开的文件、I/O设备等，可供同一进程的线程共享；\n\n系统开销\n\n+ 系统创建及撤销进程时的开销远远大于创建及撤销线程时的开销；\n\n+ 进程切换时的开销也远远大于线程切换时的开销；\n\n+ 由于同一进程中的多个线程具有相同的地址空间，致使他们之间的同步和通信的实现，也变得比较容易；\n+ 在有的OS中，线程的切换、同步和通信都无需OS内核的干预；\n\n\n\n## 多线程模型\n\n用户级线程：管理无需通过核心线程干预\n\n核心线程：用户级线程的运行需要映射到相应的核心线程才能完成\n\n\n\n用户级线程\n\n+ 存在于用户空间中，创建、撤销、线程间同步与通信等功能无需利用系统调用来实现，是通过用户级线程库来实现（如pthread\n\n+ 用户级线程的切换也无需内核的支持，通过用户级线程库来管理\n\n+ 切换规则比进程调度和切换规则简单，线程切换速度特别快\n\n+ 线程的管理是与内核无关的，不需要通过系统调用来完成\n\n+ 核心感知不到用户级线程的存在\n\n+ 执行时，需要将用户线程映射到核心线程，由核心线程控制用户线程的执行\n\n  + 如果OS不支持多线程机制，OS内核只能感知到进程的存在（一个线程），因此即使用户创建了多个用户线程，这些用户线程也不能分派到多个CPU上并行执行；\n\n    **当正在执行的用户线程被阻塞，进程就被阻塞，其他用户线程也无法执行；**\n\n三个主要的线程库\n\n+ POSIX Pthreads (for the user-level library-pthread)用户级线程库\n\n+ Win32 threads (user-level library)用户级\n+ Java threads (Windows,UNXI and Linux, for the user-level library)用户级\n\n\n\n线程\n\n+ 系统支持线程，核心线程的管理由内核完成\n+ 现成的创建、撤销和切换都是依靠内核来实现\n+ 需要直接或间接通过系统调用来完成\n+ 线程控制块（TCB）：内核通过TCB感知线程存在，并对其加以控制\n+ 内核支持线程是OS内核可感知的，用户级线程不可感知\n+ OS只为核心线程分配CPU等资源\n\n\n\n映射模型\n\n+ 多对一：许多用户级线程映射到单个内核线程\n\n  + 优点\n\n    + 线程管理由用户空间中的线程库完成，效率高\n  + 缺点\n    + 一次只有一个线程可以访问内核\n    + 多线程无法在多处理器上并行运行\n    + 如果一个线程进行阻塞，整个进程将会阻塞\n  + 用户不支持线程的系统\n+ 一对一模型：每个用户线程映射到一个内核线程上\n  + 优点：\n    + 比多对一模型有更好的并发性\n    + 一个线程阻塞时，其他线程能够继续调用\n    + 多个线程能够并发运行在多处理器\n  + 缺点：\n    + 创建内核线程的开销会影响应用程序的功能\n+ 多对多模型：将许多用户级线程多路复用成更少或相等数量的内核线程\n  + 开发人员可以根据需要创建多个用户线程\n  + 允许多个线程在多处理器上并行运行\n\n## 线程库\n\n线程库为程序员提供了创建和管理线程的API\n\n==实现线程库的两种方法==\n\n+ 提供一个完全位于用户空间的库，不提供内核支持\n  + 用户空间中的所有代码和数据结构都存在于用户空间中\n  + 调用库中的函数导致用户空间中的本地呼叫，而不是系统调用\n+ 提供内核直接支持的内核级库\n  + 库空间中的所有代码和数据结构都存在于内核空间中\n  + 调用库中API中的函数通常会导致对内核的系统调用\n\n\n\n## 多线程问题\n\n系统调用fork和exec\n\n+ 程序中一个线程调用了fork，两种解决方案\n  + 复制所有线程\n  + 只复制调用了系统调用fork的线程\n\n+ exec工作方式\n  + 如果一个线程调用exec，那么exec参数指定的程序会替换整个进程，包括所有线程\n+ 如果fork之后立即调用exec，那么没必要复制所有线程\n+ 如果fork后不调用exec，那么另一进程应该复制所有线程\n\n\n\n### 线程池\n\n用于服务器上，如web服务器\n\n请求到来时为其创建一个线程，并在完成工作后丢弃它\n\n问题：浪费时间、没有效率，无限线程可能耗尽系统资源\n\n解决方案：线程池\n\n+ 在进程开始时创建一定数量的线程，并放入到池中以等待工作。当服务器收到请求时，唤醒池中的一个线程，并将要处理的请求传递给它，一旦线程完成了任务，它会返回池中等待下一个工作。若池中没有可用线程，服务器会一直等待知道有空线程为止\n\n+ 优点:\n  + 通常用现有线程处理请求要比等待创建新的线程要快\n  + 线程池限制了在任何时候可用线程的数量\n\n\n\n# CPU调度\n\n在多重程序操作系统中\n\n+ 多个进程同时保存在内存中\n+ 每当进程阻塞时，另一个进程可以接管CPU\n  + 最大化CPU利用率、由CPU调度实现\n\n调度是操作系统的基本功能，CPU调度是操作系统设计的核心\n\nCPU调度也叫：进程调度或线程调度\n\n\n\n进程的行为或属性\n\n+ 大部分的进程，其CPU执行区间和IO执行区间是交替进行的\n+ CPU执行区间与IO执行区间有时称为CPU执行器与IO执行期\n\n进程执行从CPU区间（CPU burst）开始，之后IO区间（IO burst）和CPU区间交替执行，最终最后的CPU区间通过系统请求中止执行\n\n经过大量CPU区间的长度测试发现\n\n+ 短的CPU区间数量多，长CPU区间数量少\n+ IO约束程序通常具有很多短CPU区间，CPU约束程序可能有少量的长CPU区间\n\n这种分布有助于选择合适的CPU调度算法\n\n\n\n### CPU程序调度\n\n当CPU空闲时，操作系统必须从就绪队列中选择一个进程来执行。进程选择由短期调度程序或CPU调度程序执行。调度程序从内存中选择一个能够执行的进程，并为之分配CPU\n\n就绪队列可以实现为\n\n+ 先进先出队列\n+ 优先队列\n+ 树\n+ 无序链表\n\n就绪队列中的记录通常为PCB\n\n\n\n### 抢占调度\n\n非抢先式调度\n\n+ 又称为非剥夺式调度\n+ 分派程序一旦把处理机分配给某进程后便让它一直运行下去，知道进程执行结束（或错误退出），或者进程等待某事件而被阻塞时，才把处理机分配给另一个进程\n\n抢先式调度\n\n+ 又称为剥夺式调度\n+ 当线程/进程正在处理器上运行时，系统可根据所规定的原则剥夺（抢先）分配给此进程/线程的处理器的执行权，将其移入就绪队列中，选择调度其他进程/线程执行\n+ 一个进程的CPU burst被分割成多个执行段\n\n![image-20211207204957008](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211207204957008.png)\n\n当调度只能发生在1和4两种情况下：非抢占的\n\n否则是抢占的\n\n\n\n进程在操作系统内核程序临界区中不能进行调度与切换：√\n\n进程处于临界区时不能进行处理及调度：×\n\n临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥的访问临界资源\n\n临界区：访问临界资源的那段代码\n\n内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列\n\n\n\n### 分派程序\n\n分派程序（dispatch）是一个模块，用来将CPU的控制交给由短期调度程序选择的进程\n\n功能包括\n\n+ 切换上下文\n+ 切换到用户模式\n+ 跳转到用户程序的合适位置，以重新启动程序\n\n分派程序停止一个进程而启动另一个所花费的时间称为分派延迟\n\n## 调度准则\n\n+ CPU利用率：要使CPU尽可能忙\n+ 吞吐量：指一个时间单元内所完成的进程的数量\n+ 周转时间：从进程提交到进程完成的时间段称为周转时间\n  + 周转时间是所有时间段之和，包括等待进入内存、在就绪队列中等待、在CPU上执行和IO执行\n\n+ 等待时间：在就绪队列中等待所花费的时间之和\n  + CPU调度算法只影响等待时间\n+ 响应时间：从提交请求到产生第一响应的时间\n  + 在交互式系统中，周转时间可能不是最好的标准，周转时间通常收到输出设备的速度限制\n\n需要使CPU使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。\n\n绝大多数情况下需要优化平均值，有时需要优化最大值或最小值，而不是平均值\n\n\n\n## 调度算法\n\n### 先到先服务调度(First-Come，First-Served scheduling)\n\n貌似公平\n\n护航效应：短进程落后于长进程，所有其他进程都等待一个大进程释放CPU\n\n有利于长作业，对短作业不利，系统吞吐量小\n\n该算法通常作为其他调度算法的基本算法\n\n非抢占\n\n### 最短作业优先算法（shortest-job-first scheduling,SJF\n\n将每个进程关联他的下一个CPU burst的长度，CPU空闲时将分配给具有最短CPU区间的进程\n\n两个方案\n\n+ 非抢占：一旦进程分配给一个CPU，就不能被抢占，直到CPU区间执行完毕\n+ 抢占：新进程到达时，其CPU区间小于当前执行的进程的剩余时间，则抢占\n  + 又被称为最短剩余时间优先（SRTF\n\n平均等待时间最小，但是困难在于如何确定下一个CPU区间的长度\n\n+ 系统吞吐量大，平均周转时间短\n+ 有利于短作业，不利于长作业\n+ 饥饿问题：进程长时间得不到调度\n\n\n\n### 优先级调度(priority scheduling algorithm)\n\n将每个进程与优先级相关联，CPU优先分配给优先级高的进程\n\n优先级定义方式\n\n+ 内部定义\n  + 使用可测量的数据来计算：时间限制、内存要求、打开文件数量、平均IP区间的比率\n+ 外部定义\n  + 操作系统之外的标准：进程的重要性等\n\n优先级调度可以是\n\n+ 抢占的\n+ 非抢占的\n\n调度算法的一个重要问题，无限阻塞或者饥饿问题。可以运行但是等待CPU的进程可认为是阻塞的，优先级调度算法会使某个有低优先级的进程无穷等待CPU\n\n解决方式：老化（aging）逐渐增加在系统中等待的进程的优先级\n\n\n\n高响应比调度算法\n\n+ 优先级（相应比）=（等待时间+要求服务时间）/要求服务时间=（等待时间/要求服务时间）+1\n\n+ 每次调度时，系统重新计算各作业或各进程的相应比\n+ 算法既照顾了短作业，又考虑了作业到达的先后次序，也不会使得长作业长期得不到服务\n\nIO时间多的进程应该优先得到被调度程序选中的机会，才可以使CPU与IO设备并行工作\n\n\n\n### 轮转法调度(round-robin,RR)\n\n专门为分时系统设计\n\n类似FCFS调度，但增加了抢占以切换进程\n\n定义一个较小的时间单元称为时间片，将就绪队列作为循环队列。CPU调度程序循环就绪队列，为每个进程分配不超过一个时间片的CPU\n\n算法性能依赖于时间片的大小\n\n时间片非常大——RR算法与FCFS算法一样\n\n时间片很小——处理器共享，性能变为$1/n$\n\n\n\n### 多级队列调度(Multilevel Queue Scheduling)\n\n比如前台（交互）进程和后台（批处理）进程相变比，前台进程有更高的响应时间要求，因此有更高的优先级\n\n+ 将就绪队列依照进程的类型将其分为多个队列，每个队列设置相应的优先级\n\n+ 每个队列有自己的调度算法\n  + 比如前台队列采用RR，后台队列采用FCFS\n+ 队列之间必须有调度\n  + 通常采用固定优先级抢占调度（有饥饿的可能性\n    + 只有当高优先级队列为空的时候，才调度低优先级队列中的进程\n  + 时间片：在队列间划分时间片（80%的时间在前台，20%的时间在后台\n    + 高优先级队列中的进程获得更多的CPU执行时间\n\n\n\n### 多级反馈队列调度(Multilevel Feedback-Queue Scheduling)\n\n多级反馈队列调度允许进程在队列之间移动\n\n根据不同CPU区间的特点以区分进程\n\n+ 进程使用过多的CPU时间——移到较低优先级队列\n+ 将IO约束和交互进程留在更高优先级队列\n+ 在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列——防止饥饿\n\n通常，多级反馈队列调度程序可由下列参数来定义\n\n+ 队列数量\n+ 每个队列的调度算法\n+ 用以确定何时升级/降级到更高/更低优先级队列的方法\n+ 用以确定进程在需要服务时应进入哪个队列的方法\n\n特点\n\n+ 不同队伍有不同的优先级\n+ 不同队伍有不同的调度算法\n+ 不同的队伍有不同的时间片总量\n+ 只有高优先级的队列为空时，才会调度低优先级队列\n+ 当一个进程执行完一个时间片，但尚未结束，则降级进入低级队列\n+ 创建进程进入最高优先级队列\n\n\n\n## 线程调度\n\n+ 本地调度：线程库如何决定哪个线程被调度\n  + 选择用户线程与核心线程的映射顺序\n+ 全局调度：内核如何决定接下来执行那一个线程\n  + 调度核心线程获得CPU执行权\n\n\n\n# 进程同步\n\n+ 同步：进程之间需要协作\n  + 操作之间的偏序关系\n\n+ 互斥：进程需要共享哪一些资源\n\n\n\n\n\n偏序关系图\n\n+ 操作A必须在操作B开始之前完成，称A为B的前驱\n+ 偏序图中圆圈表示操作，有向弧连接两个操作，说明操作之间的偏序关系\n\n\n\n## 概念\n\n同步的概念\n\n并发执行环境下，保持操作之间的偏序关系的行为，称为同步\n\n应用程序实现同步\n\n如何实现：\n\n+ 执行一个操作之前，程序判断是否具备执行的条件\n  + 偏序图中在它之前的那些操作是否已经结束执行\n  + 执行过程中判断，动态判断\n+ 没执行完则需等待\n\n\n\n临界资源\n\n在一段时间内只允许一个进程访问的资源\n\n\n\n互斥的概念\n\n+ 定义：临界资源不能同时访问\n\n+ 互斥是对操作之间并发执行的约束\n\n实现\n\n+ 另一操作正在使用临界资源，则当前操作必须等待\n+ 单处理机中，存在并发，并不能自动满足互斥的条件\n\n互斥的原因\n\n+ 与资源有关\n+ 和操作有关：读/写\n\n\n\n伯恩斯坦条件：读/写、写/写操作不能同时访问同一个资源\n\n\n\n背景\n\n+ 进程可以并发执行\n+ 进程可随时中端、导致部分完成执行\n+ 并发访问共享数据可能导致数据不一致\n+ 维护数据一致性需要确保协作过程有序执行\n\n\n\n**竞争条件** ：多个并发进程同时访问和操作共享数据且执行结果与访问发生的特定顺序有关\n\n原子操作：不间断的完整完成的操作\n\n+ 一个操作中的所有动作要么全做，要么全不做\n+ 操作不可分割、不允许中断\n+ 原子操作在核心态下运行\n+ 常驻内存\n\n原语\n\n+ 完成一定功能的一个过程\n+ 是原子操作、不允许中断\n\n临界资源\n\n+ 一段时间内只允许一个进程访问的资源\n+ 互斥的共享、互斥的访问\n\n临界区\n\n+ 程序中访问临界资源的那段代码\n+ 进程对临界区必须互斥的访问\n+ 将对临界资源的互斥访问转化为对临界区的互斥访问\n\n\n\n### 解决临界区问题\n\n+ 互斥：忙则等待，保证临界区互斥访问\n+ 前进：有空让进，当无进程在临界区执行时，若有进程进入应允许，否则可能会出现饥饿现象\n+ 有限等待：当一个进程申请进入临界区，应限制其他进程进入临界区的次数，以便申请的进程有机会进入临界区\n+ 让权等待：等待的时候释放CPU的执行权（非必须\n\n\n\n两种方法用于处理操作系统内的临界区问题\n\n+ 抢占内核：允许处于内核模式的进程被抢占\n+ 非抢占内核：不允许内核模式的进程被抢占\n\n非抢占内核的内核数据结构从根本上不会导致竞争条件，对于抢占内核需要认真设计以确保内核数据结构不会导致竞争条件\n\n但抢占内核更受欢迎，\n\n+ 更适合实时编程，能允许实时进程抢占处于内核模式运行的其他进程。\n+ 响应更快，处于内核模式的进程在释放CPU之前不会运行过久\n\n\n\n## Peterson算法\n\n一种经典的基于软件的临界区问题算法\n\n在两个进程之间共享两个数据项\n\n> int turn; //turn表示哪个进程可以进入临界区：若turn==i，则进程i允许进入临界区内执行\n>\n> boolean flag[2];//表示哪个进程想要进入临界区\n\n变量turn相当于门票或令牌\n\n+ 获得令牌，进入，没获得令牌，等待\n+ 退出时移交令牌\n+ 两进程轮流访问临界资源\n\n> 进程Pi\n>\n> do{ \n>\n> flag[i]=TRUE;\n>\n> turn=j;\n>\n> while(flag[j]&&turn==j);\n>\n> \t临界区\n>\n> flag[i]=FALSE;\n>\n> \t剩余区 \n>\n> }while(TRUE)\n\n一种谦让过程\n\nPi：已准备好，但先让turn=j，查看Pj是否要运行\n\n登记+令牌\n\n+ 登记，并把令牌交给另一个进程\n+ 退出时消除登记信息\n+ 若双方都已登记，拥有令牌的进程会进入\n+ 对方尚未登记，但拥有令牌，自己会进入\n+ 对方已登记且用有令牌，自己等待\n+ 进入时令该令牌转交\n\n满足三个条件\n\n\n\n## 硬件同步\n\n单处理器——禁止中断\n\n+ 当前运行的代码将在没有抢占的情况下运行\n+ 同上在多处理器上效率太低、耗费时间\n+ 使用这种方法的操作系统不能广泛的拓展\n\n\n\n锁机制\n\n进入临界区前需要得到锁，退出临界区时需要释放锁\n\n> do{\n> 请求锁\n>  临界区\n> 释放锁\n>  剩余区\n> }while(TRUE)\n\n\n\n特殊硬件指令以允许能原子的（不可中断）检查和修改字的内容或交换两个字的内容\n\nTestAndSet 指令：两个指令同时执行在不同的CPU上，那么它们会按任意顺序来顺序执行\n\n> boolean **TestAndSe**t (boolean *target)\n> \t{\n> ​        boolean rv = *target;  **//取锁的状态(test)**\n> ​        *target = TRUE;      **//加锁(set)**\n> ​        return rv:           **//返回锁原来的状态**\n> ​     }\n\n使用方式\n\n> do{\n>  while(TestAndSetLock(&lock);//do nothing\n>      //critical section\n>  lock=FALSE;\n>      //remainder section\n> }while(TRUE);\n\n\n\nswap指令：互换两个变量的值\n\n> void Swap(boolean *a,boolean *b)\n> {\n> boolean temp=*a;\n> *a=*b;\n> *b=temp;\n> }\n\n使用方式\n\n> do{\n>  key=TRUE;\n>  while(key==TRUE)\n>  \tSwap(&lock,&key);\n> \t// *key 与lock的值互换，lock now is true,* \n>     // *if lock原值为false，then key now is false;* \n>     **//如果原来已经加锁，****自己也加锁，****并等待**\n>\n> ​        //critical section\n> ​    lock=FALSE;\n> ​        //remainder section\n> }while(TRUE);\n\n这两种算法解决了互斥，但没有解决有限等待，因为所有的程序执行均为随即执行\n\n\n\n解决有限等待的算法\n\n> do{\n> waiting[i]=TRUE;\n> key=TRUE;\n> while(waiting[i]&&key)\n>  key=TestAndSet(&lock);\n> waiting[i]=FALSE;\n>  //critical section\n> j=(i+1)%n;\n> while((j!=i)&&!waiting[j])\n>  j=(j+1)%n;\n> if(j==i)\n>  lock=FALSE;\n> else\n>  waiting[j]=FALSE\n>  //remainder section\n> }while(TRUE);\n\n为了满足有限等待，当一个进程退出其临界区时，它会循环地扫描数组waiting[i]并根据这一顺序而指派第一个等待进程作为下一个进入临界区的进程。因此，任何等待进入临界区的进程只需要等待n−1次。\n然而，对于硬件设计人员，在多处理器上实现原子指令TestAndSet并不简单。\n\n\n\n## 信号量（semaphore）\n\n应用层面解决临界区问题：信号量\n\n一个不需要忙等待的同步工具\n\n+ 整型变量 Semaphore S\n  + 受保护，只能赋值或wait（）or  signal（）\n+ 两个标准操作：wait（）   signal（）\n  + 又称为P、V操作\n+ 操作为原子操作、不可中断\n\n定义\n\n> wait(S)\n> {\n> while(S<=0)\n>  ;//no-op\n> S--;\n> }\n\n> signal(S)\n> {\n> S++;\n> }\n\n\n\n用法\n\n* 计数信号量：值域不受限制\n* 二进制信号量：为0或为1\n\n> do\n> {\n> wait(mutex);\n>  //critical section\n> signal(mutex);\n>  //remainder section\n> }while(TRUE);\n\n\n\n实现\n\nwait和signal修改共享变量semaphore，因此也是临界区\n\n忙等待：在进入代码段中连续的循环\n\n这种类型的信号量也称为自旋锁\n\n+ 优点\n  + 不用进行上下文切换，减少了系统开销\n  + 若锁占用的时间短，就很有用\n  + 实现代码短\n  + 常用于多处理器系统中\n+ 缺点\n  + 浪费CPU时钟\n\n\n\n解决方式\n\n+ 每个信号量有一个关联队列，队列中有两个数据信息\n  + 值：整型变量\n  + 队列中下一个记录的指针\n+ 两个操作\n  + block：将调用操作的进程放在一个合适的等待队列上\t\n    + 将调用它的进程挂起\n  + wakeup（P）：将一个进程从等待队列中移除并放置在就绪队列中\n    + 恢复进程P的执行\n\n因此信号量定义如下\n\n> typedef struct\n> {\n>  int value;                  //记录了这个信号量的值   \n>  struct process *list;       //储存正在等待这个信号量的进程（PCB链表指针）\n> }semaphore;\n\n因此wait和signal定义修改如下\n\n> wait(semaphore *S)\n>      {\n> S->value--;\n> if(S->value<0)                  //没有资源\n> {\n> add this process to S->list;      //进入等待队列  \n> block();                          //堵塞\n> }\n> }\n>\n> \n>\n> signal(semaphore *S)\n> {\n>  S->value++;\n>  if(S->value<=0)\n>  {                  //上面++后，S仍然还<=0，说明资源供不应求，等待者还有很多，于是唤醒等待队列中的一个\n>      remove a process P from S->list;\n>      wakeup(P);                        //切换到就绪状态  \n>  }\n> }\n\n\n\n资源信号量：s.value的初值代表系统中某类资源的数目\n\n当s.value<0，其绝对值代表在信号量链表队列S.L的长度，即在该信号量下等待的进程数\n\n\n\n### 死锁与饥饿\n\n死锁：两个或多个进程无限地等待一个时间，而该事件只能由这些等待进程之一来产生\n\n饥饿：进程在信号量内无限期等待\n\n\n\n解决思路\n\n+ 将相关问题抽象为前驱图\n  + 节点是进程所对应的需要协调的操作\n  + 边是进程之间的依赖关系\n+ 每条边设置一个信号量\n+ 根据问题设置信号量初值\n+ 对于每一个节点\n  + 若有入边，需要在协调的操作前加wait，信号量与其前驱中signal使用的相同\n    + wait个数与其入边的数目相同\n  + 如果有出边，需要在协调的操作后加signal，信号量与其后继中wait使用的相同\n    + signal个数与其出边的数目相同\n\n\n\n## 经典同步问题\n\n\n\n### 生产者消费者问题\n\n**一个生产者、一个消费者，共享一个缓冲区**\n\n+ 一个输入进程向缓冲区中放入数据，输出进程冲缓冲区将数据输出\n+ 缓冲区每次只能放一个数\n+ 开始时为空\n\n\n\n算法描述三要素\n\n+ 信号量设置\n+ 信号量初值\n+ 算法描述\n\n\n\n> semaphore empty=1,full=0;\n>\n> 生产者（输入进程）结构\n>\n> **do {** \n> ​    **生成出一件产品；**\n> ​     **…**\n> **wait(empty);**\n> ​    **…**\n> add **data** to buffer\n> ​    **…**\n> **signal(full);**\n> **} while (1);**\n>\n> \n>\n> 消费者（输出进程）结构\n>\n> **do {** \n> **wait(full)；**\n> ​     **…**\n> remove data from buffer；\n> ​     **…**\n> **signal(empty);**\n> ​       **…**\n> **消费取走的产品；**\n> **} while (1);**\n\n\n\n**一个生产者，一个消费者，共享N个缓冲区**\n\n缓冲区编号从0~N-1\n\n+ 设下标in跟踪生产者的送数过程，初始为0，每送入一个数据，in=(in+1)%N\n\n+ 设下标out记录消费者的取数过程，初始为0，每取走一个数据，out=(out+1)%N\n\n\n> semaphore empty=n,full=0;\n>\n> int in,out;\n\n\n\n**多个生产者，多个消费者，共享N个缓冲区**\n\n+ 生产者进程\n  + 共享变量 in \n  + 互斥信号量\n+ 消费者进程\n  + 共享变量out\n  + 互斥信号量\n+ 协同信号量\n\n> semaphore mutex1=1,mutex2=1,empty=N,full=0;\n>\n> int in=0;out=0\n>\n> 先同步，申请缓冲池\n>\n> 再互斥，生产者消费者自己互斥\n\n为简化P-C模型的实现，将缓冲池视为一个临界资源；\n生产者与消费者均互斥访问缓冲池；\n\n\n\n总结\n\n+ wait和signal操作成对出现\n  + 互斥信号量，成对出现在一个程序中\n  + 同步信号量，出现在不同程序中\n+ 同步在前，互斥在后\n\n\n\n**一个共享对象，多个读者可同时访问，只允许一个写者访问**\n\n* 读读不互斥\n* 读写互斥\n* 写写互斥\n\n分析\n\n+ 写者之间简单互斥\n+ 读者：两个特殊读者\n  + 第一个进入的：拒绝写者\n  + 最后一个离开的：释放锁，唤醒写者\n\n> semaphore mutex;//用于互斥readcount的修改\n>\n> semaphore wrt;//写者互斥锁\n>\n> int readcount;\n>\n> \n>\n> The structure of a writer process\n>\n> while (true) {\n> ​     wait (wrt) ;\n> ​     // writing is performing;\n> ​      signal (wrt) ;\n> }\n>\n> \n>\n>\n> The structure of a reader process   \n>\n> ​    while (true) {\n> ​       wait (mutex) ;\n> ​       readcount ++ ;\n> ​       if (readcount == 1) wait (wrt) ;\n> ​       signal (mutex) ;\n> ​         // reading is performed\n> ​       wait (mutex) ;\n> ​       readcount - - ;\n> ​       if (readcount == 0) signal (wrt) ;\n> ​       signal (mutex) ;\n> ​    }\n>\n> \n\n上述方案容易出现写者饥饿现象\n\n解决方案：写者优先，有写者到来时，该写者阻止后续读者访问该对象\n\n```\nReader: while(true) {\n                wait(w);         //尽管有读者在读，但封锁刚到来的读者\n                 wait(rmutex);\n                 if readcount=0 then wait(wmutext);\n                 readcount:=readcount+1;\n                 signal(rmutex);\n                 signal(w);\n                  perform read operation;\n                 wait(rmutext);\n                 readcount:=readcount-1;\n                 if readcount=0 then signal(wmutext);\n                 signal(rmutex);\n}\n\nwriter:\n        while(true) {\n                 wait(w);\n                 wait(wmutex);\n                  perform write operation;\n                 signal(wmutex);\n                 signal(w);\n}\n```\n\n\n\n### 哲学家就餐问题\n\n简单方案\n\n```\nThe structure of Philosopher i:\n\nWhile (true)  { \n          wait ( chopstick[i] );\n\t     wait ( chopStick[ (i + 1) % 5] );\t\n\t             // eat\n\t     signal ( chopstick[i] );\n\t     signal (chopstick[ (i + 1) % 5] );\n                 //  think\n\n}\n```\n\n问题：可能会引起死锁\n\n解决方式\n\n+ 最多只允许四个哲学家同时坐在桌子上\n+ 只有两只筷子都可获得时才能拿起筷子\n  + 信号量集\n  + 管程\n+ 使用非对称解决方法\n  + 奇数哲学家先拿起左边的筷子，再拿起右边的筷子\n  + 偶数哲学家拿起右边的筷子，再拿起左边的筷子\n+ 最后一个哲学家先拿起右边的筷子，其他哲学家先拿起左边的筷子\n\n\n\n### 睡眠的理发师问题\n\n理发店里有接待室和理发室构成，理发室一把理发椅，接待室有n把椅子\n\n顾客到达理发店\n\n+ 若座位已满选择离开，若理发室忙，等待室有座位，则在椅子上等待\n\n```\nCustomer:\nWhile (1) {\n      wait(waitingMutex);          //实现对waiting的互斥访问\nif (waiting < CHAIRS)  {   //如果有座位空闲\n   waiting=waiting +1;       //\n   signal(waitingMutex);\n   signal(customers);        //通知理发师（相当于在诊所中交上病例）\n   wait(barberReady);       //等待理发师呼叫（相当于等待医生）\n} \nelse   {                             // 理发店已满，离开\n   signal(waitingMutex);\n   leaving；\n      }\n}\n\nBarber:\nwhile (true)  {\n\twait(customers);  //检查有无顾客（医生查检查是否还有无病例）\n                             //如果没有顾客，睡眠（等待顾客）\n\twait(waitingMutex);         // 实现对waiting的互斥访问）\n\twaiting=waiting-1;\n\tsignal(waitingMutex);      //释放waiting的访问权\n\n\tsignal(barberReady);  //理发师准备好可以服务（呼叫顾客）（呼叫病人）\n\tcut-hair;               //理发（看病）\n}\n```\n\n\n\n### 吸烟者问题\n\n+ 抽烟者问题。假设一个系统中有三个抽烟者进程，每个抽烟者不断地卷烟并抽烟。\n+ 抽烟者卷起并抽掉一颗烟需要有三种材料：烟草、纸和火柴。\n+ 一个抽烟者有烟草，一个有纸，另一个有火柴。\n+ 系统中还有一个供应者进程，它们无限地供应所有三种材料，但每次仅轮流提供三种材料中的两种。\n+ 得到缺失的两种材料的抽烟者在卷起并抽掉一颗烟后会发信号通知供应者，让它继续提供另外的两种材料。\n+ 在两种材料被相应的吸烟者取走之前，不允许供应新的材料。\n+ 这一过程重复进行。\n\n```\nsemaphore tobacco_paper = 0 // waiting for tobacco and paper\nsemaphore tobacco_matches = 0 // waiting for tobacco and matches\nsemaphore paper_matches = 0 // waiting for paper and matches\nsemaphore doneSmoking = 1\n```\n\n\n\n### 捡棋子问题\n\n```\n捡黑子进程\nWhile (true) \n{\n    wait(black);\n     捡一个黑子；\n    signal(white); \n}\n\n\n捡白子进程\nWhile (true) \n{\n    wait(white);\n     捡一个白子；\n    signal(black); \n}\n```\n\n设置初值，black=M，white=N，思考两进程之间执行次数的制约\n\n+ 捡黑子的次数比捡白子的次数最多多M次；\n\n+ 捡白子的次数比捡黑子的次数最多多N次\n\n\n\n### 保证并发度的情况下实现临界资源互斥\n\n```\ntypedef struct {\n  float a;\n  float b;\n}  cnum;\ncnum x,y,z; //全局变量\n\n//计算两复数之和\ncnum add(cnum p, cnum q) {\n   cnum s;\n   s.a=p.a+q.a;\n   s.b=p.b+q.b;\n   return s;\n}\n\n```\n\n| **变量** | Thread1和thread2 | Thread1和thread3 | Thread2和thread3 |\n| -------- | ---------------- | ---------------- | ---------------- |\n| x        | 不共享           | 不共享           | 不共享           |\n| y        | 同时读           | **读写互斥**     | **读写互斥**     |\n| z        | 不共享           | 不共享           | **读写互斥**     |\n\n为了提高线程之间的并发度：仅保证相关临界区互斥访问即可\n\n```\nSemaphore mutex_y1=1;   // 用于thread1与thread3互斥访问y；Semaphore mutex_y2=1;   // 用于thread2与thread3互斥访问y；Semaphore mutex_z=1;     // 用于thread2与thread3互斥访问z；thread1 {   cnum w;   P(mutex_y1);   w=add(x,y);   V(mutex_y1)   …….   }thread2 {   cnum w;   P(mutex_y2);   P(mutex_z);   w=add(y,z);   V(mutex_z);   V(mutex_y2);   …….   }thread3 {   cnum w;   w.a=1;   w.b=1;   P(mutex_z);   z=add(z,w);   V(mutex_z);   P(mutex_y1);   P(mutex_y2);   y=add(y,w);   V(mutex_y2);   V(mutex_y1);   …….   }\n```\n\n\n\n## 管程\n\n信号量及wait、signal操作存在的问题\n\n+ wait与signal位置倒置：违反互斥\n+ signal写为wait：引发死锁\n+ 遗漏wait或signal：违反互斥或引发死锁\n+ wait顺序不当：引发死锁\n\n解决方式\n\n提供更高层的方便用户同步机制，系统将其映射到底层的信号量及wait、signal操作\n\n+ monitor管程\n\n\n\n可把管程的定义理解为一个类定义，与一般的类不同的是，管程有条件变量，用于控制进程之间的同步\n\n并发的进程要互斥的访问管程\n\n+ 同一时间只能有一个进程在管程内活动\n\n\n\n条件变量\n\n+ 进程等待的原因有很多，为区分这些原因\n+ 在不同信号量的等待队列中的进程，等待原因是不同的\n+ 管程中对每个条件变量都予以声明\n\n\n\n# 死锁\n\n一组死锁进程各自拥有资源并且等待这组进程中其他进程拥有的资源\n\n死锁：一组处于等待（阻塞）状态的进程，每个进程持有其他进程所需要的资源，而又等待使用其他进程所拥有的资源，致使这组进程互相等待，均无法向前推进\n\n饥饿\n\n+ 无限阻塞：一个进程可能永远不会从它挂起的信号量队列中移除\n+ 无限就绪：就绪进程因不满足调度策略所需的条件，长时间得不到调度\n\n\n\n死锁产生原因\n\n+ 竞争资源：系统中供进程共享的资源，数目不足以满足进程需求，进程之间要竞争使用这些资源，可能会产生死锁\n+ 进程间推进顺序不当：请求和释放资源的顺序不当，导致进程之间互相等待对方所占用的资源\n\n\n\n## 系统模型\n\n正常操作模式下，进程只能按如下顺序使用资源\n\n+ 申请：申请不能立即被允许，那么申请进程必须等待，直到它获得该资源为止\n+ 使用：进程对资源进行操作\n+ 释放：进程释放资源\n\n资源申请和释放为系统调用\n\n\n\n死锁发生的必要条件\n\n系统中下面四个条件同时满足，那么可能会引起死锁\n\n+ 互斥：一次只有一个进程使用资源\n+ 占有并等待：一个进程必须占有至少一个资源，并在等待其他进程占有的另一资源\n+ 非抢占：资源不能被抢占，只能在完成进程任务后释放\n+ 循环等待：存在一个集合p0到pn，pi等待的资源被pi+1占有\n\n四个条件不独立\n\n\n\n不是必要条件：多实例资源\n\n申请某类资源任何一个实例均可，不能具体到申请哪个实例\n\n![image-20211209222528116](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211209222528116.png)\n\n此时，进程p1、p2、p3均占有资源，并进入等待状态，且互相等待对方所占用的资源\n\n\n\n找出死锁点\n\n+ 死锁进程一定处于阻塞状态\n+ 每个进程的操作应预留一个申请操作，以便以后执行该申请操作时使进程进入等待状态\n\n\n\n资源分配图\n\nP：进程     R：资源\n\nPi->Rj：表示进程Pi已经申请了资源类型为Rj的一个实例，称为申请边\n\nPj->Pi：表示资源类型Rj已经分配给进程Pi，称为分配边\n\n\n\n可得\n\n+ 若分配图没有环，则系统就没有进程死锁\n+ 若分配图有环，那么可能存在死锁\n+ 若每类型只有一个实例，环是死锁存在的充分必要条件。若每类型不止一个实例，环是死锁的必要条件\n\n\n\n## 死锁的处理\n\n+ 使用协议以预防或避免死锁，确保系统不会进入死锁状态\n  + 死锁预防：采取防污染措施，禁止出现污染\n    + 对进程使用资源加上诸多限制条件，以防止系统出现死锁现象\n  + 死锁避免：根据环评结果，决定是否通过项目的审批\n    + 基于进程及系统的一些先验知识，当进程申请资源时，若发现满足该资源的请求可能导致死锁发生，则拒绝该申请\n+ 允许系统进入死锁状态，检测并加以修复\n+ 忽略问题，认为死锁不可能发生\n\n\n\n### 死锁预防\n\n互斥条件不可破坏\n\n\n\n占有并等待\n\n系统保证当进程申请一个资源时，不能占有其他资源\n\n+ 要求进程在开始执行前申请并分配它需要的所有资源\n  + （资源静态分配策略，占有不等待\n  + 申请资源的系统调用在其他系统调用前执行\n+ 当进程不拥有资源时才可以申请资源；进程使用完并释放一种资源后，才可以申请另一种资源\n  + 等待不占有\n\n优点：简单，安全、易于实现\n\n缺点：\n\n+ 资源利用率低、可能发生饥饿\n+ 进程直到运行时才知道它需要多少资源\n\n\n\n非抢占\n\n+ 抢占的资源被添加到正在等待的进程的资源列表中，系统中阻塞的进程的资源被分配给其他等待该资源的进程\n+ 如果申请资源而未满足，则释放自己已经获得的资源\n\n问题\n\n+ 进程只有能重新获得旧资源和正在申请的新资源时才能重新启动\n\n+ 适用于状态可保存及恢复的及的资源，如CPU寄存器、内存等\n+ 不适用于像互斥锁、信号量及打印机这类需要互斥非共享使用的资源\n\n\n\n循环等待\n\n强制对所有资源类型进行完全排序，并要求每个进程按照递增顺序来申请资源\n\n+ 进程可在任何时候申请资源，但请求必须按照资源编号递增的顺序提出\n+ 或当进程申请资源编号小于占有资源编号时，应先释放资源\n\n问题\n\n+ 限制了新类型设备的增加\n+ 先申请到的资源被长期闲置，造成资源浪费\n+ 包括抽象资源时，系统中潜在的资源数目会很大，以至于编号方法无法使用\n+ 增加编程人员负担\n\n\n\n### 死锁避免\n\n要求系统获得以后如何申请资源的附加信息\n\n+ 要求进程声明他可能需要的每种类型资源的最大数量\n+ 死锁避免算法动态的检查资源分配状态，确保永远不会有循环等待条件\n+ 资源分配状态由可用资源、已分配资源的数量以及进程最大需求数定义\n\n\n\n安全状态\n\n如果系统能按照某个顺序未每个进程分配资源（不超过其最大值）并能避免死锁，那么系统状态就是安全的。\n\n即若存在一个安全序列，那么系统处于安全状态，若没有这样的顺序存在，系统处于不安全状态\n\n进程顺序{P1,P2,…,Pn}，如果对于每个Pi，Pi仍然可以申请的资源数小于当前可用资源加上所有进程Pj（其中j小于i）所占用资源，那么这一顺序称为安全序列。\n\n+ 安全状态——可避免死锁\n+ 不安全状态——有可能导致死锁\n+ 避免——确保系统不会进入不安全状态\n\n![img](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70.png)\n\n\n\n避免算法\n\n总体思想：\n\n+ 当进程提出资源请求时，系统进行假分配，然后检测假分配之后的状态是否安全\n\n+ 若不安全，则不满足系统请求\n+ 安全，满足请求\n+ 单实例资源：资源分配图\n+ 多实例资源：银行家算法\n\n\n\n资源分配图\n\n需求边（虚线表示\n\n+ 进程Pi可能在将来某个时候申请资源Rj\n+ 只有申请边变为分配边而不会导致环路时，才允许申请\n\n<img src=\"E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211210170232550.png\" alt=\"image-20211210170232550\" style=\"zoom:50%;\" /><img src=\"E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211210170347255.png\" alt=\"image-20211210170347255\" style=\"zoom:50%;\" />\n\n算法\n\n+ 将一个claim边转变为申请边\n+ 若资源是可获得的，将申请边转变为分配边，否则Pi等待\n+ 如果检测到一个环路，那么请求不被允许，否则请求被允许\n\n\n\n银行家算法\n\n+ 多实例资源\n+ 每个进程必须事先声明最大使用数量\n+ 当进程申请资源时可能不得不等待，判断资源分配是否会使系统仍处于安全状态\n+ 当进程获得它所需的所有资源时，他必须在有限时间内返回\n\n所需数据结构\n\n+ n为系统进程个数、m为资源类型的种类\n\n+ Available：长度为m的向量，表示每种资源类型的现有实例的数量\n  + Available[j]=k：资源类型Rj现在又k个实例\n+ Max：n×m矩阵，定义每个进程的最大需求\n  + Max\\[i][j]=k：进程Pi最多申请k个资源类型Rj的实例\n+ Allocation：n×m矩阵，定义每个进程现在所分配的各种资源类型的实例数量\n  + Allocation\\[i]\\[j]=k：进程Pi已经分配了k个资源类型Rj的实例\n+ Need：n×m矩阵，定义每个进程还需要的剩余资源数量\n  + Need\\[i]\\[j]=k：进程Pi还需要k个资源类型Rj的实例\n+ 向量X和Y，若X≤Y，则X每个分量都≤Y的每个分量\n\n安全性算法\n\n+ 创建Work和Finish向量，长度分别为m和n，work=available，Finish每项均为false\n\n+ 查找i满足\n\n  + (a) Finish [i] = false\n\n    (b) Needi ≤ Work\n\n  + 若没有i满足，跳至步骤4\n\n+ Work=Work+Allocation[i]\n\n  + Finish[i]=true\n  + goto step2\n\n+ 如果所有的Finish[i]==true，那么系统处于安全状态\n\n  + 否则系统处于不安全状态\n\n\n\n银行家算法（对于进程Pi的资源分配算法\n\nrequest[i]：Pi的需求向量\n\n1. Request[i]≤Need[i]\n\n   1. 满足，跳至步骤2\n   2. 不满足报错\n\n2. Request[i]≤Available[i]\n\n   1. 满足，步骤3\n   2. 不满足，等待\n\n3. 假分配，按照如下规则\n\n   1. *Available* = *Available* – *Request;*\n\n      *Allocationi* = *Allocationi* + *Requesti*;\n\n      *Needi* = *Needi* – *Request**i**;*\n\n4. 检查状态修改的安全性\n\n   1. 安全，将资源分配给Pi\n   2. 不安全，Pi必须等待，并恢复旧的资源分配状态\n\n\n\n总结\n\n+ 一个实例的情况，采取具有calimed edge的RAG图\n  + 进程提出资源请求，假装满足\n  + 在RAG图中检测到环，不满足\n  + 否则，满足\n\n+ 多个实例的情况，采取银行家算法\n\n\n\n银行家算法可以避免死锁\n\n系统处于安全状态是，系统中一定无死锁进程\n\n\n\n## 死锁的检测\n\n单实例模型\n\n检测等待图中是否有环路\n\n![image-20211210195449284](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211210195449284.png)\n\n资源分配图化简后仍存在回路\n\n死锁定理：系统处于死锁状态当且仅当系统的资源分配图是不可完全简化的，即RAG图简化后不会使所有进程成为孤立点\n\n复杂度n^2^\n\n\n\n多实例模型\n\n1. 设 Work and Finish 分别是长度为m 和 n的向量，初始化为\n\n   (a) Work = Available;\n\n   (b) 所有i，若Allocationi $\\ne$ 0, 则Finish[i]= false，否则 Finish[i]=true\n\n   ​\t==不占有的进程比不可能产生死锁，因此直接置为true==\n\n2. 找一个进程 i ，满足: (a) Finish[i] == false; (b) Requesti $\\le$ Work；若不存在这样的 i ，转 4\n\n3. 进程结束：Work = Work+Allocationi；Finish[i] = true；转 2\n\n4. 若存在i，使 Finish[i] == false, 则系统处于死锁状态\n\n\n\n死锁检测算法的应用\n\n调用频率取决于\n\n+ 死锁发生的频率\n+ 需要回滚的进程数量\n  + 每一个不相交的循环\n\n如果任意调用检测算法，那么在资源图中可能有许多环路，无法分辨死锁进程\n\n\n\n## 死锁的恢复\n\n+ 终止所有死锁进程\n  + 代价大\n+ 一次终止一个进程，直到消除死锁\n  + 开销大，需要每次都检测\n\n\n\n如何决定终止的顺序\n\n+ 执行的时间、还需多长时间\n+ 使用的资源\n+ 需要的资源\n+ 需要终止进程的数量\n+ 交互进程or批处理进程\n\n\n\n问题\n\n+ 如何决定终止的进程：最大限度减少成本\n+ 回滚：使进程返回某个安全状态\n  + 最简单的方法：终止并重新执行\n  + 有效的方法：回滚到足够打破死锁，系统需要维护进程状态的更多信息\n+ 饥饿：确保不会发生饥饿，最常用的方法是在代价因素上加上回滚次数\n\n\n\n# 内存管理\n\n基本硬件\n\n+ 程序必须被放入内存中并且在进程中执行\n+ CPU能直接访问的存储器只有内存和处理器中的寄存器\n+ 寄存器可在一个时钟周期中访问\n+ 主存访问需要多个时钟周期\n+ Cache用于协调访问速度差异\n+ 内存保护\n\n\n\n## 逻辑地址与物理地址\n\n+ 名地址与名空间\n  + 编程时使用名字表示地址：变量名、标号等\n  + 变量名、标号等构成程序的名空间\n+ 逻辑地址与逻辑地址空间\n  + 编译时无法确定程序在运行时所分配的地址空间\n  + 假设从0开始编址\n  + CPU寻址给出的形式都是逻辑地址，MMU转化为物理地址\n+ 物理地址与物理地址空间\n  + 程序运行时，使用的内存地址\n\n\n\n运行时完成地址映射（现在的OS多采用\n\n+ 运行时将指令使用的逻辑地址映射为物理地址（边执行边变换\n+ 需要硬件支持（MMU\n+ 支持虚拟存储机制（程序可以装入到内存的任何位置\n\n\n\n## 内存管理单元MMU\n\n内存管理单元**Memory-Management Unit** **(**MMU)\n\n+ 硬件设备，完成虚拟地址到物理地址的映射\n+ 重定位寄存器（relocation register），加上用户进程生成的地址\n  + 基址寄存器\n+ 用户只处理逻辑地址\n\n\n\n基址寄存器和界限地址寄存器定义了逻辑地址空间\n\n+ 这些寄存器的值只能由OS设置\n\n![image-20211210204957533](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211210204957533.png)\n\n\n\n\n\n## 用户程序的运行\n\n编写源程序\n\n编译\n\n链接\n\n+ 静态链接（.lib）\n  + 运行之前完成链接，将所有的程序模块链接起来形成可执行文件，运行时直接装入内存\n  + 链接及装入过程费时，有些用不到的模块不需要链接及装入\n  + 不便于模块的升级\n  + 运行速度快\n+ 动态链接\n  + 运行时仅链接需要的模块\n  + 运行调用时进行链接\n  + 减少了链接需要的时间\n  + 节省内存空间\n  + 便于模块升级、共享\n\n装入\n\n+ 绝对装入方式\n\n  + 运行时装入所有模块\n  + 装入时费时，浪费内存；但管理简单，运行时速度快\n\n+ 动态运行时装入  (Dynamic Loading)\n  + 运行时可只装入主控模块\n  + 其它模块被调用时再装入；\n  + 提高了内存的利用率，只有需要的模块才被装入；\n  + 管理复杂，运行时速度降低；\n  + 支持虚拟存储\n\n执行\n\n\n\nSwap交换\n\n+ 一个进程可以被暂时从内存中交换到后备存储器，然后再被带回内存继续执行;\n+ 后备存储-快速磁盘，足够大，以容纳所有用户的所有内存映像的副本;必须提供对这些内存映像的直接访问;\n+ 滚出，滚入交换变量，用于基于优先级的调度算法;换掉低优先级的进程，以便加载和执行高优先级的进程;\n+ 交换时间的主要部分是转移时间;总传输时间与交换的内存数量成正比;\n\n在许多系统(如UNIX、Linux和Windows)上都可以找到交换的修改版本;\n\n系统维护一个随时准备运行的进程队列，这些进程在磁盘上有内存映像;\n\n\n\n## 关注的问题\n\n+ 逻辑地址空间与物理地址空间的管理方法\n  + 分区管理、页式管理、段式管理、段页管理等\n+ 逻辑地址到物理地址的映射方法\n  + 地址变换、重定位、地址绑定\n+ 存储保护机制\n+ 内存共享方法\n+ 碎片、零头\n\n\n\n## 连续内存分配\n\n内存中主要分为以下两部分\n\n+ 常驻操作系统（与中断向量一起保留在低内存\n+ 用户进程（在高内存\n  + 单分区分配\n  + 多分区分配\n\n\n\n重定向寄存器：用来保护用户进程区分自己和别的进程、数据、操作系统\n\n+ 重定向寄存器：物理地址的最小值\n+ 界限地址寄存器：逻辑地址的范围值\n\n\n\n单分区分配\n\n+ 用户区中只有一个分区、每个时刻只能运行一道程序\n\n多分区分配\n\n+ 将用户区划分成多个分区\n+ 每个分区同时只能运行一道程序\n+ 技术\n  + 静态（固定）分区管理\n  + 动态分区管理\n\n\n\n**静态分区分配**\n\n+ 系统初始化时，将内存分为多个分区\n  + 分区数目、大小固定\n  + 每个分区只能运行一道程序\n+ 分区表\n  + 记录分区位置、大小、使用情况\n  + 用于分区管理\n\n+ 内碎片\n+ 地址映射及保护（使用重定向寄存器、界限地址寄存器\n\n\n\n**动态分区管理**\n\n+ 基本思想\n  + 系统初始化时，用户使用的内存空间只划分为一个分区\n  + 对进程所需内存按需分配\n+ 分区表：对已分配的分区进行管理\n+ 空闲分区表：对空闲分区进行管理\n+ 分区分配算法\n+ 地址映射和存储保护（重定向寄存器、界限地址寄存器\n+ 外碎片\n+ 段式管理使用该内存管理方法\n\n\n\n孔：可用的内存块\n\n进程到达时，从一个足够大的孔中为它分配内存\n\n系统维护的信息：已分配分区、空闲分区\n\n![image-20211211203337922](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211211203337922.png)\n\n\n\n动态分区问题\n\n+ 首次适应：分配第一个足够大的孔\n  + 查找从头开始一旦找到足够大的孔，就停止\n+ 最佳适应：分配最小的足够大的孔。\n  + 孔按照大小排列\n  + 可以产生最小剩余孔\n+ 最差适应：分配最大的孔，为了防止外碎片产生\n  + 孔按照大小排列\n  + 产生最大剩余孔\n+ 下一个适应：基于首次适应\n\n首次适应和最佳适应在速度和存储利用率方面优于最差适应\n\n\n\n### 碎片\n\n外碎片：总的内存空间可以满足请求，但是是不连续的\n\n内碎片：分配的内存可能略大于需求的内存，这个大小差异是一个分区的内部未被使用的内存\n\n\n\n通过紧缩减少外部碎片\n\n+ 移动内存内容，将所有的空闲块放入一个大块中\n+ 紧缩仅在重定位是动态的并在运行时可采用\n\n\n\n### 分区式存储管理的特点\n\n+ 整个作业或进程存放在一段连续的内存区域\n+ 管理简单\n+ 对于较大的作业，有事找到一个足够大的连续区域比较困难\n\n\n\n## 分页\n\n连续内存分配的问题\n\n+ 产生碎片\n+ 查找大的连续分区困难\n+ 不是很好的支持虚拟存储机制\n\n解决方式：非连续内存分配\n\n分页\n\n+ 进程的物理地址空间可以是非连续的，只要物理地址可用就行\n+ 帧（页框）：将物理地址划分为固定大小的块\n+ 页：逻辑内存分为同样大小的块\n+ n页大小的程序，需要n个可用的空闲帧\n+ 建立页表来将逻辑地址转化为物理地址\n  + 页号、页内偏移\n\n存储保护\n\n+ 页号越界检查（或设置相应的标志位（有效位\n+ 共享页的访问权限\n\n页面共享：通过页表实现\n\n\n\n逻辑地址划分\n\n+ 页号：用作页表索引，页表包含物理内存中每一页的基址\n+ 页内偏移：结合基址来定义发送到内存单元的物理内存地址\n\n\n\n地址变换过程\n\n+ mmu将逻辑地址划分为页号与页内地址\n+ 查找工作由硬件执行\n+ 检索前将页号与页表长度比较，页号大于等于页表长度，越界\n+ 页表内位置：页表始址+页号*页表项长度\n+ 帧号与页内偏移拼接得到物理地址\n\n\n\n硬件实现\n\n+ 页表可以由一组专门的寄存器实现\n  + 一个页表项用一个或多个寄存器，速度快\n  + 成本高，容量有限\n+ 页表大多驻留在内存中，系统中可设置如下寄存器\n  + PTBR——页表起始地址\n  + PRLR——页表长度\n+ 进程未执行时，页表的起始地址和页表长度存放在PCB中\n\n\n\n访问一个字节需要两次内存访问\n\n+ 页表项\n+ 实际物理地址\n\n加速：转换表缓冲区TLBs（translation look-aside buffer\n\n+ 键（标签\n+ 值\n\n当关联内存根据给定值查找时，它会同时与所有键进行比较。如果找到条目，那么就得到相应的值域\n\n![image-20211211220052722](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211211220052722.png)\n\n有的TLB中还有保护地址空间标识码（ASID）：用来唯一标志进程，并提供地址空间保护\n\n\n\n### 地址变换过程中OS与CPU的分工\n\n（1）根据当前执行的进程的PCB保存的进程页表设置系统的PTBR及PTLR的内容；（软件-OS）\n\n（2）CPU对执行的指令进行解析，分离出欲访问存储单元的逻辑地址；（ 硬件）\n\n（3）MMU将逻辑地址根据规定的页面大小分成页号（P）与页内偏移量（d）两部分；（MMU，硬件）\n\n（4）根据页号P进行地址越界检查（MMU，硬件），如果产生地址越界，则对越界进行处理（软件）\n\n（5）如果没有产生地址越界，则依据页号P查找页表，得到页号P所对应的物理帧号f；（MMU，硬件）\n\n（6）将帧号f作为物理地址的高位部分，页内偏移量d作为物理地址的低位部分，形成逻辑地址所对应的物理地址，送入MAR；（硬件）\n\n\n\n### 内存保护\n\n+ 检查页号是否超出了自己的地址空间所定义的范围（要访问的是否是非法页面，即非法地址）\n\n+ 检查对该页框（帧）的访问许可：只读、读写、执行等；\n  + 在页表中设置相应的位表示该页框的访问许可；\n\n+ 每个页表项设置有效-无效位\n  + 有效：关联的页面在进程的逻辑地址空间中\n  + 无效：该页不在进程的逻辑地址空间中\n\n\n\n### 共享页\n\n共享：非自修改代码，永远不会修改自己\n\nstatic：在函数内定义，表示只被初始化一次\n\n共享代码\n\n+ 一个只读代码的副本，在进程间共享\n+ 非自修改\n+ 在所有进程的逻辑地址空间的相同位置\n  + 共享页面通常包含对自身的引用\n  + 条件跳转、循环\n\n\n\n### 层次页表\n\n一个页框无法容纳整个页表，为页表分配多个页框\n\n层次页表：将一个大的页表分解成多个较小的页表\n\n![image-20211211222255877](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211211222255877.png)\n\n![两级页表方案](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\2-1Q10P95Ub96.gif)\n\n\n\n### hash页表\n\n+ 采用虚拟页码作为哈希表值。哈希页表的每一个条目都包括一个链表\n\n+ 该链表的元素哈希到同一位置（这表示它们有了哈希冲突）。每个元素由三个字段组成：虚拟页码，映射的帧码，指向链表内下一个元素的指针。\n+ 该算法的工作如下：虚拟地址的虚拟页码哈希到哈希表。用虚拟页码与链表内的第一个元素的第一个字段相比较。如果匹配，那么相应的帧码（第二个字段）就用来形成物理地址。如果不匹配，那么与链表内的后续节点的第一个字段进行比较。以查找匹配的页码\n\n![image-20211211224637512](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211211224637512.png)\n\n### 反向页表\n\n正向页表，对每个虚拟页，页表都有一条页表项\n\n+ 表示方式自然，但若空间很大，页表很占内存\n\n反向页表\n\n+ 对于每个真正的内存页或帧，倒置页表有一个条目。\n\n+ 每个条目包含保存在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息。\n+ 整个系统只有一个页表，并且每个物理内存的页只有一条相应的条目\n\n![倒置页表](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\2-1Q10Q00R5R9.gif)\n\n## 分段\n\n分页的问题\n\n+ 实际内存与用户理解的内存不一致\n+ 共享困难\n\n分区的问题\n\n+ 一个作业逻辑空间视为一个连续的整体\n+ 为一个大作业找连续的分区比较困难\n\n用户理解的内存\n\n+ 程序的每部分为独立的单位\n+ 内存中最好也按照该逻辑单位进行管理\n+ 便于程序模块的共享\n\n\n\n分段的基本思想\n\n+ 作业分段，内存按动态分区管理\n+ 内存分配以段为单位\n+ 作业不连续，但是段内连续\n+ 每个段有段名和长度\n+ 逻辑地址格式：段号，段内偏移\n+ 段表：段与段所在内存位置的对应关系\n\n\n\n段表项\n\n+ 基址：包含本段在内存中的的起始物理地址\n+ 界限：本段长度\n\n段\n\n+ **Segment-table base register (STBR)** ：段表在内存中的位置\n+ **Segment-table length register (STLR)**：程序使用的段数\n\n\n\n内存保护\n\n+ 段表项中关联\n  + 有效位\n  + 读写权限\n  + 段界限\n+ 与段相关的保护位：代码共享发生在段级别\n+ 段长度不同：动态内存分配\n\n\n\n## 分段与分页的区别\n\n+ 页是信息的物理单位：方便系统管理\n\n  段是信息的逻辑单位：满足用户需要\n\n+ 页的大小固定且由系统决定：机器硬件实现\n\n  段的长度不固定、取决于用户编写的程序：编译程序根据信息的性质划分\n\n+ 分页的作业地址是一维的：只需一个地址记忆符\n\n  分段的作业地址是二维的：段名+段内地址\n\n\n\n## 段页式\n\n基本思想\n\n+ 作业先分段，各段再分页\n+ 内存分配以页为单位\n+ 作业有段表，记录段起始位置和段长\n+ 每个段有页表\n\n\n\n\n\n# 虚拟内存\n\n绝对装入方式：作业运行前，将作业全部装入，知道运行完之后才释放内存\n\n+ 作业在每次运行时并非使用到或暂时未使用到全部数据或程序\n+ 有的模块因IO长期等待、很少运行，仍需占用内存\n+ 编写程序长度大于实际物理内存\n\n\n\n局部性原理\n\n+ 时间局部性\n  + 某条指令执行后，不久可能重复执行。循环结构\n  + 某个数据结构访问后，不久可能重复访问。数组+循环\n+ 空间局部性\n  + 访问某个内存单元后，附近的存储单元也被访问\n  + 顺序性、数组+循环\n\n虚拟存储器、cache\n\n\n\n基本思想\n\n+ 在虚拟地址空间中编址\n+ 程序运行时只装入当前要运行的那部分页面或段\n+ 缺页、缺段：请求调页\n+ 内存已满：置换功能\n\n虚拟内存指仅把作业的一部分装入内存便可以运行作业，具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\n\n+ 逻辑容量：内存容量和外存容量之和\n+ 运行速度：接近内存速度\n+ 每位成本：接近外存\n\n\n\n优点\n\n+ 将一个大的用户程序在较小的内存空间中运行\n+ 内存中可同时装入更多的进程并发执行\n+ 在虚拟地址空间中编制，简化了编程工作\n+ 提高了并发度、吞吐量、减少IO时间\n\n\n\n## 虚拟内存的实现\n\n\n\n相关问题\n\n+ 访问页面时，检测一个页是否已存在在内存\n+ 不在内存时如何处理\n+ 内存无空闲页框时如何处理\n+ 页面置换过于频繁时，会引起系统不稳定如何处理\n\n\n\n\n\n### 按需调页\n\n在需要的时候将页面放入内存\n\n+ IO更少\n+ 所需内存更少\n+ 响应更快\n+ 支持更多用户\n\n懒惰交换（lazy swapper）：除非需要页，否则不交换到内存中\n\n\n\n### 基本概念\n\n是否在内存\n\n+ 页表中指明对应页是否在内存\n  + 有效位和无效位\n    + valid：对应页有效且在内存\n    + invalid：对应页无效或不在内存\n  + 若为i，需要 **page fault** 进一步判断i的含义（无效还是不在内存\n+ 存在位：existence bit，用于指明相应页是否在内存\n\n\n\n判断页是非法还是合法但不在内存\n\n+ 两个页表\n  + 每个进程维护一个进程页表包含当前内存分配状态：有效页及其是否在内存中\n  + 操作系统维护一个页表来执行进程\n  + 操作系统将系统页表保存到旧的进程页表，或从计划调度的进程获取系统页表\n+ 在页表中每个页表项添加一个存在未exitence bit\n  + 表明是否在内存\n\n\n\n页不在内存时如何处理\n\n系统中断：page fault（页面失效、页面错误、缺页中断\n\n+ 看另一个表来判断\n  + 系统页表和进程页表\n  + 页面非法：abort\n  + 不在内存：调入内存\n+ 获得一个空页框\n+ 从磁盘中交换页框\n+ 重新设置页表，设置有效位无效位为v\n+ 重启造成页面错误的指令\n\n\n\n 问题\n\n+ 缺页中断是在指令执行期间发生\n  + 可能产生多次缺页中断\n+ 有时重启被中断的指令不可行\n\n\n\nPage Fault Rate\n\nEffective Access Time（ETA）=（1 – *p*) x memory access \n\n​\t\t\\+ *p* (page fault overhead\n\n​\t\t\\+ swap page out\n\n​       \\+ swap page in\n\n​       \\+ restart overhead )\n\n\n\n\n\n### 写时复制\n\n+ 写时复制允许父进程和子进程共享同一页\n  + fork调用不真正复制父进程到子进程空间，而仅仅是建立一个引用\n\n+ 只有修改后，才会导致真正的复制\n\n\n\n\n\n## 页面置换\n\n在内存中找到一些没有实际使用的页面，并将其替换掉\n\n性能：希望导致最少数量的页面错误\n\n同一页可能被多次装入内存\n\n完成了逻辑内存和物理内存的分离\n\n\n\n修改page fault例程，包括页面替换，防止内存过度分配\n\n使用脏位：只将修改的页写入磁盘\n\n\n\n1. 在磁盘上找到所需页面的位置(如何找到?)\n\n2. 寻找空闲帧:-如果有空闲帧，使用它-如果没有空闲帧，使用页面替换\n\n   选择被替换帧帧的算法-如果这个受害者帧被读取后被修改过\n\n   然后将被替换帧写入磁盘;\n\n   更改页并相应地更改页框。\n\n3. 将需要的页面放入(新的)空闲页框中，更新页和页表\n\n4. 重新启动进程\n\n\n\n### 页面置换算法\n\n分配给进程的页框越多，产生页面错误次数就越少\n\n但当分配的页框数大于5时，错误次数下降缓慢\n\n即使分配过多的帧，对于提高进程的执行效率作用不是很明显；\n\n\n\n### 先进先出页面置换\n\n系统维护一个为作业的页面分配物理帧顺序的先进先出队列；\n\n最后分配的总是放在队尾；\n\n首先淘汰队首的页面；\n\n\n\n特点\n\n+ 简单直观、易于编程理解\n+ 性能并不总是很好\n  + 被替换的页面可能是初始化模块，以后不被需要\n  + 被替换的可能为早期初始化、但常被使用的变量\n+ 可能导致Belady’s Anomaly\n  + more frames more page faults，页框越多页面错误越多\n\n\n\n### 最优置换\n\nbelady提出的理论上的算法：被淘汰的页面是以后永不使用，或在最长未来时间内不再被访问的页面\n\n理论上的，无法实现，因为无法获取未来页面使用序列\n\n可用于比较研究，作为上限\n\n\n\n### 最近最少使用LRU\n\n淘汰最近最久未使用的页\n\n两种方法\n\n+ 计数器：页表中记录页的访问时间\n  + 难以维持时间\n  + 时钟溢出\n+ 堆栈：引用某页后，将其在堆栈删除并放在顶部\n  + 淘滩栈底的页面\n\n\n\n### 近似LRU页置换\n\n+ 页表项关联引用位 \n  + reference-bit\n+ 引用时将引用位置1\n\n+ 编号最小的页面为LRU页面\n+ 每隔一段时间清零\n\n开始时所有引用位清零\n\n\n\n**附加引用位算法**\n\n![image-20211212172001282](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211212172001282.png)\n\n\n\n**二次机会算法（Clock）**\n\n基本算法为FIFO算法\n\n检查引用位\n\n+ 为1：给第二次机会，选择下一个FIFO页，引用位清零，到达时间为当前时间\n+ 为0：直接替换\n\n实现方式：循环队列\n\n\n\n**增强型二次机会算法**\n\n在二次机会算法上，再增加一个修改位\n\n+ (0,0)最近没有使用且也没有修改。—用于置换的最佳页\n+ (0,1)最近没有使用但修改过。—不是很好，因为在置换之前需要将页写出到磁盘\n+ (1,0)最近使用过但没有修改—它有可能很快又要被使用\n+ (1,1)最近使用过且修改过—它有可能很快又要被使用，且置换之前需要将页写出到磁盘\n\n当页需要置换时，每个页都属于这四种类型之一。置换在最低非空类型中所碰到的页，可能要多次搜索整个循环队列。\n\n\n### 基于计数的算法\n\nLFU最近最少用\n\nMFU最常用\n\n\n\n\n\n## 页框分配\n\n每个进程需要最小页框的数量\n\n两种分配方式\n\n+ 固定分配\n  + 平等分配\n  + 比例分配\n    + 进程规模、优先级\n+ 动态分配\n\n\n\n全局分配和局部分配\n\n全局置换允许进程从所有帧集合中选择一个进行置换，而不管该帧是否已分配给其他进程，\n\n+ 它可以从其他进程抢夺帧，比如高优先级抢夺低优先级的帧；\n\n局部置换要求每个进程仅从其自己的分配帧中进行选择\n全局置换通常有更好的吞吐量，且更为常用。一个问题是不能控制页错误率。因为局部置换不能使用其他进程的不常用的内存。\n\n## 系统颠簸\n\n如果一个进程在换页上用的时间多于执行时间，那么这个进程就在**颠簸（thrashing）**，颠簸其实就是频繁的页调度行为。\n\n+ 页框数量不足\n\n\n\n系统颠簸会导致\n\n+ CPU利用率低->系统认为应该增加并发度->添加新的进程->CPU利用率更低\n\n\n\n分配的帧数小于局部区域的大小，系统就会颠簸\n\n局部\n\n+ 进程访问的页的集合，这些页在使用上具有关联性\n+ 一段程序或数据一般由若干个局部组成，在任何时刻t，进程总处于一个或多个局部中\n  + 当所有的局部都装入内存，缺页率会很低\n  + 从一个局部迁移到一个新的局部，缺页率会升高\n\n\n\n**预防系统颠簸**\n\n为进程分配足够多的帧（至少能容纳当前的一个局部\n\n根据局部性原理，每个进程**最近使用的页框数**作为**将要使用的页框数的近似值**；\n\n对一个时间段对每个进程访问的页面进行采样，**作为对进程一个局部的近似；**\n\n即根据在一个时间窗口内每个进程所访问的页面踪迹，得出**该时间段内每个进程所访问的页面集合，即每个进程的**工作集；\n\n**将该工作集的大小作为每个进程需求内存的下限；**\n\n**如果所有进程需要的页框数之和 > **系统**可用**的页框数，则可能导致系统**抖动**，**需挂起或终止部分进程，以释放内存**，将它们分配给其它的**进程；**\n\n\n\n工作集窗口：固定数量的页面引用,例如:取10000指令,或100页;\n\n工作集：最近工作集窗口页面引用中的一组页面\n\n工作集大小：在最近的工作集窗口中引用的页面总数(随时间变化)\n\n对一个时间段（窗口）对进程访问的页面进行采样，得出其运行所需的最小帧数，作为将来一段时间内该进程所需内存的近似值，**并根据该数值对进程的内存进行调整。**\n\n\n\n应用\n\nOS监视每个进程的工作集，为进程分配足够的内存以容纳进程的整个工作集（页框数>=WSS）；\n\n\n如果进程有多余的页框，可以把它们分配给其它进程并启动该进程；\n\n注：当进程的局部转移后，需要的内存的页框数也随之改变，每个进程需要的页框数是动态改变的；\n\n这里进程所需页框数也只是一个近似估计值；\n\n\n如果所有进程的WSS之和超过了系统可用的页框数，则选择一个进程并挂起，令其释放内存，将释放出的内存分配给其他需要的进程；\n\n\n\n## 内存映射文件\n\n文件的内存映射\n\n使用虚拟内存技术，可以将文件IO处理为常规内存访问\n\n\n\n文件访问按照普通请求页面调度来进行\n\n+ 页大小的部分文件就被读入到内存中\n+ 文件的读写按照普通内存访问来处理\n\n通过内存而不是read() write()系统调用来处理文件I/O，从而简化文件访问\n\n还允许多个进程映射同一个文件，从而共享内存中的页面。\n\n\n\n## 内核内存分配\n\n内核内存分配通常从空闲内存池中获取\n\n内核内存分配与普通用户不同\n\n+ 内核分配内存时，有时需要的空间不到一页\n  + 谨慎分配内存，减少浪费\n+ 有些硬件需要直接和物理内存交互，因此需要分配连续的物理页\n\n\n\n## 其他需要考虑的事情\n\n\n\n预调页\n\n为了减少进程启动时的大量缺页中断\n\n\n\n页大小\n\n页大小的选择需要考虑\n\n+ 碎片：页要小\n+ 页表大小：大页面\n+ IO开销：大页面\n+ 局部性：小页面\n  + 总的IO减少，局部性将会得到改善\n  + 小页面会更好的匹配局部性\n\n\n\nTLB(translation look-aside buffers)页表缓冲\n\nTLB命中率\n\nTLBreach：从TLB访问的内存量\n\n+ =TLB大小*页面大小\n\n增加页面大小\n\n+ 这可能会导致碎片的增加，因为并非所有应用程序都需要大的页面大小\n\n提供多种页面大小\n\n+ 这允许需要较大页面大小的应用程序有机会使用它们，而不会增加碎片\n\n\n\nIO锁：页有时需要被锁定在内存中\n\n对于一些特殊的页面，如用于I/O缓冲去的页面，不能置换出去\n\n\n\n# 文件系统\n\n\n\n## 文件的概念\n\n文件是记录在外存上的相关信息的具有名称的集合。其具有**连续的**逻辑地址空间.通常，文件表示数据和程序。\n\n\n\n文件属性\n\n+ 名称：按人们易读的方式保存的信息\n+ 标识符：用户不可读，用于在文件系统内进行该文件的标识\n+ 类型：用于操作系统辨认并执行\n+ 位置：文件位于硬盘上的位置的指针\n+ 大小：大小\n+ 保护：控制谁可以读、写、执行\n+ 时间、日期和用户标识：创建，上次修改，上次访问时间等信息，用于保护，安全，使用跟踪\n\n\n\n有关文件的信息保存在目录结构中，目录结构保存在磁盘上\n\n+ 目录表+FCB\n  + 文件控制块\n+ 目录表+Inode\n  + 索引节点\n\n\n\n文件操作\n\n创建：包含到文件系统中找到空间和在目录中为文件创建一个条目\n写：需要执行系统调用。另外需要搜索目录查找文件位置和为该文件维护一个写位置的指针并在发生写操作时不断更新指针位置\n读：需要执行系统调用。过程同写，需要搜索过程和维护读指针的位置\n重定位：设置文件位置指针为给定值。该操作不需要真正的IO操作，也叫做寻址（seek）\n删除：搜索，释放相关空间，并删除相应条目。\n截短文件（truncate）：将文件长度设置为0KB，并释放相关空间，但不改变其他属性（不删除条目）。如截短一个命名为a.txt的文本文件后，它的大小会变为0kb，但文件名和其他属性可能没有变化。\n\n+ 上述的操作都涉及到为给定的文件搜索其在目录中的相关位置，为了避免不断搜索，在首次使用文件时，和使用完毕文件时，还需要执行两个操作：\n  + ​    打开（open）：为系统调用。将执行搜索，并将相关文件的所有内容都移动到内存中，需要操作时，通过该表的索引指定文件，并直接在内存中进行操作，从而避免了重新搜索和IO操作。\n  + ​    关闭（close）：为系统调用。将文件的索引从信息表中删除，并将相关信息从内存写到外存。\n\n操作系统维护包含所有打开文件的信息表（open-file table），当需要文件操作时，通过该表的索引指定文件。\n ![image-20211212212517534](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211212212517534.png)\n\n- 文件指针：读和写操作的指针\n- 文件打开计数器：一个文件可以被多个进程打开，文件打开计数器记录该操作，当计数器为0时，可以删除该文件条目。\n- 文件磁盘位置：定位文件在磁盘的位置\n- 访问权限：每个进程用一个访问模式访问文件。\n\n\n\n## 目录结构\n\n文件系统实现对文件的按名存取\n\n文件目录表：文件系统中的数据结构，实现文件名与文件在磁盘物理位置之间的映射关系\n\n\n\n硬盘的物理格式化与逻辑格式化\n\n物理格式化：将一个混沌的磁盘表面划分为磁道与扇区\n\n逻辑格式化\n\n+ 划分磁盘的逻辑块\n+ 创建文件系统\n+ 建立文件系统在磁盘上的布局\n+ 建立文件系统的数据结构：\n  + 引导块、超级块、目录表、FCB表（索引节点表）文件分配表（FAT）、空闲块索引表\n\n\n\n磁盘的逻辑块与物理块\n\n+ 逻辑块：文件系统将磁盘视为一个逻辑空间，该逻辑空间由大小相等的一些磁盘块组成，一个逻辑块是文件系统操作的基本单位；\n\n  + 文件系统以逻辑块为单位为文件分配硬盘空间\n\n+ 物理块：数据在磁盘上的最小存取单位，也就是每进行一次I/O操作，最小传输的数据大小\n\n  + 一般物理块小于小于等于逻辑块大小；\n\n    通常，一个物理块对应一个扇区；\n\n\n\n主引导记录：操作系统对磁盘进行读写时对分区合法性的判别、分区引导信息的定位；\n\n存放在主引导扇区\n\n\n\n效率 - 快速定位文件\n\n命名 - 方便用户\n\n​\t两个用户可以为不同文件具有相同的名称\n\n​\t同一个文件可以有几个不同的名称\n\n​\t\t如文件共享，链接文件，快捷方向\n\n分组 - 按属性进行文件分组文件，（例如，所有Java程序，所有游戏，......）\n\n文件共享\n\n\n\n**目录结构**\n\n+ 单目录结构：文件系统只有根目录，没有子目录\n  + 分组问题\n\n+ 双层目录结构：每个用户一个目录\n  + 路径名、分组问题\n\n+ 树形目录结构\n  + **路径名：**路径名有绝对路径和相对路径两种形式，**绝对路径**从根路径开始，**相对路径**从当前目录开始\n  + 目录删除\n    + 强制要求如果目录不为空就无法删除目录。如MS-DOS系统\n    + 递归删除目录下的所有子目录和文件。如linux下的rm命令\n\n+ 无环图目录：树状目录结构的一个扩展，允许目录含有**共享子目录和文件**\n\n\n\n## 挂载文件系统\n\n+ OS启动后，系统维护一个根目录(/)，或根文件系统，或主文件系统\n+ 系统或用户可以根据自己的权限访问该根文件系统\n+ 其它文件系统必须挂载到该根文件系统，或挂载到一个可访问的文件系统中才能被访问\n\n\n\n# 文件系统实现\n\n磁盘提供大量的外存空间来维持文件系统。磁盘的下述两个特点使得其成为存储多个文件的方便介质。\n\n+ 可以原地重写；\n+ 可以直接访问磁盘上的任意一块信息。\n\n为了提供对磁盘的高效且便捷的访问，操作系统通过文件系统来轻松地存储、定位、提取数据。文件系统有两个设计问题。\n\n+ 定义文件系统对用户的接口\n+ 创建数据结构和算法来将逻辑文件系统映射到物理外存设备上\n\n![img](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70.png)\n\n+ IO控制为最底层，提供设备驱动程序和中断处理程序。实现内存和磁盘之间的信息传输\n+ 基本文件系统发送命令，对磁盘上的物理块进行读写。  每个块通过磁盘地址标识（驱动器，柱面，磁道，扇区）\n+ 文件组织模块将逻辑地址转换为物理地址，管理文件的逻辑块。同时含有空闲空间管理器，跟踪未分配的块，并根据要求提供给文件组织模块。\n+ 逻辑文件系统管理元数据，管理目录结构，提供给文件组织模块必要的信息。以及通过文件控制块（file control block，FCB）维护文件结构\n\n![image-20211212220328828](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211212220328828.png)\n\n左箭头为文件指针\n\n\n\n## 虚拟文件系统\n\n把多个文件系统整合为一个目录结构\n\n![img](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70.png)\n\n虚拟文件系统(VFS)是物理文件系统与文件系统服务之间的一个接口层（VFS Interface），它对每个物理文件系统的所有细节进行抽象，并为这些不同的文件系统提供了一个统一的系统调用接口。\n\n**VFS**\n\n并不是一种实际的文件系统,只是系统核心的一个管理模块\n\n它只存在于内存中，不存在于任何外存空间\n\nVFS在系统启动时建立，在系统关闭时消亡。\n\n\n\nVFS层有两个目的：\n\nVFS层通过定义一个清晰的VFS接口，以将文件系统的通用操作和具体实现分开。多个VFS接口的实现可以共存在同一台机器上，他允许访问已安装在本地的多个类型的文件系统。\nVFS提供了在网络上唯一标识一个文件的机制。VFS基于称为vnode的文件表示结构。UNIX内核中为每个活动节点（文件或目录）保存一个vnode结构\n\n\n\n## 目录实现\n\n+ 与数据块指向指针的文件名的线性列表。\n  + 易于编程\n  + 耗时的执行，查找文件需要线性搜索。\n\n+ 哈希表 - 具有哈希数据结构的线性列表。\n  + 减少目录搜索时间\n  + 碰撞 - 两个或多个文件名散列到同一位置的情况\n  + 固定尺寸，以及哈希函数对该大小的依赖性\n\n\n\n\n\n## 分配方式\n\n如何为文件分配空间，一遍有效的访问和索引文件\n\n有效地利用外存空间（额外的磁盘空间、碎片）\n\n提高对文件的访问速度（随机存取）\n\n保证可靠性（是否容易导致文件的损坏）\n\n易于文件扩展\n\n实现难度\n\n\n\n•文件名->文件目录表->FCB->存储文件内容的磁盘块\n\n\n\n### 连续分配\n\n要求每个文件在磁盘上占有一系列连续的块。\n\n**优点：**\n\n+ 在访问块b后访问块b+1通常不需要移动磁头，当需要移动时（读到当前磁道末），只需要移动一个磁道。因此访问连续分配文件需要的寻道数最小。性能较好。\n+ 访问容易，连续分配支持**顺序访问和直接访问**。\n\n缺点：\n\n+ 如何为新文件找到空间，这是一个动态存储分配问题（第八章提到过），相关的算法会产生外部碎片问题\n\n外部碎片的一个解决方案是合并（compact），即将小的空闲空间合并起来，而将其他存储的数据变成连续数据。显而易见这种方式的主要开销是时间，因为需要很多的IO操作。不能扩展\n另一方面，这种方式还需要确定一个文件占用多少空间。文件的大小有时候可能比较好确定，但通常比较难以确定。\n\n\n\n### 链接分配\n\n每个文件都是一个磁盘块的链表:磁盘块可以分散在磁盘的任何地方。\n\n优点：\n\n没有外部碎片，空闲空间的任何一块都可以满足要求。\n创建文件时，不需要说明文件大小。\n不需要合并磁盘空间\n\n可以说链接分配解决了连续分配的所有问题。\n\n缺点：\n\n只能用于顺序访问，要找到中间位置，必须跟随指针一块一块的移动。\n指针需要空间。\n可靠性较低。如果硬盘损坏，若损坏的是指针，那么这可能导致链接到错误的位置。\n\n\n\nFAT文件分配表\n\n将前面介绍的隐式链接中的Linked域独立出来，构成一个FAT表，专门用于实现磁盘块之间的链接。\n\n+ 为磁盘的每一个磁盘块建立一个表项，称为FAT表\n+ 对于一个文件，其FCB中存储该文件的第一个磁盘块的块号\n+ 每个FAT表项存储该文件的下一个磁盘块的块号\n+ 每个文件的最后一个磁盘块的FAT表项中存储一个特殊的结尾符\n\nFAT中通常称一个磁盘为一个簇\n\n\n\n### 索引分配\n\n+ 随机访问\n+ 创建文件时不需要声明文件大小\n+ 没有外部碎片\n\n\n\n浪费空间\n\n+ 动态访问无需外部分片，但有索引块开销。\n+ 索引块的指针开销通常比链接分配的大\n\n\n\n针对缺点的解决方案：\n\n    链接方案：一个索引块通常为一个磁盘块，因此，它本身能直接读写。为了处理大文件，可以将多个索引块链接起来多层索引：用第一层索引块指向一组第二层的索引块，第二层索引块再指向文件块，这是链接表示的一种变种。组合方案：将索引块的头15个指针存在文件的inode中。这其中的前12个指针指向直接块。其他的3个指针指向间接块。第一个间接块为一级间接块的地址，第二个间接块为二级间接块的指针，第三个间接块为三级间接块指针\n\n\n\n\n## 空闲空间管理\n\n系统需要维护一个空闲空间链表（free-space list），该链表记录了所有的空闲磁盘空间，并在创建文件时，能够从该链表搜索并返回一段空闲空间。\n\n  虽然名字称为链表，但实现形式不一定表现为链表。这一点要注意\n\n\n\n### 位图\n\n采用位图（bit map）或位向量（bit vector），每块用一位表示，分配表示1，未分配表示0\n\n优点：\n\n查找空闲块和n个连续空闲块相对简单和高效。\n\n缺点：\n\n除非将整个位图都放在内存中方便及时查询，否则其效率就不是很高。这对于小型磁盘是完全可以的，但对大型磁盘，就需要相对较多的内存。\n\n### 链表\n\n将空闲磁盘块用链表连接起来，并将指向第一个空闲磁盘块的指针保存在磁盘的特殊位置，并同时放置到内存中。\n\n这种方案的效率不高，因为遍历一遍链表需要大量的IO，但通常分配空闲空间不需要遍历，只需要将第一块分配即可。\n\n### 组group\n\n专门设置一些磁盘块临时存储多个空闲磁盘块的块号；\n\n磁盘块号保存在同一个磁盘块中的那些空闲磁盘块，构成一组。\n\n是为成组链接法；\n\n将n个空闲块分成一组，每组中的第一块或最后一块保存下一组的空闲块地址，依次类推；\n\n第一组的块地址保存在一个特殊空闲块中；\n\n\n\n### Counting\n\n建立一个类似于分区内存管理中的分区表；\n\n每个表项记录第一块的块号和与第一块连续的空闲块的数量；\n\n\n\n容易找到连续的空间\n\n需要额外的空间\n\n\n\n## 效率和性能\n\n效率取决于：\n\n磁盘分配和目录算法\n\n在文件的目录条目中保存的数据类型\n\n\n\n表现\n\n磁盘缓存 - 用于常用块的单独部分主内存\n\n释放和预读 - 优化顺序访问的技术\n\n通过将内存部分作为虚拟磁盘或RAM磁盘致敬，提高PC性能\n\n\n\n# 大容量存储器\n\n![img](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70.png)\n\n+ 传输速率：驱动器和计算机之间的数据传输速率\n+ 定位时间/随机访问时间：由寻道时间和旋转等待时间组成\n+ 寻道时间：移动磁臂到所有的柱面的时间\n+ 旋转等待时间：等待所要的扇区旋转到磁臂下所用的时间\n\n## 磁盘结构\n\n现代磁盘驱动器可以看为是一个一维的逻辑块的数组，\n\n其按顺序映射到磁盘的扇区\n\n+ 扇区0是最外柱面的第一个磁道的第一个扇区。\n\n+ 逻辑块是最小的传输单位\n\n\n\n映射顺序：磁道内的扇区顺序$\\Rightarrow$柱面内磁道顺序$\\Rightarrow$柱面从外到内的顺序\n\n\n\n磁道划分扇区，扇区存储容量相同、半径不同\n\n柱面：于同一个垂直区域的磁道称为柱面\n\n\n\n## 磁盘调度\n\n寻道时间：磁臂将磁头移动到包含目标扇区的柱面的时间。\n旋转延迟：磁盘将目标扇区移动到磁头下的时间。\n磁盘带宽：传递的总字节数 ÷ 从服务请求开始到结束的时间\n\n\n\n时间=寻道时间+旋转延迟+扇区存取时间\n\n旋转延迟可以用半圈时间近似\n\n\n\n调度柱面\n\n### FCFS调度\n\n先到先服务算法\n\n平均寻道距离大\n\n+ 磁臂来回摆动\n+ 效率低\n\n会出现大摆动问题\n\n\n\n### SSTF调度\n\n最短寻道时间优先算法\n\n选择距离当前磁头位置判定的最短寻道的位置\n\n![image-20211213203748163](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211213203748163.png)\n\n\n\n可能会导致饥饿现象\n\n不能保证平均寻道时间最短\n\n\n\n### SCAN调度\n\n也被称为电梯调度\n\n磁臂从一端到另一端移动，处理经过的所有请求，随后改变移动方向，继续处理。\n\n+ 磁头当前位置\n+ 磁头当前移动方向\n\n避免饥饿现象\n\n另一端等待服务的请求可能很多，等待时间也可能很长\n\n\n\n### C-SCAN调度\n\n规定磁头单向移动。系统沿着一个方向（例如由内向外），依次对请求进行服务，到达最外端后，磁头立即返回到最内端，然后再由里向外依次对请求进行服务。\n\n\n\n公平\n\n\n\n### LOOK调度\n\nSCAN和C-SCAN是在整个磁盘范围内移动，但实际上只需要在有请求的最大区间范围内移动即可。\n\n在向一个方向移动时判断是否有请求，并根据请求的边界来放置磁头，这种形式的SCAN调度被称为LOOK调度（同样C-LOOK对应C-SCAN）\n\n\n\n### 选择调度算法\n\n+ SSTF最常见\n+ SCAN和C-SCAN对于负载沉重的系统执行更好\n+ 性能取决于请求的数量和类型\n  + 可能受到文件分配方法的影响\n\n\n\n对于FLASH等半导体存储器，不需要考虑寻到和旋转延迟，FCFS效率最高\n\n\n\n## 容错\n\nSFT-I低级磁盘容错技术\n\n+ 防止磁盘表面发生缺陷所引起的数据丢失；\n\nSFT-II中级磁盘容错技术 （RAID\n\n+ 防止磁盘驱动器和磁盘控制器故障所引起的系统不能正常工作；  \n\nSFT-III高级磁盘容错技术\n\n+ 机器或系统出现故障；\n\n\n\n\n\n### 低级磁盘容错技术\n\n容错：一般都是采用数据冗余。\n防止磁盘表面发生缺陷所引起的数据丢失；\n双备份目录表、双备份FCB表、双备份文件分配表等有关文件系统所需数据结构\n热修复重定向和写后读校验\n     ￭ 热修复重定向\n        磁盘格式化时系统一般都预留一部分扇区，用于存放当写入数据发现坏扇区时，用于替换坏扇区；（不属于任何分区, bad sector mapping）\n     ￭ 写后读校验\n      写入数据后立即读出进行比较，判断是否因磁盘表面损坏而导致的写入错误\n\n\n\n### 中级磁盘容错技术\n\n防止磁盘驱动器和磁盘控制器故障所引起的系统不能正常工作\n\nRAID技术---Redundant arrays of inexpensive disks (早期：廉价磁盘冗余阵列)\nRAID--- Redundant arrays of independent  disks (现在：独立磁盘冗余阵列)\n\n\n\n### 高级磁盘容错技术\n\n防止机器或系统出现故障，造成数据丢失\n\n系统热备份（机器热备份）\n\n\n\n### RAID结构\n\nRedundant Arrays of Inexpensive Disks \n\n+ 廉价磁盘冗余阵列\n\nRedundant Array of Independent Disks\n\n+ 独立磁盘冗余阵列\n\n多个磁盘驱动器通过冗余提供可靠性和性能。\n\nRAID分为六个不同的级别。\n\n\n\n每个分区上的文件系统称为一个卷（volume）\n卷集：多个磁盘分区组合成一个卷集，数据按分区顺序存取\n带区集：多个磁盘分区组合成一个卷集，多个卷交叉存取\n\n\n\nRAID方案通过存储冗余数据，提高存储系统的性能和可靠性。\n\n镜像或阴影保留每个磁盘的副本。\n\n块交错奇偶校验使用更少的冗余。\n\n\n\n并行交叉存取技术\n\n￭ 改善系统的可靠性－数据冗余及 校验+容错技术\n￭ 提高系统的性能－并行交叉存取（位级或块级分散）\n\n将数据按位级或者按块级分散写入到多个磁盘上，多个磁盘可以同时读写存取操作，实现数据的并行存取－提高了系统的性能；\n如果再结合数据冗余技术及校验技术，例如磁盘镜像、其它校验技术（CRC、Hamming等），还可以提高系统的可靠性；\n\n\n\n# I/O系统\n\nI/O管理是操作系统设计和操作的一个重要组成部分\n\n+ 计算机操作的重要方面\n+ I/O设备差异很大\n+ 控制它们的有很多方法\n+ 性能管理\n+ 新型设备层出不穷\n\n端口，总线，设备控制器连接到各种设备\n\n设备驱动程序封装设备细节\n\n+ 为I/O子系统提供统一的设备访问接口\n\n\n\n控制I/O设备需要多种方法，因为它们在功能和速度上差异很大。\n\n这些方法形成了内核的I/O子系统，它将内核的其余部分从I/O设备的复杂性中分离出来。\n\nI/ o设备技术呈现出两种相互矛盾的趋势\n\n+ 软硬件接口标准化;\n\n+ I/O设备更广泛;\n\n\n\n## 设备驱动\n\n为各种不同的I/O设备提供到I/O子系统的统一的设备访问接口\n\n系统为不同的设备设计了不同的设备驱动程序\n\n+ 对于不同硬件设备，为I/O子系统提供了统一的设备访问接口\n\n+ 根据I/O子系统的要求完成对硬件设备的具体访问\n+ 是硬件设备和系统之间的桥梁\n+ 简化了I/O子系统的设计\n\n类似于VFS中的虚拟文件接口层(VFS Interface)，为不同的文件系统提供了统一的文件系统调用接口\n\n例如系统调用提供了应用程序和操作系统之间的标准接口。\n\n\n\n统一访问接口的使用，方便了内核及应用程序的设计与编码，但也导致应用程序无法使用设备的具体特性，降低了设备的性能；\nUNIX为此提供了一个系统调用Ioctl()， 用户可以通过该系统调用直接通过设备驱动程序操纵I/O设备；\n\n\n\nI/O系统调用为应用程序提供了统一的调用接口，隐含了硬件设备的不同\n\n+ 由I/O子系统负责处理对不同设备的访问）\n\n设备驱动程序层为I/O子系统提供统一的访问接口，隐含了I/O控制器的不同\n\n使I/O子系统独立于硬件可以简化操作系统开发人员的工作。\n\n![image-20211214002540664](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211214002540664.png)\n\n\n\n## 阻塞和非阻塞I/O\n\n+ 阻塞：进程挂起（阻塞）直到I/O完成\n  + 易于使用和理解\n  + 不足以满足某些需求\n  + 进程必须等待某一个时间发生后才能继续执行；\n    如登录某个系统，系统需要等待用户输入用户名、密码等信息才能继续执行；\n\n+ 非阻塞：I/O尽可能返回可用\n  + 用户界面，数据复制（I/O缓冲）在两个设备之间\n  + 通过多线程实现\n  + 快速返回读取或写入的字节计数\n  + 非阻塞的read()立即返回可用的数据——请求的全部字节数、更少的字节数或根本没有字节数。\n+ 异步：进程在执行I/O时同步运行\n  + 另一种非阻塞I/O\n  + 一个异步读调用请求一个传输，传输将在未来的某个时间点完成执行\n  + IO完成时，IO子系统通知进程\n  + 难以使用\n\n\n\n非阻塞IO\n\n+ 当I/O可能来自多个来源，并且I/O到达的顺序没有预先确定时，非阻塞I/O是有用的;\n+ 当进程或线程同时处理多个I/O时，有些I/O可以不需要等待其完成即可继续执行\n+ 多线程环境下，有的线程采用blocking I/O，其它线程可继续执行，整体上看是非阻塞方式\n\n\n\nIO调度\n\n目的：提高系统效率、降低平均等待时间\n\n对于大部分的设备独占是设备，一般采用非优先级+先来先服务的调度算法\n\n\n\n缓冲\n\n缓冲区是在两个设备之间或一个设备和一个应用程序之间传输数据时存储数据的内存区域。\n\n缓冲-在设备之间传输时将数据存储在内存中\n\n为什么缓冲?\n\n+ 解决设备速度不匹配的问题\n+ 解决传输尺寸不匹配的问题\n+ 维护复制语义\n  + 应用程序缓冲区和内核缓冲区\n  + 当一个进程调用write()将buffer中的数据写入磁盘，在核心将buffer中的数据写磁盘的过程中，进程对buffer中的数据进行了修改。\n    根据“复制语义”的要求，本次写入磁盘的数据应该是在发出系统调用write()时buffer中的数据，其后的修改与本次write()调用无关。\n    如果采用互斥，对buffer加锁，会降低系统的性能。\n\n\n\n### Cache\n\n高速缓存：更高速的保存数据的存储器，访问cache比访问原始副本更快\n\n\n\n缓冲区和缓存的曲别\n\n+ 缓冲区保存一个数据项的唯一现有副本\n+ 缓存只是在更快的存储空间中保存的存储项的副本\n\n缓存和缓冲是截然不同的功能，但有时内存区域可以同时用于这两种目的。\n\n+ (Unix中的磁盘缓存)操作系统在主内存中使用缓冲区来保存磁盘数据。\n\n+ 这些缓冲区还被用作缓存，以提高由应用程序共享的文件或正在快速写入和重读的文件的文件I/O效率。\n\n目的：解决独占设备的并发访问问题，以提高设备的利用率\n\n\n\n## SPOOLing技术\n\nSimultaneous Peripheral Operations On Line\n外部设备联机并行操作\n\n又称为假脱机\n\n\n\n脱机输入是利用专门的外围控制机将低速I/O设备上的数据预先输入到磁盘上，然后主机从磁盘上直接读取输入数据；\n脱机输出是主机先将输出数据写入到磁盘上，然后利用专门的外围控制机将磁盘上的数据在低速I/O设备上输出；\n脱机I/O的采用提高了主机的输入输出速度；\n\n\n\nSPOOLing技术利用一台可共享的、高速大容量的块设备（通常是硬盘）来模拟独享设备的操作，使一台独享设备变为多台可并行使用的虚拟设备，即把独享设备变为逻辑上的共享设备；\n\n* 当用户提交一个文档给打印机时，系统为该打印请求在磁盘上创建了一个文件，然后将欲打印的文档内容写入该文件中；\n* 同时在系统的打印队列中建立一张打印表；\n  系统依次将打印对列中的打印请求提交打印机打印；\n* 可以理解为：基于SPOOLing技术，OS将物理打印机虚拟为磁盘上的一个文件；\n\n\n\n输入井与输出井\n      ￭ 在磁盘上开辟的两块存储空间；\n       ￭ 输入井模拟脱机输入时的磁盘，收容输入数据；\n       ￭ 输出井模拟脱机输出时的磁盘，收容输出数据；\n输入缓冲区与输出缓冲区（buffer）\n      ￭ 在内存中开辟的两个缓冲区\n        ￭ 输入缓冲区用于暂存输入设备输入的数据，然后传送到输入井；\n        ￭ 输出缓冲区用于暂存从输出井来的数据，然后传送给输出设备；\n输入进程与输出进程\n       ￭ 输入进程将用户要求的数据从输入设备通过输入缓冲区送到输入井；当CPU需要输入数据时，直接从输入井中读入；\n      ￭ 输出进程将用户需要输出的数据送入输出井；当输出设备空闲时，从输出井读出数据，通过输出缓冲区送入输出设备上；\n请求输出队列\n      ￭ 系统为每个请求输出的进程建立一张请求输出表；若干张请求输出表形成一个请求输出队列；当输出设备空闲时，按该队列的顺序依次输出； \n\n\n\n特点\n\n￭ 提高了I/O的速度；\n    ￭ 将独占设备改造成共享设备；\n    ￭ 实现了虚拟设备；\n\n\n\n### IO保护\n\n用户进程可能会意外或故意试图通过非法的I/O指令来中断正常的操作\n\n+ 所有I/O指令被定义为特权\n\n+ I/O必须通过系统调用来执行\n  + 内存映射和I/O端口内存位置也必须受到保护\n\n\n\n## 设备独立性\n\n也称为设备的无关性：应用程序独立于具体使用的物理设备\n逻辑设备与物理设备 \n\n+ 在应用程序中使用逻辑设备名称来请求使用某类设备；\n+ 进程在申请设备时，请求的是逻辑设备，操作系统会将系统中目前空闲可用的物理设备分配给该进程\n+ 操作系统需要借助逻辑设备表（LUT）完成从逻辑设备到物理设备的映射\n\n优点\n\n+ 设备分配时的灵活性；\n+ 易于实现I/O重定向(借助于LUT)；\n\n实现\n\n+ 在设备驱动程序之上设置一层“设备独立性软件”，以执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换（为此应设置一张逻辑设备表）并向用户层（或文件层）软件提供统一接口，从而实现设备的独立性。\n+ 操作系统把所有外部设备统一当作成文件来看待，任何用户都可以象使用文件一样操纵、使用这些设备，而不必知道它们的具体存在形式。\n\n\n\n# 保护\n\n保护 (Protection)\n\n+ 保护系统的资源不被合法用户滥用（误用）；\n+ 保护系统的资源被合法的用户正确使用，不被用户有意或恶意地违反相应的约束；\n+ 保证系统中活动的程序组件只能以规定的策略、一致的方式使用系统的资源；\n+ 保护的主要手段\n  + 授权；(如不同用户建立相应的登录帐户，并授予相应的权限)\n\n安全(Security)\n\n+ 防止非法用户侵入计算机系统而使信息泄密或造成系统的损坏\n+ 安全的主要手段\n  + 用户身份认证\n  + 入侵检测（IDS）\n  + 病毒检测；\n  + 数据加密等；\n\n\n\n## 全局保护\n\n操作系统由一组对象、硬件或软件组成\n\n每个对象都有一个唯一的名称，可以通过一组定义良好的操作来访问。\n\n保护问题,\n\n+ 确保正确访问每个对象，\n\n+ 只有那些被允许进程可以访问。\n\n\n\n保护指导原则-最低特权原则\n\n程序、用户和系统应该被给予足够的特权来执行它们的任务\n\n\n\n须知原则\n\n+ 一个流程应该能够访问它当前完成其任务所需的资源。\n\n+ 它在限制故障进程对系统造成的损害程度方面非常有用。\n\n保护域\n\n+ 指定进程可以访问的资源。\n\n+ 每个域定义了一组对象和可能在每个对象上调用的操作类型。\n\n+ 存取权\n  + 在对象上执行操作的能力;\n  + Access-right = <object-name, rights-set>\n  + 其中，rights-set是可以在该对象上执行的所有有效操作的子集。\n\n域是访问权限的集合，每个域都是有序的一对<object-name, rights-set>。\n\n对象可能是\n\n+ 硬件对象和软件对象\n\n![image-20211214154907544](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211214154907544.png)\n\n\n\n每个用户可以是一个域\n\n+ 可以访问的对象集取决于用户的身份。(对象,例如。文件。设备等)\n\n+ 域切换发生在用户更改时——通常是在一个用户注销而另一个用户登录时。\n\n每个进程可以是一个域\n\n+ 可以访问的对象集取决于进程的标识。\n\n+ 当一个进程向另一个进程发送消息，然后等待响应时，就会发生域切换。\n\n每个过程可以是一个域\n\n+ 一个过程可以被评价为一种方法\n\n+ 可以访问的对象集对应于过程中定义的局部变量。\n\n+ 在进行过程调用时发生域切换。\n\n\n\n## 访问矩阵\n\n将保护视为一个矩阵(访问矩阵)\n\n+ 行代表域\n\n+ 列代表对象\n\n入口访问(i, j)是在Domain Di中执行的进程可以对Object Oj调用的一组操作\n\n![image-20211214160328490](E:\\OneDrive - mail.sdu.edu.cn\\md\\image\\image-20211214160328490.png)\n\n实现\n\n全局表\n\n每列=一个对象的访问控制列表(ACL,AL)\n\n每行=能力列表(就像一个键)\n\n\n\n全局表\n\n+ 由一组有序三元组<domain, object, right set>组成;\n\n+ 每当对对象Oj执行操作M时，就会在全局表中搜索具有M$\\in$Rk的三元组<Di,Oj,Rk>\n  + 如果找到这个三元组，则允许继续操作;\n  + 否则，将引发一个异常条件。\n\n缺点\n\n+ 表通常较长，因此不能保存在主存中，需要额外的I/O;\n\n+ 很难利用对象或域的特殊分组。\n\n+ (例如，如果每个人都可以读取一个特定的对象，那么它必须在每个域中有一个单独的条目)\n\n\n\n## 访问控制\n\n保护可以应用于非文件资源\n\nSolaris 10提供了基于角色的访问控制(RBAC)来实现最小权限\n\n+ 特权是执行系统调用或在系统调用中使用选项的权利\n\n+ 可以分配给进程\n\n+ 用户分配角色，授权访问特权和程序\n","categories":["笔记"]},{"title":"Hello World","url":"/2022/03/07/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","categories":["hello world"]}]