<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="操作系统课设Nachos系统总结中断控制器1、几个供外部程序使用的调用接口；  （1）Interrupt::SetLevel(IntOff)：用于关中断；  （2）Interrupt::SetLevel(IntOn)：用于开中断，并返回原中断的开关状态；外部程 序可通过调用这两个接口实现一些原子操作；  （3）Interrupt::Halt()：实现停机操作；  （4）Interrupt::Idl">
<meta property="og:type" content="article">
<meta property="og:title" content="Const_Point">
<meta property="og:url" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Const_Point">
<meta property="og:description" content="操作系统课设Nachos系统总结中断控制器1、几个供外部程序使用的调用接口；  （1）Interrupt::SetLevel(IntOff)：用于关中断；  （2）Interrupt::SetLevel(IntOn)：用于开中断，并返回原中断的开关状态；外部程 序可通过调用这两个接口实现一些原子操作；  （3）Interrupt::Halt()：实现停机操作；  （4）Interrupt::Idl">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220312173117116.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220312220345657.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220313005518934.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314004009009.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314005505549.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314010620035.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314010126127.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314011027327.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314010728426.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314194850745.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220315235407884.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506151516132.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506152111304.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506152302399.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506143602886.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506144109056.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506143826658.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506144350160.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506144414857.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506144437559.png">
<meta property="og:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506144539952.png">
<meta property="article:published_time" content="2022-04-24T04:56:10.086Z">
<meta property="article:modified_time" content="2022-05-10T01:29:20.285Z">
<meta property="article:author" content="一枚常指针">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220312173117116.png">

<link rel="canonical" href="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | Const_Point</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Const_Point</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile_photo.jpg">
      <meta itemprop="name" content="一枚常指针">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Const_Point">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-24 12:56:10" itemprop="dateCreated datePublished" datetime="2022-04-24T12:56:10+08:00">2022-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-10 09:29:20" itemprop="dateModified" datetime="2022-05-10T09:29:20+08:00">2022-05-10</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="操作系统课设"><a href="#操作系统课设" class="headerlink" title="操作系统课设"></a>操作系统课设</h1><h1 id="Nachos系统总结"><a href="#Nachos系统总结" class="headerlink" title="Nachos系统总结"></a>Nachos系统总结</h1><h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><p>1、几个供外部程序使用的调用接口； </p>
<p>（1）Interrupt::SetLevel(IntOff)：用于关中断； </p>
<p>（2）Interrupt::SetLevel(IntOn)：用于开中断，并返回原中断的开关状态；外部程 序可通过调用这两个接口实现一些原子操作； </p>
<p>（3）Interrupt::Halt()：实现停机操作； </p>
<p>（4）Interrupt::Idle()：相当于一般操作系统中的 idle 进程；</p>
<h3 id="中断响应时机"><a href="#中断响应时机" class="headerlink" title="中断响应时机"></a>中断响应时机</h3><p>（1）中断状态从关到开； </p>
<p>（2）Nachos 的 CPU 执行完一条应用程序指令； </p>
<p>因为只有上述两种情况发生时，系统时钟才增量（Interrupt::OneTick()，对于第一 种情况，增 10 个 ticks，第二种情况增 1 个 ticks），这时 Nachos 中断控制器才检查是 否有中断到期，如果有，则响应之；</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Nachos的进程在生命其中包括5个状态</p>
<p>JUST_CREADT：刚new</p>
<p>RUNNING：</p>
<p>READY：</p>
<p>BLOCKED：</p>
<p>JUST_CREAT-&gt;READY</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReadyToRun()</span><br></pre></td></tr></table></figure>

<p>BLOCKED-&gt;READY</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore::V()</span><br></pre></td></tr></table></figure>

<p>RUNNING-&gt;READY</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread::Yield()</span><br></pre></td></tr></table></figure>

<p>RUNNING-&gt;BOLOCKED</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread::Sleep()</span><br></pre></td></tr></table></figure>

<h1 id="实验一-Nachos系统的安装与调试"><a href="#实验一-Nachos系统的安装与调试" class="headerlink" title="实验一 Nachos系统的安装与调试"></a>实验一 Nachos系统的安装与调试</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>（1）安装编译 Nachos 系统，理解 Nachos 系统的组织结构与安装过程； </p>
<p>（2）安装测试 gcc MIPS 交叉编译器； </p>
<p>（3）掌握利用 Linux 调试工具 GDB 调试跟踪 Nachos 的执行过程； </p>
<p>（4）安装成功后，根据 Nachos 的输出结果，分析分析跟踪 Nachos 的 C++程序及汇编代码，理解 Nachos 中线程的创建方法以及上下文切换的过程。 </p>
<p>（5）阅读 Nachos 的相关源代码，理解 Nachos 内核的启动与停机过程。 </p>
<p>（6）理解 Nachos 的运行参数的含义与使用。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>（1） 安装 Linux 操作系统； </p>
<p>（2） 安装 Nachos 及 gcc mips 交叉编译程序； </p>
<p>（3） 编译测试 Nacho，并理解 Nachos 的运行参数的含义与使用； </p>
<p>（4） 运行 Nachos，根据 Nachos 的输出，理解 Nachos 中第一个线程是如何产生的。理解并掌握 Nachos 中其它内核线程的创建方法；理解 idle 线程的创建与作用。 进而理解一个实际的操作系统（如 Windows、Linux 等）的第一个进程是 如何产生的，以及 ideler 进程的创建与使用。 </p>
<p>（5） 理解 Nachos 中的上下文切换过程； </p>
<p>（6） 熟悉 gdb 调试工具；</p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="安装nachos"><a href="#安装nachos" class="headerlink" title="安装nachos"></a>安装nachos</h3><p>根据指导书操作</p>
<p>最终结果</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220312173117116.png" alt="image-20220312173117116"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>（1）在你所生成的 Nachos 系统中，下述函数的地址是多少？并说明找到这些函<br>数地址的过程及方法。<br>i. InterruptEnable()<br>ii. SimpleThread()<br>iii. ThreadFinish()<br>iv. ThreadRoot()</p>
<p>（2）下述线程对象的地址是多少？并说明找到这些对象地址的过程及方法。<br>i. the main thread of the Nachos<br>ii. the forked thread created by the main thread</p>
<p>（3）当主线程第一次运行 SWITCH()函数，执行到函数 SWITCH()的最后一条指<br>令 ret 时，CPU 返回的地址是多少？ 该地址对应程序的什么位置？</p>
<p>（4）当调用 Fork()新建的线程首次运行 SWITCH()函数时，当执行到函数<br>SWITCH()的最后一条指令 ret 时，CPU 返回的地址是多少？ 该地址对应程序的什么<br>位置？</p>
<h3 id="查询函数地址"><a href="#查询函数地址" class="headerlink" title="查询函数地址"></a>查询函数地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b InterruptEnable</span><br><span class="line">Breakpoint 1 at 0x3027: file thread.cc, line 242.</span><br><span class="line">(gdb) b SimpleThread</span><br><span class="line">Breakpoint 2 at 0x3275: file threadtest.cc, line 26.</span><br><span class="line">(gdb) b ThreadFinish</span><br><span class="line">Breakpoint 3 at 0x2ffc: file thread.cc, line 241.</span><br><span class="line">(gdb) b ThreadRoot</span><br><span class="line">Breakpoint 4 at 0x4e7c</span><br></pre></td></tr></table></figure>

<h3 id="查询对象地址"><a href="#查询对象地址" class="headerlink" title="查询对象地址"></a>查询对象地址</h3><p>主线程对象的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p currentThread</span><br><span class="line">$1 = (Thread *) 0x56563ca0</span><br></pre></td></tr></table></figure>

<p>主线程 fork的线程地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">42    ThreadTest()</span><br><span class="line">43    &#123;</span><br><span class="line">44        DEBUG(&#x27;t&#x27;, &quot;Entering SimpleTest&quot;);</span><br><span class="line">45    </span><br><span class="line">46        Thread *t = new Thread(&quot;forked thread&quot;);</span><br><span class="line">47    </span><br><span class="line">(gdb) l</span><br><span class="line">48        t-&gt;Fork(SimpleThread, 1);</span><br><span class="line">49        SimpleThread(0);</span><br><span class="line">50    &#125;</span><br><span class="line">51    </span><br><span class="line">(gdb) b 48</span><br><span class="line">Breakpoint 9 at 0x56558327: file threadtest.cc, line 48.</span><br><span class="line">(gdb) print *t</span><br><span class="line">$2 = &#123;stackTop = 0x8e30, machineState = &#123;0, 0, -137625168, -135911936, </span><br><span class="line">    -137581328, -137541952, -137580576, -137789584, -137623792, -137623952, </span><br><span class="line">    -138281536, -135921024, -137160944, -135911792, -138496512, -138170064, </span><br><span class="line">    -138392816, -137958928&#125;, stack = 0xf7e60250 &lt;operator delete(void*)&gt;, </span><br><span class="line">  status = 4156468720, </span><br><span class="line">  name = 0xf7c01220 &lt;ssignal&gt; &quot;\363\017\036\373S\213D$\b\350K&quot;&#125;</span><br><span class="line">(gdb) p t</span><br><span class="line">$3 = (Thread *) 0x5655df40</span><br></pre></td></tr></table></figure>

<h3 id="查询SWITCH函数返回地址"><a href="#查询SWITCH函数返回地址" class="headerlink" title="查询SWITCH函数返回地址"></a>查询SWITCH函数返回地址</h3><p>SWITCH汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass SWITCH</span><br><span class="line">Dump of assembler code for function SWITCH:</span><br><span class="line">=&gt; 0x56559e86 &lt;+0&gt;:    mov    %eax,0x5655e054</span><br><span class="line">   0x56559e8b &lt;+5&gt;:    mov    0x4(%esp),%eax</span><br><span class="line">   0x56559e8f &lt;+9&gt;:    mov    %ebx,0x8(%eax)</span><br><span class="line">   0x56559e92 &lt;+12&gt;:    mov    %ecx,0xc(%eax)</span><br><span class="line">   0x56559e95 &lt;+15&gt;:    mov    %edx,0x10(%eax)</span><br><span class="line">   0x56559e98 &lt;+18&gt;:    mov    %esi,0x18(%eax)</span><br><span class="line">   0x56559e9b &lt;+21&gt;:    mov    %edi,0x1c(%eax)</span><br><span class="line">   0x56559e9e &lt;+24&gt;:    mov    %ebp,0x14(%eax)</span><br><span class="line">   0x56559ea1 &lt;+27&gt;:    mov    %esp,(%eax)</span><br><span class="line">   0x56559ea3 &lt;+29&gt;:    mov    0x5655e054,%ebx</span><br><span class="line">   0x56559ea9 &lt;+35&gt;:    mov    %ebx,0x4(%eax)</span><br><span class="line">   0x56559eac &lt;+38&gt;:    mov    (%esp),%ebx</span><br><span class="line">   0x56559eaf &lt;+41&gt;:    mov    %ebx,0x20(%eax)</span><br><span class="line">   0x56559eb2 &lt;+44&gt;:    mov    0x8(%esp),%eax</span><br><span class="line">   0x56559eb6 &lt;+48&gt;:    mov    0x4(%eax),%ebx</span><br><span class="line">   0x56559eb9 &lt;+51&gt;:    mov    %ebx,0x5655e054</span><br><span class="line">   0x56559ebf &lt;+57&gt;:    mov    0x8(%eax),%ebx</span><br><span class="line">   0x56559ec2 &lt;+60&gt;:    mov    0xc(%eax),%ecx</span><br><span class="line">   0x56559ec5 &lt;+63&gt;:    mov    0x10(%eax),%edx</span><br><span class="line">   0x56559ec8 &lt;+66&gt;:    mov    0x18(%eax),%esi</span><br><span class="line">   0x56559ecb &lt;+69&gt;:    mov    0x1c(%eax),%edi</span><br><span class="line">   0x56559ece &lt;+72&gt;:    mov    0x14(%eax),%ebp</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--ret</span><br><span class="line">   0x56559ed1 &lt;+75&gt;:    mov    (%eax),%esp</span><br><span class="line">   0x56559ed3 &lt;+77&gt;:    mov    0x20(%eax),%eax</span><br><span class="line">   0x56559ed6 &lt;+80&gt;:    mov    %eax,(%esp)</span><br><span class="line">   0x56559ed9 &lt;+83&gt;:    mov    0x5655e054,%eax</span><br><span class="line">   0x56559ede &lt;+88&gt;:    ret    </span><br><span class="line">   0x56559edf &lt;+89&gt;:    nop</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>eax中存储着新旧线程地址</p>
<p>在&lt;5&gt;之后查看寄存器内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">0x56559e8f in SWITCH ()</span><br><span class="line">(gdb) info r</span><br><span class="line">eax            0x56563ca0          1448492192</span><br><span class="line">ecx            0xc                 12</span><br><span class="line">edx            0x9                 9</span><br><span class="line">ebx            0x5655df40          1448468288</span><br><span class="line">esp            0xffffce6c          0xffffce6c</span><br><span class="line">ebp            0xffffce98          0xffffce98</span><br><span class="line">esi            0x5655a2e3          1448452835</span><br><span class="line">edi            0x56563d00          1448492288</span><br><span class="line">eip            0x56559e8f          0x56559e8f &lt;SWITCH+9&gt;</span><br><span class="line">eflags         0x296               [ PF AF SF IF ]</span><br><span class="line">cs             0x23                35</span><br><span class="line">ss             0x2b                43</span><br><span class="line">ds             0x2b                43</span><br><span class="line">es             0x2b                43</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x63                99</span><br></pre></td></tr></table></figure>

<p>在&lt;44&gt;之后查看寄存器信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">0x56559eb6 in SWITCH ()</span><br><span class="line">(gdb) info r</span><br><span class="line">eax            0x56563d00          1448492288</span><br><span class="line">ecx            0xc                 12</span><br><span class="line">edx            0x9                 9</span><br><span class="line">ebx            0x56556a26          1448438310</span><br><span class="line">esp            0xffffce6c          0xffffce6c</span><br><span class="line">ebp            0xffffce98          0xffffce98</span><br><span class="line">esi            0x5655a2e3          1448452835</span><br><span class="line">edi            0x56563d00          1448492288</span><br><span class="line">eip            0x56559eb6          0x56559eb6 &lt;SWITCH+48&gt;</span><br><span class="line">eflags         0x296               [ PF AF SF IF ]</span><br><span class="line">cs             0x23                35</span><br><span class="line">ss             0x2b                43</span><br><span class="line">ds             0x2b                43</span><br><span class="line">es             0x2b                43</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x63                99</span><br></pre></td></tr></table></figure>

<p>&lt;77&gt;行后查看寄存器信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">0x56559ed6 in SWITCH ()</span><br><span class="line">(gdb) info r</span><br><span class="line">eax            0x56559e78          1448451704</span><br><span class="line">ecx            0x56558027          1448443943</span><br><span class="line">edx            0x1                 1</span><br><span class="line">ebx            0x0                 0</span><br><span class="line">esp            0x56568d50          0x56568d50</span><br><span class="line">ebp            0x0                 0x0</span><br><span class="line">esi            0x56558275          1448444533</span><br><span class="line">edi            0x56557ffc          1448443900</span><br><span class="line">eip            0x56559ed6          0x56559ed6 &lt;SWITCH+80&gt;</span><br><span class="line">eflags         0x296               [ PF AF SF IF ]</span><br><span class="line">cs             0x23                35</span><br><span class="line">ss             0x2b                43</span><br><span class="line">ds             0x2b                43</span><br><span class="line">es             0x2b                43</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x63                99</span><br></pre></td></tr></table></figure>

<p>在&lt;88&gt;后查看下一条指令执行的地址，与&lt;77&gt;中eax存储的地址相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">0x56559e78 in ThreadRoot ()</span><br></pre></td></tr></table></figure>

<p>该地址为函数ThreadRoot的第一条汇编指令地址</p>
<h3 id="Fork后运行SWICH的返回地址"><a href="#Fork后运行SWICH的返回地址" class="headerlink" title="Fork后运行SWICH的返回地址"></a>Fork后运行SWICH的返回地址</h3><p>输入c后继续运行，查看第二次switch函数的返回地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0x56559ede in SWITCH ()</span><br><span class="line">(gdb) ni</span><br><span class="line">0x56556a26 in Scheduler::Run (this=0x56563c80, nextThread=0x56563d00)</span><br><span class="line">    at scheduler.cc:116</span><br><span class="line">116        SWITCH(oldThread, nextThread);</span><br><span class="line">(gdb) l</span><br><span class="line">111        // This is a machine-dependent assembly language routine defined </span><br><span class="line">112        // in switch.s.  You may have to think</span><br><span class="line">113        // a bit to figure out what happens after this, both from the point</span><br><span class="line">114        // of view of the thread and from the perspective of the &quot;outside world&quot;.</span><br><span class="line">115    </span><br><span class="line">116        SWITCH(oldThread, nextThread);</span><br><span class="line">117        </span><br><span class="line">118        DEBUG(&#x27;t&#x27;, &quot;Now in thread \&quot;%s\&quot;\n&quot;, currentThread-&gt;getName());</span><br><span class="line">119    </span><br><span class="line">120        // If the old thread gave up the processor because it was finishing,</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p>查看run的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">disass Run</span><br><span class="line">Dump of assembler code for function Scheduler::Run(Thread*):</span><br><span class="line">   0x56556996 &lt;+0&gt;:    endbr32 </span><br><span class="line">   0x5655699a &lt;+4&gt;:    push   %ebp</span><br><span class="line">   0x5655699b &lt;+5&gt;:    mov    %esp,%ebp</span><br><span class="line">   0x5655699d &lt;+7&gt;:    push   %esi</span><br><span class="line">   0x5655699e &lt;+8&gt;:    push   %ebx</span><br><span class="line">   0x5655699f &lt;+9&gt;:    sub    $0x10,%esp</span><br><span class="line">   0x565569a2 &lt;+12&gt;:    call   0x565562f0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x565569a7 &lt;+17&gt;:    add    $0x7599,%ebx</span><br><span class="line">   0x565569ad &lt;+23&gt;:    lea    0xf4(%ebx),%eax</span><br><span class="line">   0x565569b3 &lt;+29&gt;:    mov    (%eax),%eax</span><br><span class="line">   0x565569b5 &lt;+31&gt;:    mov    %eax,-0xc(%ebp)</span><br><span class="line">   0x565569b8 &lt;+34&gt;:    sub    $0xc,%esp</span><br><span class="line">   0x565569bb &lt;+37&gt;:    pushl  -0xc(%ebp)</span><br><span class="line">   0x565569be &lt;+40&gt;:    call   0x56557c8c &lt;Thread::CheckOverflow()&gt;</span><br><span class="line">   0x565569c3 &lt;+45&gt;:    add    $0x10,%esp</span><br><span class="line">   0x565569c6 &lt;+48&gt;:    lea    0xf4(%ebx),%eax</span><br><span class="line">   0x565569cc &lt;+54&gt;:    mov    0xc(%ebp),%edx</span><br><span class="line">   0x565569cf &lt;+57&gt;:    mov    %edx,(%eax)</span><br><span class="line">   0x565569d1 &lt;+59&gt;:    lea    0xf4(%ebx),%eax</span><br><span class="line">   0x565569d7 &lt;+65&gt;:    mov    (%eax),%eax</span><br><span class="line">   0x565569d9 &lt;+67&gt;:    sub    $0x8,%esp</span><br><span class="line">   0x565569dc &lt;+70&gt;:    push   $0x1</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--ret</span><br><span class="line">   0x565569de &lt;+72&gt;:    push   %eax</span><br><span class="line">   0x565569df &lt;+73&gt;:    call   0x56556ade &lt;Thread::setStatus(ThreadStatus)&gt;</span><br><span class="line">   0x565569e4 &lt;+78&gt;:    add    $0x10,%esp</span><br><span class="line">   0x565569e7 &lt;+81&gt;:    sub    $0xc,%esp</span><br><span class="line">   0x565569ea &lt;+84&gt;:    pushl  0xc(%ebp)</span><br><span class="line">   0x565569ed &lt;+87&gt;:    call   0x56556afc &lt;Thread::getName()&gt;</span><br><span class="line">   0x565569f2 &lt;+92&gt;:    add    $0x10,%esp</span><br><span class="line">   0x565569f5 &lt;+95&gt;:    mov    %eax,%esi</span><br><span class="line">   0x565569f7 &lt;+97&gt;:    sub    $0xc,%esp</span><br><span class="line">   0x565569fa &lt;+100&gt;:    pushl  -0xc(%ebp)</span><br><span class="line">   0x565569fd &lt;+103&gt;:    call   0x56556afc &lt;Thread::getName()&gt;</span><br><span class="line">   0x56556a02 &lt;+108&gt;:    add    $0x10,%esp</span><br><span class="line">   0x56556a05 &lt;+111&gt;:    push   %esi</span><br><span class="line">   0x56556a06 &lt;+112&gt;:    push   %eax</span><br><span class="line">   0x56556a07 &lt;+113&gt;:    lea    -0x3e7c(%ebx),%eax</span><br><span class="line">   0x56556a0d &lt;+119&gt;:    push   %eax</span><br><span class="line">   0x56556a0e &lt;+120&gt;:    push   $0x74</span><br><span class="line">   0x56556a10 &lt;+122&gt;:    call   0x565581e8 &lt;DEBUG(char, char const*, ...)&gt;</span><br><span class="line">   0x56556a15 &lt;+127&gt;:    add    $0x10,%esp</span><br><span class="line">   0x56556a18 &lt;+130&gt;:    sub    $0x8,%esp</span><br><span class="line">   0x56556a1b &lt;+133&gt;:    pushl  0xc(%ebp)</span><br><span class="line">   0x56556a1e &lt;+136&gt;:    pushl  -0xc(%ebp)</span><br><span class="line">   0x56556a21 &lt;+139&gt;:    call   0x56559e86 &lt;SWITCH&gt;</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--ret</span><br><span class="line">=&gt; 0x56556a26 &lt;+144&gt;:    add    $0x10,%esp</span><br><span class="line">   0x56556a29 &lt;+147&gt;:    lea    0xf4(%ebx),%eax</span><br><span class="line">   0x56556a2f &lt;+153&gt;:    mov    (%eax),%eax</span><br><span class="line">   0x56556a31 &lt;+155&gt;:    sub    $0xc,%esp</span><br><span class="line">   0x56556a34 &lt;+158&gt;:    push   %eax</span><br><span class="line">   0x56556a35 &lt;+159&gt;:    call   0x56556afc &lt;Thread::getName()&gt;</span><br><span class="line">   0x56556a3a &lt;+164&gt;:    add    $0x10,%esp</span><br><span class="line">   0x56556a3d &lt;+167&gt;:    sub    $0x4,%esp</span><br><span class="line">   0x56556a40 &lt;+170&gt;:    push   %eax</span><br><span class="line">   0x56556a41 &lt;+171&gt;:    lea    -0x3e51(%ebx),%eax</span><br><span class="line">   0x56556a47 &lt;+177&gt;:    push   %eax</span><br><span class="line">   0x56556a48 &lt;+178&gt;:    push   $0x74</span><br><span class="line">   0x56556a4a &lt;+180&gt;:    call   0x565581e8 &lt;DEBUG(char, char const*, ...)&gt;</span><br><span class="line">   0x56556a4f &lt;+185&gt;:    add    $0x10,%esp</span><br><span class="line">   0x56556a52 &lt;+188&gt;:    lea    0xf8(%ebx),%eax</span><br><span class="line">   0x56556a58 &lt;+194&gt;:    mov    (%eax),%eax</span><br><span class="line">   0x56556a5a &lt;+196&gt;:    test   %eax,%eax</span><br><span class="line">   0x56556a5c &lt;+198&gt;:    je     0x56556a90 &lt;Scheduler::Run(Thread*)+250&gt;</span><br><span class="line">   0x56556a5e &lt;+200&gt;:    lea    0xf8(%ebx),%eax</span><br><span class="line">   0x56556a64 &lt;+206&gt;:    mov    (%eax),%esi</span><br><span class="line">   0x56556a66 &lt;+208&gt;:    test   %esi,%esi</span><br><span class="line">   0x56556a68 &lt;+210&gt;:    je     0x56556a84 &lt;Scheduler::Run(Thread*)+238&gt;</span><br><span class="line">   0x56556a6a &lt;+212&gt;:    sub    $0xc,%esp</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--</span><br></pre></td></tr></table></figure>

<p>发现返回地址对应于run中调用函数SWITCH后紧跟着的一条指令</p>
<p>重复上述过程发现，SWITCH返回地址均与第二次运行后结果相同</p>
<p>通过阅读源码可知</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleThread(_int which)</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line"></span><br><span class="line">    for (num = 0; num &lt; 5; num++) &#123;</span><br><span class="line">    printf(&quot;*** thread %d looped %d times\n&quot;, (int) which, num);</span><br><span class="line">        currentThread-&gt;Yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SWITCH函数用于交替执行这个函数</p>
<p>子线程第一次返回时，返回进入函数头部</p>
<p>之后交替执行</p>
<h1 id="实验二-Nachos的MAKEFILES"><a href="#实验二-Nachos的MAKEFILES" class="headerlink" title="实验二 Nachos的MAKEFILES"></a>实验二 Nachos的MAKEFILES</h1><p>目的与任务<br>该实验在目录 lab2 中完成。<br>（1）熟悉 Nachos 的 makefiles 的结构；<br>（2）熟悉如何在几个 lab 文件目录中构造相应的 Nachos 系统；</p>
<h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><ol>
<li><p>code&#x2F;下子目录中的Makefile文件主要内容</p>
<ul>
<li><p>include Makefile.local</p>
</li>
<li><p>include ..&#x2F;Makefile.common</p>
<p>将父目录下的 Makefile.common 包含了进来</p>
</li>
</ul>
</li>
<li><p>makefile.local文件</p>
<ul>
<li>主要作用：对一些编译、链接及运行时所使用的宏进行定义</li>
<li>CCFILES：指明在该目录下生成Nachos时所涉及到的C++源文件</li>
<li>INCPATH：指明所涉及的C++源程序中的头文件（.h文件）所在路径</li>
<li>DEFINES：传递g++的一些标号或宏</li>
</ul>
</li>
<li><p>Makefile.dep文件</p>
<ul>
<li>获取操作平台</li>
<li>给出gcc mips交叉编译器所在的路径及前缀</li>
<li>arch文件下三个文件夹分别存放<ul>
<li>可执行文件（nachos）</li>
<li>依赖文件（dependence files，如xxxx.d）</li>
<li>目标文件（object files，如xxx.o）</li>
</ul>
</li>
<li>code&#x2F;子目录下生成可执行文件的链接文件</li>
</ul>
</li>
<li><p>Makfile.common文件，定义了编译链接生成一个完整的Nachos可执行文件所需要的所有规则</p>
</li>
</ol>
<h3 id="在其他目录中修改Nachos代码并生成系统"><a href="#在其他目录中修改Nachos代码并生成系统" class="headerlink" title="在其他目录中修改Nachos代码并生成系统"></a>在其他目录中修改Nachos代码并生成系统</h3><p>lab1和lab2在code&#x2F;thread下完成</p>
<p>lab3在code&#x2F;monitor下完成</p>
<p>lab4和lab5在code&#x2F;filesys下完成</p>
<p>lab6、lab7和lab8在code&#x2F;userprog下完成</p>
<h3 id="修改INPATH"><a href="#修改INPATH" class="headerlink" title="修改INPATH"></a>修改INPATH</h3><p>如若不修改INPATH</p>
<p>若修改xxxx.h文件，重新编译后只有同文件夹下的xxxx.cc文件会关联</p>
<p>其他文件中的头文件若包含xxxx.h文件，会优先寻找本文件夹下的xxxx.h文件</p>
<p>然后从 -I..&#x2F;threads -I..&#x2F;machine  两个文件夹下寻找</p>
<p>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCPATH += -I../&lt;文件夹名&gt; -I../threads -I../machine</span><br></pre></td></tr></table></figure>

<p>找不到文件就从该路径左至右寻找。</p>
<p>但该方法仍会导致只有目录lab2下的scheduler.cc使用lab2下的scheduler.h，其他目录中的.cc源文件仍然使用目录..&#x2F;threads下的scheduler.h</p>
<h3 id="寻找包含修改的-h文件的最小文件集"><a href="#寻找包含修改的-h文件的最小文件集" class="headerlink" title="寻找包含修改的.h文件的最小文件集"></a>寻找包含修改的.h文件的最小文件集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep scheduler.h *</span><br><span class="line">Grep选项：</span><br><span class="line">* : 表示当前目录所有文件，也可以是某个文件名</span><br><span class="line">-r 是递归查找</span><br><span class="line">-n 是显示行号</span><br><span class="line">-R 查找所有文件包含子目录</span><br><span class="line">-i 忽略大小写</span><br></pre></td></tr></table></figure>

<p>可以检查哪些文件中包含字符串</p>
<p>查找出包含修改后的.h文件的所有文件放入新建的文件夹中</p>
<p>使用touch命令更新所修改的的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1．命令格式：</span><br><span class="line">touch [选项]... 文件...</span><br><span class="line">2．命令参数：</span><br><span class="line">-a   或--time=atime或--time=access或--time=use 　只更改存取时间。</span><br><span class="line">-c   或--no-create 　不建立任何文档。</span><br><span class="line">-d 　使用指定的日期时间，而非现在的时间。</span><br><span class="line">-f 　此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。</span><br><span class="line">-m   或--time=mtime或--time=modify 　只更改变动时间。</span><br><span class="line">-r 　把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。</span><br><span class="line">-t 　使用指定的日期时间，而非现在的时间。</span><br><span class="line">3．命令功能：</span><br><span class="line">touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。 </span><br></pre></td></tr></table></figure>

<p>make</p>
<p>再touch未修改的其他文件目录下的原文件</p>
<p>重新make，观察nachos是否会被更新</p>
<h1 id="实验三-利用信号量实现线程同步"><a href="#实验三-利用信号量实现线程同步" class="headerlink" title="实验三 利用信号量实现线程同步"></a>实验三 利用信号量实现线程同步</h1><h2 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h2><p>（1）进一步理解 Nachos 中如何创建线程； </p>
<p>（2）理解 Nachos 中信号量与 P、V 操作是如何实现的 </p>
<p>（3）如何创建与使用 Nachos 的信号量 </p>
<p>（4）理解 Nachos 中是如何利用信号量实现 producer&#x2F;consumer problem；</p>
<p>（5）理解 Nachos 中如何测试与调试程序； </p>
<p>（6）理解 Nachos 中轮转法（RR）线程调度的实现；</p>
<h2 id="设计步骤与要求"><a href="#设计步骤与要求" class="headerlink" title="设计步骤与要求"></a>设计步骤与要求</h2><ol>
<li><p>在 code&#x2F;lab3 目录中， </p>
<ul>
<li>详细阅读并深刻理解 ring.h 及 ring.cc 中的所有代码； </li>
<li>阅读并理解 main.cc 的功能；</li>
<li>详细阅读并深刻理解 prodcons++.cc 的程序结构，在 prodcons++.cc 中添加或 修改相应的代码，满足设计要求。（可依据其中的注释添加相应的代码） </li>
<li>利用 make 编译生成新的 Nachos，并测试其功能是否满足设计要求；</li>
</ul>
</li>
<li><p>分析..&#x2F;threads&#x2F;threadtest.cc，理解利用 Thread::Fork()创建线程的方法； </p>
<p>分析 Thread::Fork() ，理解内核创建线程的过程</p>
<p>分析..&#x2F;threads&#x2F;synch.cc，理解 Nachos 中信号量是如何实现的； </p>
<p>分析..&#x2F;monitor&#x2F;prodcons++.cc，理解信号量的创建与使用方法； </p>
<p>分析 Thread::Fork() , Thread::Yiled(), Thread::Sleep(), Thread::Finish() ,, Scheduler::  Scheduler::ReadyToRun(), Scheduler::FindNextToRun(), Scheduler::Run()等相关函数，理解线程调度及上下文切换的工作过程；</p>
</li>
<li><p>在理解上述 Nachos 工作机理的基础上，补充或修改目录 lab3 中 prodcons++.cc 中的代码，利用 Nachos 实现的线程与信号量机制完善一个 producer&#x2F;consumer problem 测试程序。 </p>
</li>
<li><p>根据生产者&#x2F;消费者问题的功能定义，你的实现应该满足如下条件: </p>
<ul>
<li>生产者线程所产生的所有的消息，都应该被消费者接收并保存到输出文件 中（tem_0，temp_1，…） </li>
<li>每个消息只能被接收一次且在文件保存一次 </li>
<li>来自于同一个生产者的消息，以及被同一个消费者接收到的消息，在文件保存的顺序应该按其序号升序排列；</li>
</ul>
</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define BUFF_SIZE 3  // the size of the round buffer</span><br><span class="line">#define N_PROD    2  // the number of producers </span><br><span class="line">#define N_CONS    2  // the number of consumers</span><br><span class="line">#define N_MESSG   4  // the number of messages produced by each producer</span><br></pre></td></tr></table></figure>

<p>阅读代码可得</p>
<ul>
<li>缓冲区大小为：3</li>
<li>生产者个数：2</li>
<li>消费者个数：2</li>
<li>每个生产者发送信息数：4</li>
</ul>
<h3 id="理解信号量的实现"><a href="#理解信号量的实现" class="headerlink" title="理解信号量的实现"></a>理解信号量的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Semaphore &#123;</span><br><span class="line">  public:</span><br><span class="line">    Semaphore(char* debugName, int initialValue);    // 设置初值</span><br><span class="line">    ~Semaphore();                       // de-allocate semaphore</span><br><span class="line">    char* getName() &#123; return name;&#125;            // debugging assist</span><br><span class="line"></span><br><span class="line">    void P();     // 判断value是否大于0，否则加入queue队尾，睡眠当前线程</span><br><span class="line">    void V();     // 返回队首线程，并设置状态为ready</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    char* name;        // debug的名字</span><br><span class="line">    int value;         // 信号量的值</span><br><span class="line">    List *queue;       // value为0时的等待队列</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>信号量的实现</p>
<p>关键操作为P、V操作</p>
<ul>
<li>P()的实现<ul>
<li>判断value是否为0</li>
<li>若为0，则将当前线程加入queue队尾，并调用sleep函数睡眠</li>
<li>不为0，value–</li>
</ul>
</li>
<li>v()的实现<ul>
<li>从queue队首拿出一个线程</li>
<li>若线程不为空，将其状态设置为READY</li>
<li>value++</li>
</ul>
</li>
</ul>
<h3 id="修改prodcons-cc的程序"><a href="#修改prodcons-cc的程序" class="headerlink" title="修改prodcons++.cc的程序"></a>修改prodcons++.cc的程序</h3><ul>
<li><p>参照monitor文件下prodcons++.cc文件的内容</p>
</li>
<li><p>根据生产者消费者模型</p>
</li>
</ul>
<p>修改程序如下（简要显示）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">nempty = new Semaphore(&quot;nempty&quot;,BUFF_SIZE);</span><br><span class="line">nfull = new Semaphore(&quot;nfull&quot;,0);</span><br><span class="line">mutex = new Semaphore(&quot;mutex&quot;,1);</span><br><span class="line"></span><br><span class="line">ring = new Ring(BUFF_SIZE);</span><br><span class="line"></span><br><span class="line">producer &#123;</span><br><span class="line">    for (num = 0; num &lt; N_MESSG ; num++) &#123;</span><br><span class="line"></span><br><span class="line">      message-&gt;thread_id = which;</span><br><span class="line">      message-&gt;value = num;</span><br><span class="line"></span><br><span class="line">      nempty-&gt;P();</span><br><span class="line">      mutex-&gt;P();</span><br><span class="line"></span><br><span class="line">      ring-&gt;Put(message);</span><br><span class="line">      printf(&quot;producer %d produce thread %d ---&gt; valude d\n&quot;,which,which,num);</span><br><span class="line"></span><br><span class="line">      mutex-&gt;V();</span><br><span class="line">      nfull-&gt;V();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">      nfull-&gt;P();</span><br><span class="line">      mutex-&gt;P();</span><br><span class="line"></span><br><span class="line">      ring-&gt;Get(message);</span><br><span class="line">      printf(&quot;consumer %d get thread %d ---&gt; value %d\n&quot;,which,message-&gt;thread_id,message-&gt;value);</span><br><span class="line"></span><br><span class="line">      mutex-&gt;V();</span><br><span class="line">      nempty-&gt;V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改文件</p>
<p>可得实验结果</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220312220345657.png" alt="image-20220312220345657"></p>
<h3 id="分析并理解，Thread-Fork-创建线程的方法"><a href="#分析并理解，Thread-Fork-创建线程的方法" class="headerlink" title="分析并理解，Thread::Fork()创建线程的方法"></a>分析并理解，Thread::Fork()创建线程的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Thread::Fork(VoidFunctionPtr func, _int arg)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Forking thread \&quot;%s\&quot; with func = 0x%x, arg = %d\n&quot;,  name, (int) func, arg);//设置debug信息</span><br><span class="line"></span><br><span class="line">    StackAllocate(func, arg);//为线程分配栈</span><br><span class="line"></span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);//关中断</span><br><span class="line">    scheduler-&gt;ReadyToRun(this);    // 将线程状态设置为ready并加入就绪队列</span><br><span class="line"></span><br><span class="line">    (void) interrupt-&gt;SetLevel(oldLevel);//开中断</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>fork()</p>
<p>新建一个线程并设置状态为ready（放入准备就绪队列）</p>
<p>StackAllocate(func, arg);&#x2F;&#x2F;为线程分配栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">machineState[PCState] = (_int) ThreadRoot;//函数入口</span><br><span class="line">machineState[StartupPCState] = (_int) InterruptEnable;</span><br><span class="line">machineState[InitialPCState] = (_int) func;//函数运行体</span><br><span class="line">machineState[InitialArgState] = arg;</span><br><span class="line">machineState[WhenDonePCState] = (_int) ThreadFinish;//函数结束出口</span><br></pre></td></tr></table></figure>

<p>其他Thread和scheduler的函数分析请见备注</p>
<h3 id="rs轮转调度"><a href="#rs轮转调度" class="headerlink" title="-rs轮转调度"></a>-rs轮转调度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if (!strcmp(*argv, &quot;-rs&quot;)) &#123;</span><br><span class="line">        ASSERT(argc &gt; 1);</span><br><span class="line">        RandomInit(atoi(*(argv + 1)));    // initialize pseudo-random</span><br><span class="line">                        // number generator</span><br><span class="line">        randomYield = TRUE;</span><br><span class="line">        argCount = 2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>-rs后可跟数字，作为随机数初始化种子</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220313005518934.png" alt="image-20220313005518934"></p>
<p>可以看到与上次运行结果确实不同，在producer0产生的消息未填满缓冲区时就发生了调度</p>
<p>通过阅读Interrupt的源码可知，nachos中断响应的时机</p>
<ul>
<li>中断状态从关到开</li>
<li>Nachos的CPU执行完一条应用程序指令</li>
</ul>
<p>上述两种情况发生时，系统时钟调用Interrupt::OneTick()。</p>
<p>同时检查是否有中断到期，有则响应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (yieldOnReturn) &#123;        // if the timer device handler asked </span><br><span class="line">                    // for a context switch, ok to do it now</span><br><span class="line">    yieldOnReturn = FALSE;</span><br><span class="line">     status = SystemMode;        // yield is a kernel routine</span><br><span class="line">    currentThread-&gt;Yield();</span><br><span class="line">    status = old;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时发生程序调度，当前进程转为READY状态，运行下一个就绪进程</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><h3 id="C语言函数"><a href="#C语言函数" class="headerlink" title="C语言函数"></a>C语言函数</h3><p>sprintf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sprintf(char *str, const char *format, ...) </span><br><span class="line">发送格式化输出到 str 所指向的字符串</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char str[80];</span><br><span class="line"></span><br><span class="line">   sprintf(str, &quot;Pi 的值 = %f&quot;, M_PI);</span><br><span class="line">   puts(str);</span><br><span class="line"></span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pi 的值 = 3.141593</span><br></pre></td></tr></table></figure>

<p>atoi</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int atoi(const char *str)</span><br></pre></td></tr></table></figure>

<p>把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int val;</span><br><span class="line">   char str[20];</span><br><span class="line"></span><br><span class="line">   strcpy(str, &quot;98993489&quot;);</span><br><span class="line">   val = atoi(str);</span><br><span class="line">   printf(&quot;字符串值 = %s, 整型值 = %d\n&quot;, str, val);</span><br><span class="line"></span><br><span class="line">   strcpy(str, &quot;runoob.com&quot;);</span><br><span class="line">   val = atoi(str);</span><br><span class="line">   printf(&quot;字符串值 = %s, 整型值 = %d\n&quot;, str, val);</span><br><span class="line"></span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">字符串值 = 98993489, 整型值 = 98993489</span><br><span class="line">字符串值 = runoob.com, 整型值 = 0</span><br></pre></td></tr></table></figure>

<h2 id="上下文切换相关函数实现的分析"><a href="#上下文切换相关函数实现的分析" class="headerlink" title="上下文切换相关函数实现的分析"></a>上下文切换相关函数实现的分析</h2><h3 id="Thread-Yield"><a href="#Thread-Yield" class="headerlink" title="Thread::Yield()"></a>Thread::Yield()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Thread::Yield ()</span><br><span class="line">&#123;</span><br><span class="line">    Thread *nextThread;</span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);//关中断</span><br><span class="line"></span><br><span class="line">    ASSERT(this == currentThread);//判断本进程是否为当前进程</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Yielding thread \&quot;%s\&quot;\n&quot;, getName());//设置debug信息</span><br><span class="line"></span><br><span class="line">    nextThread = scheduler-&gt;FindNextToRun();//在就绪队列中找到下一个可运行进程</span><br><span class="line">    if (nextThread != NULL) &#123;//若下一个可运行进程不为空</span><br><span class="line">        scheduler-&gt;ReadyToRun(this);//设置本进程状态为READY</span><br><span class="line">        scheduler-&gt;Run(nextThread);//运行下一个进程</span><br><span class="line">    &#125;</span><br><span class="line">    (void) interrupt-&gt;SetLevel(oldLevel);//开中断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scheduler-Run-Thread-nextThread"><a href="#Scheduler-Run-Thread-nextThread" class="headerlink" title="Scheduler::Run (Thread *nextThread)"></a>Scheduler::Run (Thread *nextThread)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Scheduler::Run (Thread *nextThread)</span><br><span class="line">&#123;</span><br><span class="line">    Thread *oldThread = currentThread;</span><br><span class="line"></span><br><span class="line">    oldThread-&gt;CheckOverflow();            // 检查旧进程是否有不可删除的栈溢出</span><br><span class="line">                        // had an undetected stack overflow</span><br><span class="line"></span><br><span class="line">    currentThread = nextThread;            // 宏变量当前进程设置为即将运行的进程</span><br><span class="line">    currentThread-&gt;setStatus(RUNNING);      // 设置本进程状态为RUNNING</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Switching from thread \&quot;%s\&quot; to thread \&quot;%s\&quot;\n&quot;,</span><br><span class="line">      oldThread-&gt;getName(), nextThread-&gt;getName());</span><br><span class="line"></span><br><span class="line">    //阅读汇编代码</span><br><span class="line">    SWITCH(oldThread, nextThread);//交换两个进程的状态</span><br><span class="line">    //返回nextThread的执行</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Now in thread \&quot;%s\&quot;\n&quot;, currentThread-&gt;getName());</span><br><span class="line"></span><br><span class="line">    // 处理完成运行的旧线程</span><br><span class="line">    if (threadToBeDestroyed != NULL) &#123;</span><br><span class="line">        delete threadToBeDestroyed;</span><br><span class="line">        threadToBeDestroyed = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thread-finish"><a href="#Thread-finish" class="headerlink" title="Thread::finish()"></a>Thread::finish()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Thread::Finish ()</span><br><span class="line">&#123;</span><br><span class="line">    (void) interrupt-&gt;SetLevel(IntOff);        </span><br><span class="line">    ASSERT(this == currentThread);</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Finishing thread \&quot;%s\&quot;\n&quot;, getName());</span><br><span class="line"></span><br><span class="line">    threadToBeDestroyed = currentThread;</span><br><span class="line">    Sleep();                    // invokes SWITCH</span><br><span class="line">    // not reached</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread::sleep()"></a>Thread::sleep()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Thread::Sleep ()</span><br><span class="line">&#123;</span><br><span class="line">    Thread *nextThread;</span><br><span class="line"></span><br><span class="line">    ASSERT(this == currentThread);</span><br><span class="line">    ASSERT(interrupt-&gt;getLevel() == IntOff);</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Sleeping thread \&quot;%s\&quot;\n&quot;, getName());</span><br><span class="line"></span><br><span class="line">    status = BLOCKED;</span><br><span class="line">    while ((nextThread = scheduler-&gt;FindNextToRun()) == NULL)</span><br><span class="line">    interrupt-&gt;Idle();    // no one to run, wait for an interrupt</span><br><span class="line"></span><br><span class="line">    scheduler-&gt;Run(nextThread); // returns when we&#x27;ve been signalled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当前进程设置状态为 BLOCKED</p>
</li>
<li><p>寻找下一个可执行进程并运行</p>
</li>
<li><p>若找不到可执行进程，等待一个中断</p>
</li>
</ul>
<p>Thread::Sleep()只是将当前线程的状态设置为 BLOCKED，然后调度下一 个线程执行；</p>
<p>（目前 Sleep()在信号量的 P、V 操作、Thread::Finish()调用）；</p>
<h3 id="Thread-FindNextToRun"><a href="#Thread-FindNextToRun" class="headerlink" title="Thread::FindNextToRun()"></a>Thread::FindNextToRun()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread *</span><br><span class="line">Scheduler::FindNextToRun ()</span><br><span class="line">&#123;</span><br><span class="line">    return (Thread *)readyList-&gt;Remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在就绪队列中返回队首的就绪线程，并将该线程在就绪队列中移除</p>
<h1 id="实验四-Nachos-的文件系统"><a href="#实验四-Nachos-的文件系统" class="headerlink" title="实验四 Nachos 的文件系统"></a>实验四 Nachos 的文件系统</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol>
<li>理解 Nachos 硬盘是如何创建的； </li>
<li>熟悉查看 Nachos 硬盘上的内容的方法； </li>
<li>理解硬盘初始化的过程（如何在硬盘上创建一个文件系统）； </li>
<li>了解 Nachos 文件系统提供了哪些命令，哪些命令已经实现，哪些需要你自 己实现； </li>
<li>理解已经实现的文件系统命令的实现原理； </li>
<li>理解硬盘空闲块的管理方法； </li>
<li>理解目录文件的结构与管理；</li>
<li>理解文件的结构与文件数据块的分配方法； </li>
<li>了解一个文件系统命令执行后，硬盘的布局； </li>
<li>分析目前 Nachos 不能对文件进行扩展的原因，考虑解决方案；</li>
</ol>
<h2 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h2><p>Nachos实现了两个版本的文件系统</p>
<ul>
<li>FILESYS_STUB：直接利用UNIX所提供的系统调用实现</li>
<li>FILESYS：通过Openfile类对DISK上的文件进行操作，尽管最终也是使用系统调用</li>
</ul>
<h3 id="硬盘初始化"><a href="#硬盘初始化" class="headerlink" title="硬盘初始化"></a>硬盘初始化</h3><p>（1）..&#x2F;lab5&#x2F;main.cc 调用了..&#x2F;threads&#x2F;system.cc 中的 Initialize()创建了硬盘 DISK。 分析..&#x2F;threads&#x2F;synchdisk.cc 及..&#x2F;machine&#x2F;disk.cc，理解 Nachos 创建硬盘的过程与方法；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Disk::Disk(char* name, VoidFunctionPtr callWhenDone, _int callArg)</span><br><span class="line">&#123;</span><br><span class="line">    int magicNum;</span><br><span class="line">    int tmp = 0;</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;d&#x27;, &quot;Initializing the disk, 0x%x 0x%x\n&quot;, callWhenDone, callArg);</span><br><span class="line">    handler = callWhenDone;</span><br><span class="line">    handlerArg = callArg;</span><br><span class="line">    lastSector = 0;</span><br><span class="line">    bufferInit = 0;</span><br><span class="line"></span><br><span class="line">    fileno = OpenForReadWrite(name, FALSE);</span><br><span class="line">    if (fileno &gt;= 0) &#123;             // 文件存在，检查magicNum</span><br><span class="line">        Read(fileno, (char *) &amp;magicNum, MagicSize);//获取前四个字节 Sizeof(int)</span><br><span class="line">        ASSERT(magicNum == MagicNumber);</span><br><span class="line">    &#125; else &#123;                // 文件不存在，创建文件</span><br><span class="line">        fileno = OpenForWrite(name);</span><br><span class="line">        magicNum = MagicNumber;  </span><br><span class="line">        WriteFile(fileno, (char *) &amp;magicNum, MagicSize); // 写入magicNum</span><br><span class="line"></span><br><span class="line">    // need to write at end of file, so that reads will not return EOF</span><br><span class="line">        Lseek(fileno, DiskSize - sizeof(int), 0);    </span><br><span class="line">        WriteFile(fileno, (char *)&amp;tmp, sizeof(int));  </span><br><span class="line">    &#125;</span><br><span class="line">    active = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个文件用来当硬盘</p>
<ul>
<li>若文件存在，检查magicNum</li>
<li>若文件不存在，创建文件</li>
</ul>
<h3 id="硬盘大小"><a href="#硬盘大小" class="headerlink" title="硬盘大小"></a>硬盘大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define SectorSize         128    // 每个扇区的字节数</span><br><span class="line">#define SectorsPerTrack     32    // 每道的扇区数</span><br><span class="line">#define NumTracks         32    // 硬盘的道数</span><br><span class="line">#define NumSectors         (SectorsPerTrack * NumTracks)</span><br><span class="line"></span><br><span class="line">#define MagicNumber     0x456789ab</span><br><span class="line">#define MagicSize     sizeof(int) //4字节大小</span><br><span class="line"></span><br><span class="line">#define DiskSize     (MagicSize + (NumSectors * SectorSize))</span><br></pre></td></tr></table></figure>

<p>总扇区数：32*32&#x3D;1024</p>
<p>硬盘大小：（4+32<em>32</em>128）B&#x2F;1024&#x3D;0x80KB</p>
<h3 id="Nachos的文件系统命令"><a href="#Nachos的文件系统命令" class="headerlink" title="Nachos的文件系统命令"></a>Nachos的文件系统命令</h3><p>（2）分析..&#x2F;lab5&#x2F;main.cc，了解 Nachos 文件系统提供了哪些命令，对每个命令进行测试，根据执行结果观察哪些命令已经实现（正确运行），哪些无法正确运行（尚未 完全实现，需要你自己完善）；</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-d f</td>
<td>可选参数[-d f]的作用是打印出所有与文件系统有关的调试信息。</td>
</tr>
<tr>
<td>nachos –cp UNIX_filename nachos_filename</td>
<td>将一个 Unix 文件系统中的文 件 UNIX_filename 复制到 Nachos 文件系统中，重新命名为 nachos_filename</td>
</tr>
<tr>
<td>nachos [-d f] –p nachos_filename</td>
<td>该命令输出 nachos 文件 nachos_filename 的内容，类似于 UNIX 中的 cat 命令</td>
</tr>
<tr>
<td>nachos [-d f] –r nachos_filename</td>
<td>删除 Nachos 文件 nachos_filename，类似于 UNIX 中的 rm 命令</td>
</tr>
<tr>
<td>nachos [-d f] -l</td>
<td>输出当前目录中的文件名，类似于 DOS 中的 dir，UNIX 中的 ls</td>
</tr>
<tr>
<td>nachos [-d f] -t</td>
<td>测试 Nachos 文件系统的性能（目前尚未实现）</td>
</tr>
<tr>
<td>nachos [-d f] -D</td>
<td>输出 Nachos 的文件系统在磁盘上的组织。打印出整个文件系统 的所有内容，包括位图文件（bitmap）、文件头（file header）、目录文件（directory） 和普通文件（file）</td>
</tr>
</tbody></table>
<h3 id="文件系统FileSystem的初始化"><a href="#文件系统FileSystem的初始化" class="headerlink" title="文件系统FileSystem的初始化"></a>文件系统FileSystem的初始化</h3><p>（3）分析..&#x2F;filesys&#x2F;filessys.cc，特别是构造函数 FileSystem::FileSystem(..)，理解 Nachos 硬盘”DISK”的创建及硬盘格式化（创建文件系统）的处理过程；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 通过宏定义确定位示图文件头和文件目录表文件头的扇区位置</span><br><span class="line">#define FreeMapSector         0</span><br><span class="line">#define DirectorySector     1</span><br><span class="line"></span><br><span class="line">FileSystem::FileSystem(bool format)</span><br><span class="line">&#123; </span><br><span class="line">    DEBUG(&#x27;f&#x27;, &quot;Initializing the file system.\n&quot;);</span><br><span class="line">    if (format) &#123;</span><br><span class="line">        BitMap *freeMap = new BitMap(NumSectors); //位示图</span><br><span class="line">        Directory *directory = new Directory(NumDirEntries); //文件目录表</span><br><span class="line">        FileHeader *mapHdr = new FileHeader; //位示图的文件头</span><br><span class="line">        FileHeader *dirHdr = new FileHeader; //文件目录表的文件头</span><br><span class="line"></span><br><span class="line">        DEBUG(&#x27;f&#x27;, &quot;Formatting the file system.\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 首先，标记0号和1号扇区已被使用</span><br><span class="line">        freeMap-&gt;Mark(FreeMapSector);        </span><br><span class="line">        freeMap-&gt;Mark(DirectorySector);</span><br><span class="line"></span><br><span class="line">    // 然后，为位示图数据块和根目录表分配空间，确保有足够的空间</span><br><span class="line">        ASSERT(mapHdr-&gt;Allocate(freeMap, FreeMapFileSize));</span><br><span class="line">        ASSERT(dirHdr-&gt;Allocate(freeMap, DirectoryFileSize));</span><br><span class="line"></span><br><span class="line">    // 将位图和文件目录表的文件头刷新回磁盘</span><br><span class="line">    // 在打开文件前就需要做这一步，否则在打开文件时，磁盘是脏的</span><br><span class="line">        DEBUG(&#x27;f&#x27;, &quot;Writing headers back to disk.\n&quot;);</span><br><span class="line">        mapHdr-&gt;WriteBack(FreeMapSector);    </span><br><span class="line">        dirHdr-&gt;WriteBack(DirectorySector);</span><br><span class="line"></span><br><span class="line">    // 现在可以打开位示图和文件目录表</span><br><span class="line">    // 文件系统操作假设在Nachos运行时这两个文件是打开的</span><br><span class="line">        freeMapFile = new OpenFile(FreeMapSector); </span><br><span class="line">        directoryFile = new OpenFile(DirectorySector);</span><br><span class="line"></span><br><span class="line">    // 当我们打开文件时，我们可以写每个文件的最初版本到硬盘上</span><br><span class="line">    // 此时文件目录表是空的，但位示图会被改变（由于扇区已经被分配给了文件头</span><br><span class="line">        DEBUG(&#x27;f&#x27;, &quot;Writing bitmap and directory back to disk.\n&quot;);</span><br><span class="line">        freeMap-&gt;WriteBack(freeMapFile);     // 写回硬盘</span><br><span class="line">        directory-&gt;WriteBack(directoryFile);</span><br><span class="line"></span><br><span class="line">        if (DebugIsEnabled(&#x27;f&#x27;)) &#123;</span><br><span class="line">            freeMap-&gt;Print();</span><br><span class="line">            directory-&gt;Print();</span><br><span class="line"></span><br><span class="line">               delete freeMap; </span><br><span class="line">            delete directory; </span><br><span class="line">            delete mapHdr; </span><br><span class="line">            delete dirHdr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    // 如果不是在建立硬盘的话，我们只需要打开文件就好</span><br><span class="line">        freeMapFile = new OpenFile(FreeMapSector);</span><br><span class="line">        directoryFile = new OpenFile(DirectorySector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nachos文件系统布局"><a href="#Nachos文件系统布局" class="headerlink" title="Nachos文件系统布局"></a>Nachos文件系统布局</h3><p>（4）利用命令 hexdump –C DISK 查看硬盘格式化后硬盘的布局，理解格式化硬盘所完成的工作，以及文件系统管理涉及到的一些数据结构组织与使用，如文件头 （FCB）、目录表与目录项、空闲块管理位示图等；</p>
<p>​        结合输出结果，分析 FileSystem::FileSystem(..)初始化文件系统时涉及到的几个模 块 ， 如 ..&#x2F;filesys&#x2F;filehdr.h(filehdr.cc) ， directory.h(directory.cc) ， ..&#x2F;userprog&#x2F;bitmap.h （bitmap.cc），<strong>理解文件头（FCB）的结构与组织、硬盘空闲块管理使用的位示图文件、目录表文件及目录下的组织与结构</strong>，以及它们在硬盘上的位置；</p>
<table>
<thead>
<tr>
<th><strong>扇区号</strong></th>
<th><strong>起止字节</strong></th>
<th><strong>内容描述</strong></th>
<th><strong>内容</strong></th>
<th><strong>大小</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x0~0x3</td>
<td>磁盘标识（魔数）</td>
<td>0x456789ab</td>
<td>4字节</td>
</tr>
<tr>
<td>0</td>
<td>0x4~0x83</td>
<td>位示图文件头</td>
<td>Class FileHeader</td>
<td>128字节</td>
</tr>
<tr>
<td>1</td>
<td>0x84~0x103</td>
<td>目录表文件头</td>
<td>Class FileHeader</td>
<td>128字节</td>
</tr>
<tr>
<td>2</td>
<td>0x104~0x183</td>
<td>位示图文件数据块</td>
<td>Class BitMap</td>
<td>128字节</td>
</tr>
<tr>
<td>3</td>
<td>0x184~0x203</td>
<td>根目录表（目录文件）</td>
<td>Class Directory</td>
<td>128字节</td>
</tr>
<tr>
<td>4</td>
<td>0x204~0x283</td>
<td>根目录表（目录文件）</td>
<td>Class Directory</td>
<td>128字节</td>
</tr>
<tr>
<td>5</td>
<td>0x284~0x303</td>
<td>第一个文件的文件头</td>
<td>Class FileHeader</td>
<td>128字节</td>
</tr>
<tr>
<td>6</td>
<td>0x304~0x383</td>
<td>第一个文件的数据块</td>
<td></td>
<td>128字节</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>(文件需要的块数不定)</td>
<td>…….</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>第二个文件的文件头</td>
<td>Class FileHeader</td>
<td>128字节</td>
</tr>
<tr>
<td></td>
<td></td>
<td>第二个文件的数据块</td>
<td></td>
<td>128字节</td>
</tr>
<tr>
<td></td>
<td></td>
<td>……</td>
<td>……</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>第三个文件的文件头</td>
<td>Class FileHeader</td>
<td>128字节</td>
</tr>
<tr>
<td></td>
<td></td>
<td>第三个文件的数据块</td>
<td></td>
<td>128字节</td>
</tr>
<tr>
<td></td>
<td></td>
<td>…..</td>
<td>……</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>以此类推</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在系统初始化后查看硬盘内容</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314004009009.png" alt="image-20220314004009009"></p>
<p>此时对应查看</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314005505549.png" alt="image-20220314005505549"></p>
<p>与DISK文件内容一致</p>
<p>总结其布局</p>
<p>文件系统 FileSystem</p>
<ul>
<li>位示图 OpenFile* freeMapFile;</li>
<li>根目录 OpenFile* directoryFile;</li>
<li>打开文件 OpenFile 结构<ul>
<li>FileHeader *hdr;            &#x2F;&#x2F; 文件头</li>
<li>int seekPosition;            &#x2F;&#x2F; 文件内的当前位置</li>
<li>int hdrSector;                &#x2F;&#x2F; 文件头所在扇区<ul>
<li>FileHeader 文件头结构<ul>
<li>int numBytes;            &#x2F;&#x2F; 文件大小，单位：字节</li>
<li>int numSectors;            &#x2F;&#x2F; 文件的逻辑块数</li>
<li>int dataSectors[NumDirect];        &#x2F;&#x2F; 数据块所在扇区列表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="三元组信息"><a href="#三元组信息" class="headerlink" title="三元组信息"></a>三元组信息</h4><ul>
<li><p>文件头</p>
<ul>
<li>文件大小 int</li>
<li>占用扇区数 int</li>
<li>数据块所在扇区列表  int*30</li>
</ul>
</li>
<li><p>位示图</p>
</li>
<li><p>文件目录项</p>
<ul>
<li>inUse bool （但为了对齐，编译器分配了4字节</li>
<li>扇区号 int</li>
<li>名字 9+1&#x3D;10 字节</li>
<li>为了对齐 共20字节</li>
</ul>
</li>
</ul>
<h3 id="更多的验证"><a href="#更多的验证" class="headerlink" title="更多的验证"></a>更多的验证</h3><p>（5）利用命令 nachos –cp ..&#x2F;test&#x2F;small samll 复制文件..&#x2F;test&#x2F;small 到硬盘 DISK 中； </p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314010620035.png" alt="image-20220314010620035"></p>
<p>可以看到3号扇区增加一个文件目录项small</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>inUse</th>
<th>文件头（索引节点）所在的扇区号</th>
</tr>
</thead>
<tbody><tr>
<td>small</td>
<td>1</td>
<td>5</td>
</tr>
</tbody></table>
<p>5号扇区内保存small文件头内容</p>
<p>5号扇区文件头</p>
<ul>
<li>文件大小：54字节</li>
<li>分配扇区个数：1</li>
<li>扇区位置：6号扇区</li>
</ul>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314010126127.png" alt="image-20220314010126127"></p>
<p>验证可得相同内容</p>
<p>（6）利用命令 hexdump –C DISK 查看硬盘格式化后硬盘的布局，理解创建一个 文件后相关的结构在硬盘上的存储布局； </p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314011027327.png" alt="image-20220314011027327"></p>
<p>文件目录表、位示图全部初始化为初始信息。</p>
<p>（7）复制更多的文件到 DISK 中，然后删除一个文件，利用 hexdump –C DISK 查看文件的布局，分析文件系统的管理策略。</p>
<p>复制small、big文件到DISK中，删除small文件，查看DISK内容</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314010728426.png" alt="image-20220314010728426"></p>
<p>删除文件samll后</p>
<p>更改</p>
<ul>
<li>位示图中扇区变为空闲</li>
<li>目录项变为空闲  isUse置0</li>
</ul>
<p>未更改</p>
<ul>
<li>文件名、头文件所占扇区号均未清除</li>
<li>文件头信息、文件内容未清除</li>
</ul>
<p>分析文件管理策略：</p>
<ul>
<li>删除文件时，并非真的物理性初始化文件信息，只需修改位示图和文件目录表</li>
<li>文件所在扇区标记为空闲、文件目录表中被删除文件信息无效化便可视为文件已删除</li>
</ul>
<h2 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h2><h3 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h3><h4 id="od命令用于输出文件内容。"><a href="#od命令用于输出文件内容。" class="headerlink" title="od命令用于输出文件内容。"></a>od命令用于输出文件内容。</h4><p>od指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来。</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>格式规范</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>-t a</td>
<td>输出命名字符。</td>
</tr>
<tr>
<td>-b</td>
<td>-t o1</td>
<td>输出八进制字节。</td>
</tr>
<tr>
<td>-c</td>
<td>-t c</td>
<td>输出可打印的单字节字符，C反斜杠转义或3位八进制序列。</td>
</tr>
<tr>
<td>-d</td>
<td>-t u2</td>
<td>输出无符号十进制数（双字节）。</td>
</tr>
<tr>
<td>-f</td>
<td>-t fF</td>
<td>输出浮点型。</td>
</tr>
<tr>
<td>-i</td>
<td>-t dI（大写I）</td>
<td>输出十进制整数。</td>
</tr>
<tr>
<td>-l</td>
<td>-t dL</td>
<td>输出十进制长整型。</td>
</tr>
<tr>
<td>-o</td>
<td>-t o2</td>
<td>输出八进制字节（双字节）。</td>
</tr>
<tr>
<td>-s</td>
<td>-t d2</td>
<td>输出十进制数（双字节）。</td>
</tr>
<tr>
<td>-x</td>
<td>-t x2</td>
<td>输出十六进制数（双字节）。</td>
</tr>
</tbody></table>
<h4 id="hexdump命令主要用来查看“二进制”文件的十六进制编码"><a href="#hexdump命令主要用来查看“二进制”文件的十六进制编码" class="headerlink" title="hexdump命令主要用来查看“二进制”文件的十六进制编码"></a>hexdump命令<strong>主要用来查看“二进制”文件的十六进制编码</strong></h4><ul>
<li><p><strong>语法</strong></p>
<p><strong>hexdump [选项] [文件]…</strong></p>
</li>
<li><p><strong>选项</strong></p>
<ul>
<li>-<strong>n length</strong>：格式化输出文件的前length个字节</li>
<li>-<strong>C</strong>：输出规范的十六进制和ASCII码</li>
<li><strong>-b</strong>：单字节八进制显示</li>
<li><strong>-c</strong>：单字节字符显示</li>
<li><strong>-d</strong>：双字节十进制显示</li>
<li><strong>-o</strong>：双字节八进制显示</li>
<li><strong>-x</strong>：双字节十六进制显示</li>
<li><strong>-s</strong>：从偏移量开始输出</li>
</ul>
</li>
</ul>
<h3 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class BitMap &#123;</span><br><span class="line">  private:</span><br><span class="line">    int numBits;            // 扇区数 固定不变 初始化来的</span><br><span class="line">    int numWords;            // 位示图存储的字节数</span><br><span class="line">                    // 不是字的倍数可以舍入</span><br><span class="line">    unsigned int *map;            // bit storage</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>标记whitch扇区被使用，左移赋值</p>
<p>BitsInWord&#x3D;32</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">BitMap::Mark(int which) </span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(which &gt;= 0 &amp;&amp; which &lt; numBits);</span><br><span class="line">    map[which / BitsInWord] |= 1 &lt;&lt; (which % BitsInWord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他函数的实现规则类似</p>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>文件目录的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Directory &#123;</span><br><span class="line">  private:</span><br><span class="line">    int tableSize;            // 目录项的数量</span><br><span class="line">    DirectoryEntry *table;        // 目录项数组</span><br><span class="line"></span><br><span class="line">    int FindIndex(char *name);        // 根据文件名寻找下标</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>目录项的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class DirectoryEntry &#123;</span><br><span class="line">  public:</span><br><span class="line">    bool inUse;                // 该目录项是否已经分配 1字节  编译器出于对其原则分配4字节</span><br><span class="line">    int sector;                // 文件头所在的扇区号 4字节</span><br><span class="line">                    //   文件头未FCB或i-node </span><br><span class="line">    char name[FileNameMaxLen + 1];    // 文件名 最长为9个字节</span><br><span class="line">                    // +1 末尾 &#x27;\0&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>目录文件<ul>
<li>文件头</li>
<li>目录表</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>文件名</th>
<th>inUse</th>
<th>文件头（索引节点）所在的扇区号</th>
</tr>
</thead>
<tbody><tr>
<td>main.cc</td>
<td>1</td>
<td>4</td>
</tr>
</tbody></table>
<ul>
<li>文件<ul>
<li>文件头</li>
<li>数据块</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Sectors containing the file headers for the bitmap of free sectors,</span><br><span class="line">// and the directory of files.  These file headers are placed in well-known </span><br><span class="line">// sectors, so that they can be located on boot-up.</span><br><span class="line">#define FreeMapSector         0</span><br><span class="line">#define DirectorySector     1</span><br><span class="line"></span><br><span class="line">// Initial file sizes for the bitmap and directory; until the file system</span><br><span class="line">// supports extensible files, the directory size sets the maximum number </span><br><span class="line">// of files that can be loaded onto the disk.</span><br><span class="line">#define FreeMapFileSize     (NumSectors / BitsInByte)</span><br><span class="line">#define NumDirEntries         10</span><br><span class="line">#define DirectoryFileSize     (sizeof(DirectoryEntry) * NumDirEntries)</span><br></pre></td></tr></table></figure>

<p>文件头相当于FCB</p>
<h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class FileHeader &#123;</span><br><span class="line">  public:</span><br><span class="line">    bool Allocate(BitMap *bitMap, int fileSize);// 初始化文件头</span><br><span class="line">                        //  包括在硬盘上分配数据块</span><br><span class="line">    void Deallocate(BitMap *bitMap);          // 回收数据块</span><br><span class="line"></span><br><span class="line">    void FetchFrom(int sectorNumber);     // 在硬盘上初始化文件头</span><br><span class="line">    void WriteBack(int sectorNumber);     // 向硬盘写回文件头的修改内容</span><br><span class="line"></span><br><span class="line">    int ByteToSector(int offset);    // Convert a byte offset into the file</span><br><span class="line">                    // to the disk sector containing</span><br><span class="line">                    // the byte</span><br><span class="line">                    //将文件中的字节偏移量转换为包含该字节的扇区编号</span><br><span class="line"></span><br><span class="line">    int FileLength();            // 以字节为单位返回文件长度</span><br><span class="line"></span><br><span class="line">    void Print();            // 输出文件内容</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    int numBytes;            // 文件大小，单位：字节</span><br><span class="line">    int numSectors;            // 文件的逻辑块数</span><br><span class="line">    int dataSectors[NumDirect];        // 直接块数组，依次存储文件的每个数据块所对应的扇区号</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define NumDirect     ((SectorSize - 2 * sizeof(int)) / sizeof(int)) </span><br><span class="line">#define MaxFileSize     (NumDirect * SectorSize)</span><br></pre></td></tr></table></figure>

<p>每个文件最多包含30个扇区，最大为3780字节（3KB&#x3D;30*128B）</p>
<p>确定方式</p>
<p>目标：使文件头大小刚好为一个数据块大小</p>
<p>文件头包含&#x3D;numBytes(int) + numSectores(int) + dataSectors[]</p>
<p>使得dataSectors数组大小填满剩下的区域</p>
<p>size&#x3D;(128-4*2)&#x2F;4&#x3D;30</p>
<h3 id="硬盘空闲块的管理"><a href="#硬盘空闲块的管理" class="headerlink" title="硬盘空闲块的管理"></a>硬盘空闲块的管理</h3><p>位示图（BitMap）</p>
<p>位示图也是一个文件，由文件头+数据块组成，文件头保存在第0号扇区中</p>
<p>1024个扇区对应   1024&#x2F;8&#x3D;128字节</p>
<p>目录文件（根目录）的文件头存储在第1号扇区</p>
<p>文件的大小在创建后无法改变</p>
<h1 id="实验五-扩展Nachos的文件系统"><a href="#实验五-扩展Nachos的文件系统" class="headerlink" title="实验五 扩展Nachos的文件系统"></a>实验五 扩展Nachos的文件系统</h1><h2 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h2><p>理解文件系统中文件操作的实现方法，如文件打开、读、写、扩展、定位、关闭等； </p>
<p>理解如何管理硬盘空闲块； </p>
<p>创建文件时，如何为文件分配目录项及文件头（FCB）；</p>
<p>理解文件扩展时，如何为要扩展的数据查找并分配空闲块； </p>
<p>理解文件扩展后，文件大小是如何记录与保存的； </p>
<p>文件被删除后，如何回收为其分配的资源，如文件头、目录项、硬盘块等； </p>
<p>拓展：有精力的同学可进一步尝试多级目录（目录树）的设计与实现方法。根据上述工作，总结操作系统（如 Nachos）读写文件，以及对文件追加数据的过程与步骤（如操作系统需要操作哪些文件系统的控制信息，如何操作的等）。</p>
<h2 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h2><p>让你修改 Nachos 的文件系统，以满足： </p>
<ol>
<li><p>文件创建时，其大小可初始化为 0； </p>
</li>
<li><p>当一个文件写入更多的数据时，其大小可随之增大； </p>
</li>
<li><p>要求能够在从一个文件的任何位置开始写入数据，即能够正确处理命令行参数 </p>
<p>-ap, -hap,及-nap；</p>
</li>
</ol>
<p>例子</p>
<p>如果一个文件的大小为 100 字节，当从其偏移量 50（第一个字节的偏移量 是 0）开始写入 100 个字节后，该文件的大小应该为 150 字节</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220314194850745.png" alt="image-20220314194850745"></p>
<h2 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>确定需要修改的文件和函数</p>
<p>首先阅读源码可知，</p>
<ul>
<li><p>OpenFile::WriteAt(char *from, int numBytes, int position)函数实现了从任意位置插入内容，但是并不可以扩展文件大小，修改其内部代码，增加扩展文件大小的函数调用</p>
</li>
<li><p>Openfile::WriteBack()  实现将新的文件头写回硬盘</p>
<ul>
<li>FileHeader::void WriteBack(int sectorNumber);FileHeader类本身拥有将自身写回硬盘sectorNumber扇区的函数，但是我们缺少原文件头所在扇区号的参数</li>
<li>Openfile增加私有变量hdrSector用于记录文件头所在扇区，并在初始化时更新</li>
</ul>
</li>
<li><p>新函数 Openfile::ExtendSpace(int NumByte) 增加NumByte的空间</p>
<ul>
<li>实现方式通过调用FileHeader *hdr;的内部函数实现</li>
<li>FileHeader::ExtendSpace(BitMap *bitMap,int NumByte)  增加NumByte的字节，并修改位示图</li>
</ul>
</li>
<li><p>FileSystem类的新函数</p>
<ul>
<li>BitMap* getBitMap();   获取位示图</li>
<li>void setBitMap(BitMap* freeMap);  写回位示图</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>修改OpenFile，增加初始化私有成员hdrSector</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OpenFile::OpenFile(int sector)</span><br><span class="line">&#123; </span><br><span class="line">    hdr = new FileHeader;</span><br><span class="line">    hdr-&gt;FetchFrom(sector);</span><br><span class="line">    seekPosition = 0;</span><br><span class="line">    hdrSector = sector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得扇区号后，增加函数WriteBack，将头文件写回硬盘</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int OpenFile::WriteBack()&#123;</span><br><span class="line">    hdr-&gt;WriteBack(hdrSector);</span><br><span class="line">    return hdrSector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展文件大小</p>
<p>函数实现模仿<code>bool Allocate(BitMap *bitMap, int fileSize);</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int FileHeader::ExtendSpace(BitMap *bitMap,int NewByteNum)&#123;</span><br><span class="line">    int NewSectorNum; //新扇区数量</span><br><span class="line">    int OriginalRemainingSpace = SectorSize*numSectors - numBytes; //原剩余空间</span><br><span class="line">    int ExtendByteNum = NewByteNum - OriginalRemainingSpace; </span><br><span class="line">                                    //扩展空间= 新增字节数 - 原剩余空间</span><br><span class="line">    NewSectorNum = divRoundUp(ExtendByteNum,SectorSize); //新增扇区数</span><br><span class="line"></span><br><span class="line">    //若新增扇区数小于等于0，简单增加文件长度后直接返回</span><br><span class="line">    if (NewSectorNum &lt;= 0)&#123; </span><br><span class="line">        numBytes += NewByteNum;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 硬盘剩余扇区数小于新增扇区数，扩展失败，返回-1</span><br><span class="line">    if(bitMap-&gt;NumClear()&lt;NewSectorNum)&#123; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 超过可分配的最大扇区数量，扩展失败</span><br><span class="line">    if((NewSectorNum+numSectors)&gt;30)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最初匹配，寻找第一个空闲扇区，放入文件头的扇区分配数组</span><br><span class="line">    for(int i = numSectors;i &lt; numSectors+NewSectorNum ; i++)&#123;</span><br><span class="line">        dataSectors[i] = bitMap-&gt;Find();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //更新文件头信息</span><br><span class="line">    numSectors += NewSectorNum;</span><br><span class="line">    numBytes += NewByteNum;</span><br><span class="line"></span><br><span class="line">    return NewSectorNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现OpenFile::ExtenByte(int)函数，这个函数主要是帮助FileHead::ExtendSpace()函数准备位示图并将更新后的位示图写回DISK</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">OpenFile::ExtendSpace(int NumByte)&#123;</span><br><span class="line"></span><br><span class="line">    BitMap* bitMap = fileSystem-&gt;getBitMap();</span><br><span class="line"></span><br><span class="line">    int ExtendSectorNum = hdr-&gt;ExtendSpace(bitMap,NumByte);</span><br><span class="line"></span><br><span class="line">    fileSystem-&gt;setBitMap(bitMap);</span><br><span class="line">    return ExtendSectorNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新WriteAt函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">OpenFile::WriteAt(char *from, int numBytes, int position)</span><br><span class="line">&#123;</span><br><span class="line">    int fileLength = hdr-&gt;FileLength();</span><br><span class="line">    int i, firstSector, lastSector, numSectors;</span><br><span class="line">    bool firstAligned, lastAligned;</span><br><span class="line">    char *buf;</span><br><span class="line"></span><br><span class="line">//以下修改的内容</span><br><span class="line">    if (numBytes &lt;= 0)</span><br><span class="line">        return 0;                // 判断写入字节数</span><br><span class="line">    if ((position + numBytes) &gt; fileLength)&#123;</span><br><span class="line">        //判断写入后的位置是否大于文件长度</span><br><span class="line">        int incrementBytes = (position + numBytes) - fileLength;</span><br><span class="line">        int Extend = ExtendSpace(incrementBytes);</span><br><span class="line">        //扩展文件长度</span><br><span class="line">    &#125;</span><br><span class="line">//以上为修改内容</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;f&#x27;, &quot;Writing %d bytes at %d, from file of length %d.\n&quot;,     </span><br><span class="line">            numBytes, position, fileLength);</span><br><span class="line"></span><br><span class="line">    firstSector = divRoundDown(position, SectorSize);</span><br><span class="line">    lastSector = divRoundDown(position + numBytes - 1, SectorSize);</span><br><span class="line">    numSectors = 1 + lastSector - firstSector;</span><br><span class="line"></span><br><span class="line">    buf = new char[numSectors * SectorSize];</span><br><span class="line"></span><br><span class="line">    firstAligned = (bool)(position == (firstSector * SectorSize));</span><br><span class="line">    lastAligned = (bool)((position + numBytes) == ((lastSector + 1) * SectorSize));</span><br><span class="line"></span><br><span class="line">// read in first and last sector, if they are to be partially modified</span><br><span class="line">    if (!firstAligned)</span><br><span class="line">        ReadAt(buf, SectorSize, firstSector * SectorSize);    </span><br><span class="line">    if (!lastAligned &amp;&amp; ((firstSector != lastSector) || firstAligned))</span><br><span class="line">        ReadAt(&amp;buf[(lastSector - firstSector) * SectorSize], </span><br><span class="line">                SectorSize, lastSector * SectorSize);    </span><br><span class="line"></span><br><span class="line">// copy in the bytes we want to change </span><br><span class="line">    bcopy(from, &amp;buf[position - (firstSector * SectorSize)], numBytes);</span><br><span class="line"></span><br><span class="line">// write modified sectors back    </span><br><span class="line">    for (i = firstSector; i &lt;= lastSector; i++)    </span><br><span class="line">        synchDisk-&gt;WriteSector(hdr-&gt;ByteToSector(i * SectorSize), </span><br><span class="line">                    &amp;buf[(i - firstSector) * SectorSize]);</span><br><span class="line">    delete [] buf;</span><br><span class="line"></span><br><span class="line">    //printf(&quot;NumByte: %d\n&quot;,numBytes);</span><br><span class="line">    return numBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220315235407884.png" alt="image-20220315235407884"></p>
<p>可以看到big的文件内容被添加在了medium后面</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>&#x3D;&#x3D;目前 Nachos 文件系统仅仅实现了单级目录结构，只有一个根目录。可以尝试采用目录树对文件进行管理。&#x3D;&#x3D;</p>
<h2 id="备注-2"><a href="#备注-2" class="headerlink" title="备注"></a>备注</h2><p>fseek()<br>函数名: fseek<br>功 能: 重定位流上的文件指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fseek(FILE *stream, long offset, int fromwhere);</span><br></pre></td></tr></table></figure>

<p>描 述: 函数设置文件指针stream的位置。</p>
<ul>
<li><p>如果执行成功，stream将指向以fromwhere为基准，偏移offset个字节的位置。</p>
</li>
<li><p>如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置。</p>
</li>
<li><p>返回值: 成功，返回0，否则返回其他值。</p>
</li>
</ul>
<p>第一个参数stream为文件指针<br>第二个参数offset为偏移量，整数表示正向偏移，负数表示负向偏移<br>第三个参数origin设定从文件的哪里开始偏移,可能取值为：SEEK_CUR、 SEEK_END 或 SEEK_SET<br>SEEK_SET： 文件开头     0<br>SEEK_CUR： 当前位置   1<br>SEEK_END： 文件结尾   2<br>其中SEEK_SET,SEEK_CUR和SEEK_END和依次为0，1和2.</p>
<p>ftell()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long ftell(FILE *fp);</span><br></pre></td></tr></table></figure>

<p>函数功能：返回当前文件指针的位置。这个位置是指当前文件指针相对于文件开头的位移量</p>
<p>返回值：返回文件指针的位置，若出错则返回-1L</p>
<p>fread()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t  fread( void  *buffer, size_t  size, size_t  count, FILE  *stream  ) </span><br></pre></td></tr></table></figure>

<p>buffer  读取的数据存放的内存的指针，可以是数组，也可以是新开辟的空间，buffer就是一个索引</p>
<p>size    每次读取的字节数  </p>
<p>count   读取次数  </p>
<p>strean  要读取的文件的指针  </p>
<p>返回值为读取元素个数</p>
<p>bcopy()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern void bcopy(const void *src, void *dest, int n);</span><br></pre></td></tr></table></figure>

<p> 用法：#include &lt;string.h&gt;</p>
<p> 功能：将字符串src的前n个字节复制到dest中</p>
<p> 说明：bcopy不检查字符串中的空字节NULL，函数没有返回值。</p>
<p>类作用总结</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class OpenFile &#123;</span><br><span class="line">  public:</span><br><span class="line">    OpenFile(int sector);        // 根据扇区号打开文件 文件头</span><br><span class="line">    ~OpenFile();            // 关闭文件</span><br><span class="line"></span><br><span class="line">    void Seek(int position);         // 文件内指针重定位</span><br><span class="line"></span><br><span class="line">    int Read(char *into, int numBytes); // 隐含位置开始读</span><br><span class="line">    int Write(char *from, int numBytes);// 隐含位置开始写</span><br><span class="line"></span><br><span class="line">    int ReadAt(char *into, int numBytes, int position);</span><br><span class="line">                        // 传递位置开始读</span><br><span class="line">    int WriteAt(char *from, int numBytes, int position);</span><br><span class="line"></span><br><span class="line">    int Length();             // 返回文件长度</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    FileHeader *hdr;            // Header for this file </span><br><span class="line">    int seekPosition;            // Current position within the file</span><br><span class="line">    int hdrSector;              // 文件头所在扇区</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class FileHeader &#123;</span><br><span class="line">  public:</span><br><span class="line">    bool Allocate(BitMap *bitMap, int fileSize);// 初始化文件头，在位示图中分配空间</span><br><span class="line">    void Deallocate(BitMap *bitMap);          // 删除文件</span><br><span class="line"></span><br><span class="line">    void FetchFrom(int sectorNumber);     // 根据扇区号初始化文件头</span><br><span class="line">    void WriteBack(int sectorNumber);     // 写回修改后的文件头</span><br><span class="line"></span><br><span class="line">    int ByteToSector(int offset);    // 将字节偏移量转化为扇区号</span><br><span class="line"></span><br><span class="line">    int FileLength();            // 文件的字节长度</span><br><span class="line"></span><br><span class="line">    void Print();            // 打印文件内容</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    int numBytes;            // 字节数</span><br><span class="line">    int numSectors;            // 扇区数</span><br><span class="line">    int dataSectors[NumDirect];        // 扇区数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class FileSystem &#123;</span><br><span class="line">  public:</span><br><span class="line">    FileSystem(bool format);        // Initialize the file system.</span><br><span class="line">                    // Must be called *after* &quot;synchDisk&quot; </span><br><span class="line">                    // has been initialized.</span><br><span class="line">                        // If &quot;format&quot;, there is nothing on</span><br><span class="line">                    // the disk, so initialize the directory</span><br><span class="line">                        // and the bitmap of free blocks.</span><br><span class="line"></span><br><span class="line">    bool Create(char *name, int initialSize);      </span><br><span class="line">                    // Create a file (UNIX creat)</span><br><span class="line"></span><br><span class="line">    OpenFile* Open(char *name);     // 打开一个文件</span><br><span class="line"></span><br><span class="line">    bool Remove(char *name);          // 删除一个文件</span><br><span class="line"></span><br><span class="line">    void List();            // 列出文件系统中的所有文件</span><br><span class="line">    void Print();            // 打印出所有文件及其内容</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">   OpenFile* freeMapFile;        // 位示图</span><br><span class="line">   OpenFile* directoryFile;        // 根部目录文件表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class BitMap &#123;</span><br><span class="line">  public:</span><br><span class="line">    BitMap(int nitems);        // 初始化位示图，参数：扇区数</span><br><span class="line">    ~BitMap();            // De-allocate bitmap</span><br><span class="line"></span><br><span class="line">    void Mark(int which);       // 标记which扇区</span><br><span class="line">    void Clear(int which);      // 清楚whitch扇区</span><br><span class="line">    bool Test(int which);       // witch扇区是否使用</span><br><span class="line">    int Find();                // 寻找并分配第一个空闲扇区 失败返回-1</span><br><span class="line">    int NumClear();        // 返回未使用扇区数</span><br><span class="line"></span><br><span class="line">    void Print();        // 打印位示图信息</span><br><span class="line"></span><br><span class="line">    // These aren&#x27;t needed until FILESYS, when we will need to read and </span><br><span class="line">    // write the bitmap to a file</span><br><span class="line">    void FetchFrom(OpenFile *file);     // fetch contents from disk </span><br><span class="line">    void WriteBack(OpenFile *file);     // write contents to disk</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    int numBits;            // number of bits in the bitmap</span><br><span class="line">    int numWords;            // number of words of bitmap storage</span><br><span class="line">                    // (rounded up if numBits is not a</span><br><span class="line">                    //  multiple of the number of bits in</span><br><span class="line">                    //  a word)</span><br><span class="line">    unsigned int *map;            // bit storage</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="实验六-Nachos用户程序与系统调用"><a href="#实验六-Nachos用户程序与系统调用" class="headerlink" title="实验六 Nachos用户程序与系统调用"></a>实验六 Nachos用户程序与系统调用</h1><h2 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h2><p>为后续实验中实现系统调用 Exec()与 Exit()奠定基础 </p>
<p>理解 Nachos 可执行文件的格式与结构； </p>
<p>掌握 Nachos 应用程序的编程语法，了解用户进程是如何通过系统调用与操作系统内核进行交互的； 掌握如何利用交叉编译生成 Nachos 的可执行程序； </p>
<p>理解系统如何为应用程序创建进程，并启动进程； </p>
<p>理解如何将用户线程映射到核心线程，核心线程执行用户程序的原理与方法； </p>
<p>理解当前进程的页表是如何与 CPU 使用的页表进行关联的；</p>
<h3 id="任务-3"><a href="#任务-3" class="headerlink" title="任务"></a>任务</h3><p>该实验将体验 Nachos 的用户程序、应用进程进程及 Nachos 系统调用的相关概念；</p>
<p>（1）阅读..&#x2F;bin&#x2F;noff.h，分析 Nachos 可执行程序.noff 文件的格式组成； </p>
<p>（2）阅读..&#x2F;test 目录下的几个 Nachos 应用程序，理解 Nachos 应用程序的编程语法，了解用户进程是如何通过系统调用与操作系统内核进行交互的； </p>
<p>（3）阅读..&#x2F;test&#x2F;Makefile，掌握如何利用交叉编译生成 Nachos 的可执行程序； </p>
<p>（4）阅读..&#x2F;threads&#x2F;main.cc，..&#x2F;userprog&#x2F; progtest.cc，根据对命令行参数-x 的处理 过程，理解系统如何为应用程序创建进程，并启动进程的； </p>
<p>（5）阅读..&#x2F;userprog&#x2F; progtest.cc，..&#x2F;threads&#x2F;scheduler.cc（Run()），理解如何将用户线程映射到核心线程，以及核心线程执行用户程序的原理与方法；</p>
<p>（6）阅读..&#x2F;userprog&#x2F; progtest.cc，..&#x2F;machine&#x2F;translate.cc，理解当前进程的页表是如何与CPU使用的页表进行关联的；</p>
<h2 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="运行-Nachos-应用程序的方法："><a href="#运行-Nachos-应用程序的方法：" class="headerlink" title="运行 Nachos 应用程序的方法："></a>运行 Nachos 应用程序的方法：</h3><p>（1）在..&#x2F;test 目录下运行 make，将该目下的几个现有的 Nachos 应用程序（.c 文件）交叉编译，并转换成 Nachos 可执行的.noff 格式文件。<br>现有的几个应用程序：halt.c，matmult.c，shell.c，sort.c<br>（2）在..&#x2F;userprog 目录下运行 make 编译生成 Nachos 系统，键入命令.&#x2F;nachos –x<br>halt.noff 可让 Nachos 运行应用程序 halt.noff，参数-x 的作用是 Nachos 运行其应用程<br>序。</p>
<p>Nachos 实现的文件系统实现了两个版本，</p>
<ul>
<li>FILESYS_STUB：直接利用 UNIX 所提供的系统调用实现，操作的不是硬盘 DISK 上的文件</li>
<li>FILESYS：FILESYS 实现的文件系统是通过 OpenFile 类对 DISK 上的文件进行操作（尽管最终也是使用 UNIX 的系统调用实现）</li>
</ul>
<p>考察..&#x2F;userprog&#x2F;makefile 与 makefile.local 的内容可以看出，实验 6、7、8 默认使用的是 FILESYS_STUB 定义的相关实现，即不是对 DISK 上的文件进行操作，而是直接对 UNIX 文件进行操作；</p>
<h3 id="noff文件格式"><a href="#noff文件格式" class="headerlink" title=".noff文件格式"></a>.noff文件格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define NOFFMAGIC    0xbadfad     /* 表示Nachos的魔数</span><br><span class="line">                     * object code file </span><br><span class="line">                     */</span><br><span class="line"></span><br><span class="line">typedef struct segment &#123;</span><br><span class="line">  int virtualAddr;        /* 虚拟空间的段地址 */</span><br><span class="line">  int inFileAddr;        /* 本文件的段地址 */</span><br><span class="line">  int size;            /* 段长度 */</span><br><span class="line">&#125; Segment;</span><br><span class="line"></span><br><span class="line">typedef struct noffHeader &#123;</span><br><span class="line">   int noffMagic;        /* 应为NOFFMAGIC */</span><br><span class="line">   Segment code;        /* 可执行段代码 */ </span><br><span class="line">   Segment initData;        /* 初始化过的数据段 */</span><br><span class="line">   Segment uninitData;        /* 未初始化过的数据段 --</span><br><span class="line">                 * should be zero&#x27;ed before use </span><br><span class="line">                 */</span><br><span class="line">&#125; NoffHeader;</span><br></pre></td></tr></table></figure>

<p>分析：Nachos 的应用程序是作者自己定义的一种文件类型，文件头部分结构相对简单，编程方便。</p>
<p>Nachos文件主要由3部分构成</p>
<ul>
<li>可执行代码段</li>
<li>初始化过的数据段：一般为初始化的全局变量等</li>
<li>未初始化的数据段：一般指程序运行时才会分配的动态内存、静态变量、未初始化的全局变量</li>
</ul>
<p>每个段有自己的信息</p>
<ul>
<li>文件中的位置</li>
<li>大小</li>
<li>程序入口地址</li>
</ul>
<h3 id="将noff文件装入内存"><a href="#将noff文件装入内存" class="headerlink" title="将noff文件装入内存"></a>将noff文件装入内存</h3><p>系统要运行一个应用程序，需要</p>
<ul>
<li>为该程序创建一个用户进程</li>
<li>为程序分配内存空间，将用户程序（代码段与数据段，数据段包括初始化的全局变量与未初始化的全局变量，以及静态变量）装入所分配的内存空间</li>
<li>创建相应的页表，建立虚页与实页（帧）的映射关系；（参见 AddressSpace:: AddressSpace()）；</li>
</ul>
<p>通过noff.h的各种信息，我们可以得知读取noff文件的规则，并定义好相关的数据结构</p>
<p>Address::Address()初始化将noff文件读入内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">AddrSpace::AddrSpace(OpenFile *executable)</span><br><span class="line">&#123;</span><br><span class="line">    NoffHeader noffH;</span><br><span class="line">    unsigned int i, size;</span><br><span class="line"></span><br><span class="line">// 检查魔数是否正确</span><br><span class="line">    executable-&gt;ReadAt((char *)&amp;noffH, sizeof(noffH), 0);</span><br><span class="line">    if ((noffH.noffMagic != NOFFMAGIC) &amp;&amp; </span><br><span class="line">        (WordToHost(noffH.noffMagic) == NOFFMAGIC))</span><br><span class="line">        SwapHeader(&amp;noffH);</span><br><span class="line">    ASSERT(noffH.noffMagic == NOFFMAGIC);</span><br><span class="line"></span><br><span class="line">// 计算地址空间大小</span><br><span class="line">    size = noffH.code.size + noffH.initData.size + noffH.uninitData.size </span><br><span class="line">            + UserStackSize;    // we need to increase the size   增加栈空间</span><br><span class="line">                        // to leave room for the stack</span><br><span class="line">    numPages = divRoundUp(size, PageSize);</span><br><span class="line">    size = numPages * PageSize;</span><br><span class="line"></span><br><span class="line">    ASSERT(numPages &lt;= NumPhysPages);        // 检查所需页数不会超过实际内存页数 64页</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;a&#x27;, &quot;Initializing address space, num pages %d, size %d\n&quot;, </span><br><span class="line">                    numPages, size);</span><br><span class="line"></span><br><span class="line">// 设置页表</span><br><span class="line">    pageTable = new TranslationEntry[numPages];</span><br><span class="line">    for (i = 0; i &lt; numPages; i++) &#123;</span><br><span class="line">        pageTable[i].virtualPage = i;    // 现在虚拟页号等于物理页号</span><br><span class="line">        pageTable[i].physicalPage = i;</span><br><span class="line">        pageTable[i].valid = TRUE;</span><br><span class="line">        pageTable[i].use = FALSE;</span><br><span class="line">        pageTable[i].dirty = FALSE;</span><br><span class="line">        pageTable[i].readOnly = FALSE;  // 若代码段在独立的页中，设置为只读</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 将整个地址空间置零, 未初始化数据段和栈段</span><br><span class="line">    bzero(machine-&gt;mainMemory, size);</span><br><span class="line"></span><br><span class="line">// 将代码和数据段复制进入内存</span><br><span class="line">    if (noffH.code.size &gt; 0) &#123;</span><br><span class="line">        DEBUG(&#x27;a&#x27;, &quot;Initializing code segment, at 0x%x, size %d\n&quot;, </span><br><span class="line">            noffH.code.virtualAddr, noffH.code.size);</span><br><span class="line">        executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[noffH.code.virtualAddr]),</span><br><span class="line">            noffH.code.size, noffH.code.inFileAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    if (noffH.initData.size &gt; 0) &#123;</span><br><span class="line">        DEBUG(&#x27;a&#x27;, &quot;Initializing data segment, at 0x%x, size %d\n&quot;, </span><br><span class="line">            noffH.initData.virtualAddr, noffH.initData.size);</span><br><span class="line">        executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[noffH.initData.virtualAddr]),</span><br><span class="line">            noffH.initData.size, noffH.initData.inFileAddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的执行流程为</p>
<ul>
<li><p>读入NoffHeader结构，获取文件的基本信息</p>
</li>
<li><p>检查noffMagic</p>
</li>
<li><p>计算所需空间大小</p>
<ul>
<li><p>size &#x3D; noffH.code.size + noffH.initData.size + noffH.uninitData.size + UserStackSize</p>
</li>
<li><p>代码段+初始化数据段+未初始化数据段+用户栈空间</p>
</li>
</ul>
</li>
<li><p>设置页表</p>
<ul>
<li>用于实现虚拟地址到物理地址的转换</li>
</ul>
</li>
<li><p>将整个地址空间置零, 包括未初始化数据段和栈段</p>
</li>
<li><p>将代码和数据段复制进入内存</p>
</li>
</ul>
<p>页表结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class TranslationEntry &#123;</span><br><span class="line">  public:</span><br><span class="line">    int virtualPage;      // 虚拟页号</span><br><span class="line">    int physicalPage;      // 物理页号</span><br><span class="line">    bool valid;         // 有效位</span><br><span class="line">            // 表示本页表项是否被初始化过</span><br><span class="line">    bool readOnly;    // 是否只读</span><br><span class="line">    bool use;           // 页被硬件引用或修改</span><br><span class="line">    bool dirty;         // 脏位</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要为页表项结构，记录本页的相关信息</p>
<h3 id="Nachos应用程序的启动过程"><a href="#Nachos应用程序的启动过程" class="headerlink" title="Nachos应用程序的启动过程"></a>Nachos应用程序的启动过程</h3><p>用户进程需要映射到核心进程才能得到执行：本质上是替换掉地址空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void StartProcess(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    OpenFile *executable = fileSystem-&gt;Open(filename);</span><br><span class="line">    AddrSpace *space;</span><br><span class="line"></span><br><span class="line">    if (executable == NULL) &#123;</span><br><span class="line">        printf(&quot;Unable to open file %s\n&quot;, filename);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将用户进程映射到核心进程</span><br><span class="line">    space = new AddrSpace(executable);    </span><br><span class="line">    currentThread-&gt;space = space;</span><br><span class="line"></span><br><span class="line">    delete executable;            // close file</span><br><span class="line"></span><br><span class="line">    space-&gt;InitRegisters();        // 设置初始寄存器值</span><br><span class="line">    space-&gt;RestoreState();        // 加载页表寄存器</span><br><span class="line"></span><br><span class="line">    machine-&gt;Run();            // 运行用户程序</span><br><span class="line">    ASSERT(FALSE);            // machine-&gt;Run 从不返回，若返回则必定错误</span><br><span class="line">                    // the address space exits</span><br><span class="line">                    // by doing the syscall &quot;exit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为使该核心线程能够执行用户进程的代码，需要核心在调度执行该线程时，根据用户进程的页表读取用户进程指令；</p>
<p>因此需要将用户页表首地址传递给核心的地址变换机构；（machine.h 中维护一个 pageTable 指针，指向当前正在 运行的 Nachos 应用 进程的页表）</p>
<p>如此一来，我们完成了</p>
<ul>
<li>文件的读取</li>
<li>内存的加载</li>
<li>用户进程映射到核心进程</li>
</ul>
<h3 id="上下文切换的完成"><a href="#上下文切换的完成" class="headerlink" title="上下文切换的完成"></a>上下文切换的完成</h3><p>为便于上下文切换时保存与恢复寄存器状态，Nachos 设置了两组寄存器，</p>
<ul>
<li>CPU 使用的寄存器 int registers[NumTotalRegs]（参见 Machine 类 in Machine.h），用于保存执行完一条机器指令时该指令的执行状态；</li>
<li>运行用户程序时使用的用户寄存器 int userRegisters[NumTotalRegs]，用户保存执行完一条用户程序指令后的寄存器状态（参见 Thread.h）；</li>
</ul>
<p>当用户进程进行上下文切换时（实质上是执行用户进程的核心线程发生上下文切换）</p>
<p>将老进程的 CPU 的寄存器状态保存到用户寄存器 userRegisters[]中</p>
<p>将新用户进程的寄存器状态恢复到 CPU 的寄存器中，以便 CPU 能够继续执行上次被中断的用户程序；参见 Scheduler::Run()中核心进程切换时对 CPU 寄存器与用户寄存器的保存与恢复；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Scheduler::Run (Thread *nextThread)</span><br><span class="line">&#123;</span><br><span class="line">    Thread *oldThread = currentThread;</span><br><span class="line"></span><br><span class="line">#ifdef USER_PROGRAM            //单独对用户进程进行的额外处理</span><br><span class="line">    if (currentThread-&gt;space != NULL) &#123;    // 如果进程为用户进程,</span><br><span class="line">        currentThread-&gt;SaveUserState(); // 保存用户的CPU寄存器到用户寄存器</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>若是用户进程</p>
<h3 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h3><p>machine::Run() （ .&#x2F;machine&#x2F;mipssim.cc 中 实 现 ）</p>
<p> 循环调用 Machine::OneInstruction(Instruction *instr) 执行程序指令，直到程序退出或遇到一个异常；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Machine::Run()</span><br><span class="line">&#123;</span><br><span class="line">    Instruction *instr = new Instruction;  // 存储指令</span><br><span class="line"></span><br><span class="line">    if(DebugIsEnabled(&#x27;m&#x27;))</span><br><span class="line">        printf(&quot;Starting thread \&quot;%s\&quot; at time %d\n&quot;,</span><br><span class="line">           currentThread-&gt;getName(), stats-&gt;totalTicks);</span><br><span class="line">        interrupt-&gt;setStatus(UserMode);</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        OneInstruction(instr); //运行一条指令</span><br><span class="line">        interrupt-&gt;OneTick(); // 中断完成一次跳动</span><br><span class="line">        if (singleStep &amp;&amp; (runUntilTime &lt;= stats-&gt;totalTicks))</span><br><span class="line">              Debugger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中指令的格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Instruction &#123;</span><br><span class="line">  public:</span><br><span class="line">    void Decode();    // 解码指令的二进制表示</span><br><span class="line"></span><br><span class="line">    unsigned int value; // 指令的二进制表示</span><br><span class="line"></span><br><span class="line">    char opCode;     // 指令类型  This is NOT the same as the 与opcode不同</span><br><span class="line">                 // opcode field from the instruction: see defs in mips.h</span><br><span class="line">    char rs, rt, rd; // 指令的三个寄存器</span><br><span class="line">    int extra;       // Immediate or target or shamt field or offset.</span><br><span class="line">                     // Immediates are sign-extended.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="机器硬件设置"><a href="#机器硬件设置" class="headerlink" title="机器硬件设置"></a>机器硬件设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define PageSize     SectorSize     // y</span><br><span class="line"></span><br><span class="line">#define NumPhysPages    64 //32</span><br><span class="line">#define MemorySize     (NumPhysPages * PageSize)</span><br><span class="line">#define TLBSize        4        // if there is a TLB, make it small</span><br></pre></td></tr></table></figure>

<h3 id="Address类分析"><a href="#Address类分析" class="headerlink" title="Address类分析"></a>Address类分析</h3><p>我们可以看到，在用户线程向核心线程映射的时候，最关键的数据结构就是Address了，它完成了页表、PCB等部件的功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class AddrSpace &#123;</span><br><span class="line">  public:</span><br><span class="line">    AddrSpace(OpenFile *executable);    // 创建一个地址空间</span><br><span class="line">                    // 用程序初始化它</span><br><span class="line">                    // stored in the file &quot;executable&quot;</span><br><span class="line">    ~AddrSpace();            // 收回分配的地址空间</span><br><span class="line"></span><br><span class="line">    void InitRegisters();        // 初始化用户级CPU寄存器</span><br><span class="line">                    // 在进入用户代码前</span><br><span class="line"></span><br><span class="line">    void SaveState();      // Save/restore address space-specific 保存或恢复特定                            // 地址空间</span><br><span class="line">    void RestoreState();        // 上下文切换信息</span><br><span class="line"></span><br><span class="line">    void Print();</span><br><span class="line">  private:</span><br><span class="line">    TranslationEntry *pageTable;    // 假设线性的地址转换</span><br><span class="line">    unsigned int numPages;        // 虚拟地址空间的页数</span><br><span class="line">                    // address space</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="备注-3"><a href="#备注-3" class="headerlink" title="备注"></a>备注</h2><p>void bzero（void *s, int n）；</p>
<p>头文件：#include &lt;string.h&gt;</p>
<p>功能：将字符串s的前n个字节置为0，一般来说n通常取sizeof(s),将整块空间清零。</p>
<p>返回值：无返回值</p>
<h1 id="实验7-地址空间的扩展"><a href="#实验7-地址空间的扩展" class="headerlink" title="实验7 地址空间的扩展"></a>实验7 地址空间的扩展</h1><h2 id="目的-4"><a href="#目的-4" class="headerlink" title="目的"></a>目的</h2><p>通过考察系统加载应用程序过程，如何为其分配内存空间、创建页表并建立虚页与实页帧的映射关系，理解 Nachos 的内存管理方法； </p>
<p>理解如何系统对空闲帧的管理； </p>
<p>理解如何加载另一个应用程序并为其分配地址空间，以支持多进程机制； </p>
<p>理解进程的 pid； </p>
<p>理解进程退出所要完成的工作；</p>
<h2 id="任务-4"><a href="#任务-4" class="headerlink" title="任务"></a>任务</h2><p>该实验与下一个实验（实验 8）可在目录..&#x2F;lab7-8 中完成，参照实验 2 介绍的方法将该实验中需要修改的模块、头文件，以及依赖这些头文件的模块复制到该目录中。 如将需要的模块从..&#x2F;userprog 目录复制到该目录中，还要复制 arch 目录及其子目录、Makefile、Makefile.local 等文件，并对 Makefile 及 Makefile.local 做相应 的修改。 该实验中，你需要完成： </p>
<p>（1）阅读..&#x2F;prog&#x2F;protest.cc，深入理解 Nachos 创建应用程序进程的详细过程 </p>
<p>（2）阅读理解类 AddrSpace，然后对其进行修改，使 Nachos 能够支持多进程机制，允许 Nachos 同时运行多个用户线程； </p>
<p>（3）在类 AddrSpace 中添加完善 Print()函数（在实验 6 中已经给出） </p>
<p>（4）在类 AddrSpace 中实例化类 Bitmap 的一个全局对象，用于管理空闲帧； </p>
<p>（5）如果将 SpaceId 直接作为进程号 Pid 是否合适？如果感觉不是很合适， 应该如何为进程分配相应的 pid？ </p>
<p>（6）为实现 Join(pid)，考虑如何在该进程相关联的核心线程中保存进程号； </p>
<p>（7）根据进程创建时系统为其所做的工作，考虑进程退出时应该做哪些工 作； </p>
<p>（8）考虑系统调用 Exec()与 Exit()的设计实现方案； </p>
<p>（9）拓 展 ： 可 以 进 一 步 考 虑 如 何 添 加 自 己 所 需 要 的 系 统 调 用 ，即..&#x2F;userprog&#x2F;syscall.h 中没有定义的系统调用，如 Time，以获取当前的系统时间。</p>
<h2 id="实验过程-2"><a href="#实验过程-2" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="修改makefile文件"><a href="#修改makefile文件" class="headerlink" title="修改makefile文件"></a>修改makefile文件</h3><p>首先将文件夹userprog下的文件复制到lab7-8中，修改makefile文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include ../threads/Makefile.local</span><br><span class="line"># include ../filesys/Makefile.local</span><br><span class="line"># include ../lab5/Makefile.local</span><br><span class="line">include ../lab7-8/Makefile.local</span><br><span class="line">include ../Makefile.dep</span><br><span class="line">include ../Makefile.common</span><br></pre></td></tr></table></figure>

<p>这样文件在make的时候就会将lab7-8中的文件编译进去</p>
<h3 id="进程的创建过程"><a href="#进程的创建过程" class="headerlink" title="进程的创建过程"></a>进程的创建过程</h3><p>由于我们已知Nachos系统调用startprocess实现装入并运行noff可执行程序，顺序为</p>
<p>启动应用程序的过程startProcess</p>
<ul>
<li><p>获取OpenFile打开文件：OpenFile &#x3D; fileSystem-&gt;Open(filename)</p>
</li>
<li><p>通过OpenFile获取AddrSpace：space &#x3D; new AddrSpace(Opnefile);</p>
</li>
<li><p>用户进程映射到核心进程currentThread-&gt;space &#x3D; space; </p>
</li>
<li><p>Machine初始化</p>
<ul>
<li>AddrSpace初始化寄存器</li>
<li>AddrSpace加载页表寄存器</li>
</ul>
</li>
<li><p>运行用户程序：Machine-&gt;Run()</p>
</li>
</ul>
<p>在这个过程中我们发现，&#x3D;&#x3D;可执行程序的管理是通过AddrSpace进行管理&#x3D;&#x3D;</p>
<p>然后看AddrSpace的初始化过程</p>
<h3 id="AddrSpace初始化"><a href="#AddrSpace初始化" class="headerlink" title="AddrSpace初始化"></a>AddrSpace初始化</h3><p>初始化过程</p>
<ul>
<li>创建用户程序页表，完成虚拟地址到物理地址的映射</li>
<li>将noff文件数据复制进入Machine内存中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pageTable = new TranslationEntry[numPages];</span><br><span class="line">    for (i = 0; i &lt; numPages; i++) &#123;</span><br><span class="line">	    pageTable[i].virtualPage = i;	</span><br><span class="line">	    pageTable[i].physicalPage = i; //此时虚拟页号等于物理页号</span><br><span class="line"></span><br><span class="line">	    pageTable[i].valid = TRUE;</span><br><span class="line">	    pageTable[i].use = FALSE;</span><br><span class="line">	    pageTable[i].dirty = FALSE;</span><br><span class="line">	    pageTable[i].readOnly = FALSE;  // 设置文件权限</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意这块代码，用户程序页表初始化时，i号虚拟页号直接对应于machine内存中的i号物理页号，这导致所有的noff可执行程序都会映射到0～n号内存页号，这导致了Nachos无法执行多个用户程序</p>
<p>同时注意后面的将可执行程序复制进入内存时默认内存是连续分配的，这可能会导致错误</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>由于我们需要在Nachos同时运行多个用户程序，所以需要内存中同时装入多个进程，并通过SpaceId对进程进行管理，由于内存使用分页进行管理，所以需要一个BitMap对页面进行管理。</p>
<p>由于SpaceId只有标记线程的作用，我选择使用一个100+的int数字（0～99用于核心线程的标记）来进行标志。将SpaceId用作pid并不十分合理，因为这没有直接索引PCB的功能，&#x3D;&#x3D;可以考虑使用addrspace的地址来当作Pid，存储在thread类中&#x3D;&#x3D;，但由于我们并没有实现pcb，所以意义并不大</p>
<ul>
<li>static BitMap *physmap 用于标记主存页面是否使用</li>
<li>static BitMap *pidmap  用于标记SpaceId是否适用</li>
</ul>
<h3 id="源代码修改"><a href="#源代码修改" class="headerlink" title="源代码修改"></a>源代码修改</h3><h4 id="addrspace-h"><a href="#addrspace-h" class="headerlink" title="addrspace.h"></a>addrspace.h</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static BitMap *physmap,*pidmap; //页表位示图，记录已分配页表  线程SpaceId分配情况</span><br><span class="line">								//static只定义一次</span><br><span class="line"></span><br><span class="line">AddrSpace添加成员变量</span><br><span class="line">int SpaceId;</span><br></pre></td></tr></table></figure>



<h4 id="AddrSpace-AddrSpace-OpenFile-executable"><a href="#AddrSpace-AddrSpace-OpenFile-executable" class="headerlink" title="AddrSpace::AddrSpace(OpenFile *executable)"></a>AddrSpace::AddrSpace(OpenFile *executable)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">AddrSpace::AddrSpace(OpenFile *executable)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //设置SpaceId，初始化physmap和pidmap</span><br><span class="line">    if(physmap==NULL)&#123;</span><br><span class="line">        physmap=new BitMap(NumPhysPages);</span><br><span class="line">    &#125;</span><br><span class="line">    if(pidmap==NULL)&#123;</span><br><span class="line">        pidmap=new BitMap(MAX_USERPROCESSES);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(pidmap-&gt;NumClear()&gt;1);//保证还有线程号可分</span><br><span class="line">    SpaceId = pidmap-&gt;Find()+100;//0~99号线程为核心线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NoffHeader noffH;</span><br><span class="line">    unsigned int i, size;</span><br><span class="line"></span><br><span class="line">    executable-&gt;ReadAt((char *)&amp;noffH, sizeof(noffH), 0);  //读入文件头</span><br><span class="line">    if ((noffH.noffMagic != NOFFMAGIC) &amp;&amp; </span><br><span class="line">		(WordToHost(noffH.noffMagic) == NOFFMAGIC))</span><br><span class="line">    	SwapHeader(&amp;noffH);</span><br><span class="line">    ASSERT(noffH.noffMagic == NOFFMAGIC);</span><br><span class="line"></span><br><span class="line">// how big is address space?</span><br><span class="line">    size = noffH.code.size + noffH.initData.size + noffH.uninitData.size </span><br><span class="line">			+ UserStackSize;	// we need to increase the size</span><br><span class="line">						// to leave room for the stack</span><br><span class="line">    numPages = divRoundUp(size, PageSize);</span><br><span class="line">    size = numPages * PageSize;</span><br><span class="line"></span><br><span class="line">    ASSERT(numPages &lt;= NumPhysPages);		// 确认文件大小可运行</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;a&#x27;, &quot;Initializing address space, num pages %d, size %d\n&quot;, </span><br><span class="line">					numPages, size);</span><br><span class="line">// first, set up the translation </span><br><span class="line">    pageTable = new TranslationEntry[numPages];</span><br><span class="line">    for (i = 0; i &lt; numPages; i++) &#123;</span><br><span class="line">	    pageTable[i].virtualPage = i;	</span><br><span class="line">	    pageTable[i].physicalPage = physmap-&gt;Find();   //找第一个空闲页表分配</span><br><span class="line">        ASSERT(pageTable[i].physicalPage!=-1);</span><br><span class="line"></span><br><span class="line">	    pageTable[i].valid = TRUE;</span><br><span class="line">	    pageTable[i].use = FALSE;</span><br><span class="line">	    pageTable[i].dirty = FALSE;</span><br><span class="line">	    pageTable[i].readOnly = FALSE;  // if the code segment was entirely on </span><br><span class="line">					// a separate page, we could set its </span><br><span class="line">					// pages to be read-only</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// zero out the entire address space, to zero the unitialized data segment </span><br><span class="line">// and the stack segment</span><br><span class="line">    //bzero(machine-&gt;mainMemory, size);</span><br><span class="line"></span><br><span class="line">// 将可执行文件读如内存，修改源代码</span><br><span class="line">    if(noffH.code.size&gt;0)&#123;</span><br><span class="line">        int pagePos = pageTable[noffH.code.virtualAddr/PageSize].physicalPage*PageSize;</span><br><span class="line">        int offSet = noffH.code.virtualAddr%PageSize;</span><br><span class="line">        </span><br><span class="line">        //默认扇区分配是连续的</span><br><span class="line">        executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[pagePos+offSet]),</span><br><span class="line">            noffH.code.size,noffH.code.inFileAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    if(noffH.initData.size&gt;0)&#123;</span><br><span class="line">        int pagePos = pageTable[noffH.initData.virtualAddr/PageSize].physicalPage*PageSize;</span><br><span class="line">        int offSet = noffH.initData.virtualAddr%PageSize;</span><br><span class="line"></span><br><span class="line">        executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[pagePos+offSet]),</span><br><span class="line">            noffH.initData.size,noffH.initData.inFileAddr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AddrSpace-AddrSpace"><a href="#AddrSpace-AddrSpace" class="headerlink" title="AddrSpace::~AddrSpace()"></a>AddrSpace::~AddrSpace()</h4><p>释放占用的SpaceId和内存占用的页面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AddrSpace::~AddrSpace()</span><br><span class="line">&#123;</span><br><span class="line">    pidmap-&gt;Clear(SpaceId-100);</span><br><span class="line">    for(int i=0;i&lt;numPages;i++ )&#123;</span><br><span class="line">        physmap-&gt;Clear(pageTable[i].physicalPage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete [] pageTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AddrSpace-Print"><a href="#AddrSpace-Print" class="headerlink" title="AddrSpace::Print()"></a>AddrSpace::Print()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void AddrSpace::Print() &#123;</span><br><span class="line">    printf(&quot;page table dump: %d pages in total\n&quot;,numPages);</span><br><span class="line">    printf(&quot;============================================\n&quot;);</span><br><span class="line">    printf(&quot;\tVirtPage, \tPhysPage\n&quot;);</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; numPages; i++)</span><br><span class="line">        printf(&quot;\t%d,\t\t%d\n&quot;,pageTable[i].virtualPage,pageTable[i].physicalPage);</span><br><span class="line">    printf(&quot;============================================\n\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="考虑系统调用-Exec-与-Exit-的设计实现方案；"><a href="#考虑系统调用-Exec-与-Exit-的设计实现方案；" class="headerlink" title="考虑系统调用 Exec()与 Exit()的设计实现方案；"></a>考虑系统调用 Exec()与 Exit()的设计实现方案；</h4><p>见实验八</p>
<h2 id="备注-4"><a href="#备注-4" class="headerlink" title="备注"></a>备注</h2><p>内存大小定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define NumPhysPages    64 //32</span><br><span class="line">#define MemorySize 	(NumPhysPages * PageSize)</span><br></pre></td></tr></table></figure>

<p>make时显示，全局变量重复定义问题</p>
<p>使用static进行定义</p>
<h1 id="实验八"><a href="#实验八" class="headerlink" title="实验八"></a>实验八</h1><h2 id="目的-5"><a href="#目的-5" class="headerlink" title="目的"></a>目的</h2><p>理解用户进程是如何通过系统调用与操作系统内核进行交互的；<br>理解系统调用是如何实现的；<br>理解系统调用参数传递与返回数据的回传机制；<br>理解核心进程如何调度执行应用程序进程；<br>理解进程退出后如何释放内存等为其分配的资源；<br>理解进程号 pid 的含义与使用；</p>
<h2 id="任务-5"><a href="#任务-5" class="headerlink" title="任务"></a>任务</h2><ul>
<li><p>阅读..&#x2F;userprog&#x2F;exception.cc，理解系统调用 Halt()的实现原理；</p>
</li>
<li><p>基于实现 6、7 中所完成的工作，利用 Nachos 提供的文件管理、内存管理及线程管理等功能，编程实现系统调用 Exec()与 Exit()（至少实现这两个）。</p>
</li>
</ul>
<h3 id="系统调用宏定义"><a href="#系统调用宏定义" class="headerlink" title="系统调用宏定义"></a>系统调用宏定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define SC_Halt        0</span><br><span class="line">#define SC_Exit        1</span><br><span class="line">#define SC_Exec        2</span><br><span class="line">#define SC_Join        3</span><br><span class="line">#define SC_Create      4</span><br><span class="line">#define SC_Open        5</span><br><span class="line">#define SC_Read        6</span><br><span class="line">#define SC_Write       7</span><br><span class="line">#define SC_Close       8</span><br><span class="line">#define SC_Fork        9</span><br><span class="line">#define SC_Yield       10</span><br></pre></td></tr></table></figure>

<p>汇编语言</p>
<p>汇编语言有助于使系统调用对Nachos内核</p>
<p>寄存器</p>
<p>2，3：存放返回值</p>
<p>4，5，6，7：存放传递参数</p>
<h2 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h2><p>Machine::OneInstruction(Instruction *instr)中有一个非常大的 SWITCH 语句，该语句分析所取出的指令类型执行这条指令</p>
<p>在 mipssim.cc 中 Machine::OneInstruction(Instruction *instr)的 switch 语句，对 Nachos 系统调用的处理方法是当 Nachos 的 CPU 检测到该条指令是执行一个 Nachos 的系统调用，则抛出一个异常 SyscallException 以便从用户态陷入到核心态去处理这个系统调用，代码如下：：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case OP_SYSCALL:</span><br><span class="line">    RaiseException(SyscallException, 0);</span><br><span class="line">    return;</span><br></pre></td></tr></table></figure>

<p>该异常 SyscallException 在..&#x2F;userprog&#x2F;exception.cc 中进行处理，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void ExceptionHandler(ExceptionType which)</span><br><span class="line">&#123;</span><br><span class="line">    int type = machine-&gt;ReadRegister(2);</span><br><span class="line">    if ((which == SyscallException) &amp;&amp; (type == SC_Halt)) &#123;</span><br><span class="line">        DEBUG(&#x27;a&#x27;, &quot;Shutdown, initiated by user program.\n&quot;);</span><br><span class="line">        interrupt-&gt;Halt();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Unexpected user mode exception %d %d\n&quot;, which, type);</span><br><span class="line">        ASSERT(FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此需要参照..&#x2F;userprog&#x2F;exception.cc 中对 Halt()的处理方法编写其它系统调用的处理代码。</p>
<h2 id="Nachso系统调用参数传递"><a href="#Nachso系统调用参数传递" class="headerlink" title="Nachso系统调用参数传递"></a>Nachso系统调用参数传递</h2><p>一般参数传递有三种方式：<br>（a）通过寄存器；<br>（b）通过内存区域，将该内存区域的首地址存放在一个寄存器中；<br>（c）通过栈；<br>&#x3D;&#x3D;在基于 MIPS 架构中，对于一般的函数调用，一般利用$4-$7（4 到 7 号寄存器）传递函数的前四个参数给子程序，参数多于 4 个时，其余的利用堆栈进行传递；&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;返回值利用2、3号寄存器存储函数的返回值，当这两个寄存器不够存放返回值时，通过内存来完成&#x3D;&#x3D;</p>
<blockquote>
<p>当字符串作为参数时的传递方式，这时寄存器中保存的是字符串在内存中的地址</p>
</blockquote>
<p>例如，当从内存中拿出字符串时，常用的操作为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char filename[50];  //声名字符串数组</span><br><span class="line">int addr=machine-&gt;ReadRegister(4); //从4号寄存器中取出首地址</span><br><span class="line">int i=0;</span><br><span class="line">do&#123;</span><br><span class="line">    //从内存中读出文件名，以&#x27;\0&#x27;为结尾</span><br><span class="line">    machine-&gt;ReadMem(addr+i,1,(int*)&amp;filename[i]);</span><br><span class="line">&#125;while(filename[i++]!=&#x27;\0&#x27;);</span><br></pre></td></tr></table></figure>



<h2 id="编写自己的Nachos应用程序"><a href="#编写自己的Nachos应用程序" class="headerlink" title="编写自己的Nachos应用程序"></a>编写自己的Nachos应用程序</h2><p>当我们实现了Nachos的系统调用后，可以编写一些Nachos应用程序以测试Nachos的相应功能。</p>
<p>可以采用以下方法步骤</p>
<ul>
<li>按照类C语言的语法以及Nachos所提供的系统调用（详情可查看&#x2F;userprog&#x2F;syscall.h），编写文件exec.c保存到..&#x2F;test目录中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int pid;</span><br><span class="line">    int pid2;</span><br><span class="line">    int pid3;</span><br><span class="line">    pid = Exec(&quot;exit&quot;);</span><br><span class="line">    pid2 = Exec(&quot;exit&quot;);</span><br><span class="line">    Join(pid);</span><br><span class="line">    pid3 = Exec(&quot;exit&quot;);</span><br><span class="line">    Join(pid3);</span><br><span class="line">    Join(pid2);</span><br><span class="line">    Halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将exec.c交叉编译并转化成Nachos模拟的CPU可执行程序exec.noff，将exec.c添加到..&#x2F;test&#x2F;Makefile的target列表中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># User programs.  Add your own stuff here. </span><br><span class="line"># </span><br><span class="line"># Note:  The convention is that there is exactly one .c file per target.</span><br><span class="line">#        The target is built by compiling the .c file and linking the </span><br><span class="line">#        corresponding .o with start.o.  If you want to have more than</span><br><span class="line">#        one .c file per target, you will have to change stuff below.</span><br><span class="line"></span><br><span class="line">targets = filetest yield exit exec halt shell matmult sort cat</span><br></pre></td></tr></table></figure>

<ul>
<li>运行make，生成exec.noff</li>
</ul>
<h2 id="系统调用的解决"><a href="#系统调用的解决" class="headerlink" title="系统调用的解决"></a>系统调用的解决</h2><p>修改ExceptionHandler(ExceptionType which)函数，便于我们进行扩展</p>
<p>每一个新的系统调用单独写一个函数来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void ExceptionHandler(ExceptionType which)</span><br><span class="line">&#123;</span><br><span class="line">    int type = machine-&gt;ReadRegister(2);</span><br><span class="line"></span><br><span class="line">    if (which == SyscallException) &#123;</span><br><span class="line">	    switch (type)&#123;</span><br><span class="line">            case SC_Halt:&#123;</span><br><span class="line">                DEBUG(&#x27;a&#x27;, &quot;Shutdown, initiated by user program.\n&quot;);</span><br><span class="line">   	            interrupt-&gt;Halt();</span><br><span class="line">            &#125;</span><br><span class="line">            case SC_Exit:&#123;</span><br><span class="line">                exit();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case SC_Exec:&#123;</span><br><span class="line">                exec();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case SC_Join:&#123;</span><br><span class="line">                Join();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ······</span><br><span class="line">            </span><br><span class="line">            default:&#123;</span><br><span class="line">                printf(&quot;Unexpected syscal %d %d\n&quot;,which,type);</span><br><span class="line">                AdvancePC();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">	    printf(&quot;Unexpected user mode exception %d %d\n&quot;, which, type);</span><br><span class="line">	    ASSERT(FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AdvancePC"><a href="#AdvancePC" class="headerlink" title="AdvancePC()"></a>AdvancePC()</h2><p><code>../machine/ mipssim.cc</code> 中的成员函数 <code>void Machine::OneInstruction(Instruction  *instr)</code>，从 Nachos 的内存中取出并执行一条 Nachos 应用程序的指令。其中 有一个非常大的 switch 语句，是分析所取出的指令类型执行这条指令 （Nachos 的指令类型见..&#x2F;machine&#x2F; mipssim.h）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Machine::<span class="built_in">OneInstruction</span>(Instruction *instr)</span><br><span class="line">&#123;</span><br><span class="line">	 ……..</span><br><span class="line">	<span class="keyword">switch</span> (instr-&gt;opCode) &#123;</span><br><span class="line">		<span class="keyword">case</span> OP_ADD:</span><br><span class="line">			…..</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line">		……..</span><br><span class="line">		<span class="keyword">case</span> OP_SYSCALL:</span><br><span class="line">			<span class="built_in">RaiseException</span>(SyscallException, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		………</span><br><span class="line"> 		<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">ASSERT</span>(FALSE);</span><br><span class="line">&#125; <span class="comment">// switch (instr-&gt;opCode) </span></span><br><span class="line"> <span class="comment">// 现在已经成功执行了指令</span></span><br><span class="line"> <span class="comment">// 进行延迟加载操作</span></span><br><span class="line"> <span class="built_in">DelayedLoad</span>(nextLoadReg, nextLoadValue);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 增加程序计数器</span></span><br><span class="line">registers[PrevPCReg] = registers[PCReg];</span><br><span class="line">registers[PCReg] = registers[NextPCReg];</span><br><span class="line"> registers[NextPCReg] = pcAfter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    从中可以看出，当一条指令正常执行结束后，需要将 PC 推进，指向下 一条指令，但 case OP_SYSCALL:中，RaiseException(SyscallException, 0);后 不是一条 break 语句，而是一条 return 语句，原因是通常情况下，当处理完 一个异常后需要重启这条指令。但系统调用异常是个特例，异常处理结束后指令不需要重启。</p>
<p>处理方式，以在 exception.cc 模块中添加如下 PC 推进代码，并在 你的各系统调用处理程序最后调用函数 AdvancePC()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void AdvancePC()&#123;</span><br><span class="line">    machine-&gt;WriteRegister(PrevPCReg,machine-&gt;ReadRegister(PCReg));	</span><br><span class="line">    machine-&gt;WriteRegister(PCReg,machine-&gt;ReadRegister(NextPCReg));</span><br><span class="line">    machine-&gt;WriteRegister(NextPCReg,machine-&gt;ReadRegister(NextPCReg)+4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="系统调用Exec的实现思路"><a href="#系统调用Exec的实现思路" class="headerlink" title="系统调用Exec的实现思路"></a>系统调用Exec的实现思路</h2><p>Exec(char * filename) 系统调用的功能：加载运行应用程序filename</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ul>
<li>从 4 号寄存器中可以获取 Exec() 的参数 filename 在内存中的地址（addr &#x3D; machine-&gt;ReadRegister(4)）</li>
<li>利用 Machine::ReadMem() 从该地址读取应用程序文件名 filename</li>
<li>打开该应用程序（OpenFile *executable &#x3D; fileSystem-&gt;Open(filename)）</li>
<li>为其分配内存空间、创建页表、分配 pid（space &#x3D; new AddrSpace(executable)），至此为应用程序创建了一个进程。<ul>
<li>在 AddrSpace 类中我们需要为进程分配 pid 以及对空闲帧进行管理，在进程退出时需要释放 pid，并释放为其所分配的帧，详情请见实验七</li>
</ul>
</li>
<li>创建一个核心线程，并将该进程与新建的核心线程关联（thread &#x3D; new Thread(forkedThreadName)），thread-&gt;Fork(StartProcess,space-&gt;getSpace(ID))<ul>
<li>将该应用程序映射到核心线程，以执行应用程序 filename。</li>
<li>重载StartProcess(int spaceId)，新函数</li>
</ul>
</li>
<li>返回进程的SpaceId，machine-&gt;WriteRegister(2,space-&gt;getSpaceId());</li>
<li>PC增量</li>
</ul>
<h3 id="重载StartProcess-int-spaceId"><a href="#重载StartProcess-int-spaceId" class="headerlink" title="重载StartProcess(int spaceId)"></a>重载StartProcess(int spaceId)</h3><p>StartProcess函数定义在exeption.cc中以便于Thread::Fork()找到</p>
<p>该函数作为Fork()出来的新线程的执行体，调度到新线程时，便会运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void StartProcess(int spaceId)&#123;</span><br><span class="line">    currentThread-&gt;space-&gt;InitRegisters(); //设置寄存器初值</span><br><span class="line">    currentThread-&gt;space-&gt;RestoreState();   //加载页表寄存器</span><br><span class="line"></span><br><span class="line">    machine-&gt;Run();       //进入用户程序</span><br><span class="line">    ASSERT(FALSE);         //machine-&gt;Run从不返回，返回代表出错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改AddrSpace"><a href="#修改AddrSpace" class="headerlink" title="修改AddrSpace"></a>修改AddrSpace</h3><p>详情见实验七</p>
<h3 id="修改源代码"><a href="#修改源代码" class="headerlink" title="修改源代码"></a>修改源代码</h3><p>根据exec执行流程我们可以写出对应代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exec</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nExecute system call of Exec()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> filename[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> addr=machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">//从内存中读出文件名</span></span><br><span class="line">        machine-&gt;<span class="built_in">ReadMem</span>(addr+i,<span class="number">1</span>,(<span class="type">int</span>*)&amp;filename[i]);</span><br><span class="line">    &#125;<span class="keyword">while</span>(filename[i++]!=<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Exec(%s):\n&quot;</span>,filename);</span><br><span class="line"></span><br><span class="line">    OpenFile *executable = fileSystem-&gt;<span class="built_in">Open</span>(filename);</span><br><span class="line">    <span class="keyword">if</span>(executable==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to open file %s\n&quot;</span>,filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddrSpace *space = <span class="keyword">new</span> <span class="built_in">AddrSpace</span>(executable);</span><br><span class="line">    <span class="keyword">delete</span> executable;</span><br><span class="line">    <span class="type">char</span> *forkedThreadName=filename;</span><br><span class="line">    Thread* thread = <span class="keyword">new</span> <span class="built_in">Thread</span>(forkedThreadName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new Thread, SpaceId: %d, Name: %s\n&quot;</span>,space-&gt;<span class="built_in">getSpaceId</span>(),filename);</span><br><span class="line"></span><br><span class="line">    thread-&gt;<span class="built_in">initSpace</span>(space); <span class="comment">//用户线程映射到核心线程</span></span><br><span class="line">    <span class="comment">//thread-&gt;space-&gt;Print();</span></span><br><span class="line">    thread-&gt;<span class="built_in">Fork</span>(StartProcess,space-&gt;<span class="built_in">getSpaceId</span>()); <span class="comment">//fork一个新的核心线程</span></span><br><span class="line"></span><br><span class="line">    machine-&gt;<span class="built_in">WriteRegister</span>(<span class="number">2</span>,space-&gt;<span class="built_in">getSpaceId</span>());</span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Join的实现"><a href="#Join的实现" class="headerlink" title="Join的实现"></a>Join的实现</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>系统调用 int Join(SpaceId)的功能类似于 Pthread 中的 pthread_join(tid)和 UNXI 系统调用 wait()的功能，int Join(SpaceId id)的功能是调用 Join(SpaceId  id)的程序等待进程 id 结束，当进程 id 结束后，Join()返回进程 id 的退出状态 （退出码）。</p>
<h3 id="在thread类中实现Join"><a href="#在thread类中实现Join" class="headerlink" title="在thread类中实现Join"></a>在thread类中实现Join</h3><ul>
<li><p>在thread.cc中添加函数Join(int spaceId)，系统调用int Join(int spaceId) 通过调用 Thread::Join()实现； </p>
</li>
<li><p>在 Scheduler::Scheduler()中初始化</p>
<ul>
<li>线程等待队列waitingList</li>
<li>线程终止队列terminatedList，将所有的线程在调用 Finish()后先进入该队列，再伺机销毁</li>
</ul>
</li>
<li><p>通过检查 terminated 队列以确定一个线程是否已经终止 （通过 Joinee 的 SpaceId 与 Joiner 所等待的 SpaceId 确定线程的身份）</p>
</li>
<li><p>如果 Joinee 不在 terminated 队列，说明其尚未终止，则 Joiner 进入睡眠 队列 waitingList，当 Joinee 退出调用 Finish()时通过检查 waitingList 以确定 是否需要唤醒 Joiner。</p>
</li>
<li><p>当 Joiner 被唤醒后，需要从 terminated 队列移除 Joinee 并将其销毁，然后返回 Joinee 的退出</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">	participant Join</span><br><span class="line">	participant terminatedList</span><br><span class="line">	participant waitingList</span><br><span class="line">	Join--&gt;&gt;terminatedList:Join(spaceId):确定Joinee是否在终止队列中</span><br><span class="line">	Join-&gt;&gt;waitingList:Joinee不在终止队列中，CurrentThread加入等待队列</span><br><span class="line">    Join--&gt;&gt;Join:Joinee在终止队列中或本进程被唤醒，在终止队列中删除Joinee，继续运行</span><br></pre></td></tr></table></figure>

<h3 id="在thread类中修改finish"><a href="#在thread类中修改finish" class="headerlink" title="在thread类中修改finish"></a>在thread类中修改finish</h3><ul>
<li>本函数主要功能是将子线程放入终止队列并唤醒 Join() 它的父线程</li>
</ul>
<p>执行流程</p>
<ul>
<li>本线程运行结束，调用finish()进入线程结束处理</li>
<li>检查Joiner是否在等待队列中，即等待队列中是否有线程等待本线程运行结束<ul>
<li>若有则唤醒之&#96;&#96;scheduler-&gt;ReadyToRun((Thread *)thread);&#96;</li>
</ul>
</li>
<li>将本线程加入终结队列<code>Terminated();</code></li>
</ul>
<h3 id="在thread类中实现terminated"><a href="#在thread类中实现terminated" class="headerlink" title="在thread类中实现terminated()"></a>在thread类中实现terminated()</h3><p>主要功能为将终止进程加入终止队列</p>
<p>执行流程</p>
<ul>
<li>在终结队列中加入本进程</li>
<li>找到下一个可运行进程运行</li>
</ul>
<p>这里会出现一个问题，就是并不是所有子线程都会被 Join()，但是上述操作却在所有进程 Finish 的时候，将它们丢进了 terminated 队列，因此这些没有被 Join() 的子线程会一直留在 terminated 队列中不会被销毁。</p>
<p>通常来说，我们应该当父进程退出时来将这些未被 Join() 的子线程销毁，但 Nachos 中并没有记录进程的家族关系，难以标识父进程。因此临时的解决方案是，为父进程设置特殊的退出码，在 Exit() 中识别父进程，并由父进程负责销毁 terminated 队列中的所有线程。但该方案还是存在问题，即 terminated 队列中可能存在不属于该父进程的子进程，但被该父进程一并销毁。导致其真正的父进程在 Join() 这个子进程时无法找到该子进程。</p>
<h3 id="源代码修改-1"><a href="#源代码修改-1" class="headerlink" title="源代码修改"></a>源代码修改</h3><p>修改Schedule类，增加函数调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Scheduler</span>();			<span class="comment">// Initialize list of ready threads </span></span><br><span class="line">    ~<span class="built_in">Scheduler</span>();			<span class="comment">// De-allocate ready list</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReadyToRun</span><span class="params">(Thread* thread)</span></span>;	<span class="comment">// Thread can be dispatched.</span></span><br><span class="line">    <span class="function">Thread* <span class="title">FindNextToRun</span><span class="params">()</span></span>;		<span class="comment">// Dequeue first thread on the ready </span></span><br><span class="line">					<span class="comment">// list, if any, and return thread.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(Thread* nextThread)</span></span>;	<span class="comment">// Cause nextThread to start running</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;			<span class="comment">// Print contents of ready list</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    List *readyList;  		<span class="comment">// queue of threads that are ready to run,</span></span><br><span class="line">				<span class="comment">// but not running</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USER_PROGRAM</span></span><br><span class="line">    List *waitingList;</span><br><span class="line">    List *terminatedList;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">List *<span class="title">getReadyList</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> readyList; &#125;</span><br><span class="line">    <span class="function">List *<span class="title">getWaitingList</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> waitingList;&#125;</span><br><span class="line">    <span class="function">List *<span class="title">getTerminatedList</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> terminatedList;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DeletTerminatedThread</span><span class="params">(<span class="type">int</span> deleteSpaceId)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">emptyList</span><span class="params">(List *deleteList)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scheduler::<span class="built_in">Scheduler</span>()</span><br><span class="line">&#123; </span><br><span class="line">    readyList = <span class="keyword">new</span> List; </span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> USER_PROGRAM</span></span><br><span class="line">    waitingList = <span class="keyword">new</span> List;</span><br><span class="line">    terminatedList = <span class="keyword">new</span> List;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>修改exception，增加函数调用处理程序，主要是调用thread-&gt;Join(spaceId)进行实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Join</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nExecute system call of Join()\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> SpaceId = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread:%d wait Thread %d\n&quot;</span>,currentThread&gt;<span class="built_in">userProgramId</span>(),SpaceId);</span><br><span class="line">    currentThread-&gt;<span class="built_in">Join</span>(SpaceId);</span><br><span class="line">    <span class="comment">//waitProcessExitCode 返回Joinee的退出码</span></span><br><span class="line">    machine-&gt;<span class="built_in">WriteRegister</span>(<span class="number">2</span>,currentThread-&gt;<span class="built_in">waitExitCode</span>());</span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加void <strong>Thread</strong>::<strong>Join</strong>(int SpaceId)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::Join</span><span class="params">(<span class="type">int</span> SpaceId)</span></span>&#123;</span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);  <span class="comment">//涉及线程切换，要先关中断</span></span><br><span class="line">    waitProcessSpaceId = SpaceId;       <span class="comment">//设置当前进程所等待的进程id</span></span><br><span class="line">    <span class="comment">//获取终止队列和等待队列</span></span><br><span class="line">    List *terminatedList = scheduler-&gt;<span class="built_in">getTerminatedList</span>(); </span><br><span class="line">    List *waitingList = scheduler-&gt;<span class="built_in">getWaitingList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定Joinee是否在终止队列中</span></span><br><span class="line">    <span class="type">bool</span> interminatedList = FALSE;</span><br><span class="line">    ListElement *first = terminatedList-&gt;<span class="built_in">listFirst</span>();</span><br><span class="line">    <span class="keyword">while</span>(first!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        Thread *thread = (Thread*)first-&gt;item; <span class="comment">//强制类型转换</span></span><br><span class="line">        <span class="keyword">if</span>(thread-&gt;<span class="built_in">userProgramId</span>()==SpaceId)&#123;</span><br><span class="line">            interminatedList = <span class="literal">true</span>;</span><br><span class="line">            waitProcessExitCode = thread-&gt;exitCode; <span class="comment">//父线程等待子线程退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若所等待的进程不在终止队列中，阻塞当前进程</span></span><br><span class="line">    <span class="keyword">if</span>(!interminatedList)&#123;</span><br><span class="line">        waitingList-&gt;<span class="built_in">Append</span>((<span class="type">void</span>*)<span class="keyword">this</span>);</span><br><span class="line">        currentThread-&gt;<span class="built_in">Sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//被唤醒或Joinee在终止队列中，在终止队列中删除Joinee</span></span><br><span class="line">    scheduler-&gt;<span class="built_in">DeletTerminatedThread</span>(SpaceId);</span><br><span class="line">    (<span class="type">void</span>)interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加函数void <strong>Thread</strong>::<strong>Terminated</strong>()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::Terminated</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//功能与sleep差不多，将终止进程加入终止队列</span></span><br><span class="line">    List *terminatedList = scheduler-&gt;<span class="built_in">getTerminatedList</span>();</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="keyword">this</span> == currentThread);</span><br><span class="line">    <span class="built_in">ASSERT</span>(interrupt-&gt;<span class="built_in">getLevel</span>()==IntOff);</span><br><span class="line">    status = TERMINATED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf(&quot;currentThread:%d\n&quot;,userSpaceId);</span></span><br><span class="line">    <span class="comment">//terminatedList-&gt;show();</span></span><br><span class="line">    terminatedList-&gt;<span class="built_in">Append</span>((<span class="type">void</span>*)<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;join terminatedList SpaceId %d\n&quot;,userProgramId());</span></span><br><span class="line">    <span class="comment">//terminatedList-&gt;show();</span></span><br><span class="line">    <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">    Thread *nextThread = scheduler-&gt;<span class="built_in">FindNextToRun</span>();</span><br><span class="line">    <span class="keyword">while</span>(nextThread == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        interrupt-&gt;<span class="built_in">Idle</span>();</span><br><span class="line">        nextThread = scheduler-&gt;<span class="built_in">FindNextToRun</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    scheduler-&gt;<span class="built_in">Run</span>(nextThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改函数<strong>Thread</strong>::<strong>Finish</strong> ()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::Finish</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="type">void</span>) interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);		</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="keyword">this</span> == currentThread);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USER_PROGRAM</span></span><br><span class="line">    <span class="comment">//运行结束，获取退出码</span></span><br><span class="line">    exitCode = currentThread-&gt;<span class="built_in">getExitStatus</span>();</span><br><span class="line">    <span class="comment">//joinee结束，尝试唤醒Joiner</span></span><br><span class="line">    List *ReadyList = scheduler-&gt;<span class="built_in">getReadyList</span>();</span><br><span class="line">    List *waitingList = scheduler-&gt;<span class="built_in">getWaitingList</span>();</span><br><span class="line">    <span class="comment">//检查joiner是否在等待队列中</span></span><br><span class="line">    ListElement *p =waitingList-&gt;<span class="built_in">listFirst</span>();</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        Thread *thread = (Thread*)p-&gt;item;</span><br><span class="line">        <span class="keyword">if</span>(thread-&gt;waitProcessSpaceId == <span class="built_in">userProgramId</span>())&#123;</span><br><span class="line">            <span class="comment">//将子线程退出码赋给父进程的等待退出码</span></span><br><span class="line">            thread-&gt;waitProcessExitCode = exitCode;</span><br><span class="line">            scheduler-&gt;<span class="built_in">ReadyToRun</span>((Thread *)thread);</span><br><span class="line">            waitingList-&gt;<span class="built_in">RemoveItem</span>(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Terminated</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Finishing thread \&quot;%s\&quot;\n&quot;</span>, <span class="built_in">getName</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//threadToBeDestroyed = currentThread;</span></span><br><span class="line">    <span class="built_in">Sleep</span>();					<span class="comment">// invokes SWITCH</span></span><br><span class="line">    <span class="comment">// not reached</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>增加函数void <strong>Thread</strong>::<strong>initSpace</strong>(<strong>AddrSpace</strong> *userSpace)</p>
<p>由于之前完成地址空间的映射时，仅仅使用currentThread-&gt;space &#x3D; space完成映射，这就导致在space被delete掉之后，存储在space的SpaceId一同被销毁，</p>
<p>space在调用finish之前就会被delete</p>
<p>再次访问SpaceId的时候就会发生地址越界的问题，因此需要将SpaceId在映射时就存储在thread类中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Thread::initSpace(AddrSpace *userSpace)&#123;</span><br><span class="line">    space = userSpace;</span><br><span class="line">    userSpaceId = space-&gt;getSpaceId();</span><br><span class="line">    printf(&quot;userProgram SpaceId %d conflicted\n&quot;,userSpaceId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>List中元素的删除</p>
<p>在上述代码的实现过程中，还需要修改 scheduler 类以及 List 类，具体添加函数如下所示。</p>
<ul>
<li>void Scheduler::deleteTerminatedThread(int deleteSpaceId) 函数为从 Scheduler 的终止队列中删去一个线程；</li>
<li>void List::RemoveItem(ListElement *tmp) 函数为从一个 List 中删去一个元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scheduler::DeletTerminatedThread</span><span class="params">(<span class="type">int</span> deleteSpaceId)</span></span>&#123;</span><br><span class="line">    ListElement *first = terminatedList-&gt;<span class="built_in">listFirst</span>();</span><br><span class="line">    <span class="comment">//printf(&quot;deleteSpaceId:%d\n&quot;,deleteSpaceId);</span></span><br><span class="line">    <span class="keyword">while</span> (first!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        Thread *thread = (Thread*) first-&gt;item;</span><br><span class="line">        <span class="comment">//printf(&quot;finish %d\n&quot;,thread-&gt;userProgramId());</span></span><br><span class="line">        <span class="keyword">if</span>(thread-&gt;<span class="built_in">userProgramId</span>() == deleteSpaceId)&#123;</span><br><span class="line">            terminatedList-&gt;<span class="built_in">RemoveItem</span>(first);</span><br><span class="line">            <span class="comment">//printf(&quot;remove %d from terminatedList\n\n&quot;,deleteSpaceId);</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List::RemoveItem</span><span class="params">(ListElement *tmp)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> isFind = FALSE;</span><br><span class="line">    ListElement *p=first,*pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;item == tmp-&gt;item)&#123;</span><br><span class="line">            isFind = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isFind)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first==last)&#123;</span><br><span class="line">            first = last =<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="literal">NULL</span>) first= first-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p==last)&#123;</span><br><span class="line">                last = pre;</span><br><span class="line">                last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre-&gt;next=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//delete p;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Exit的实现"><a href="#Exit的实现" class="headerlink" title="Exit的实现"></a>Exit的实现</h2><p>系统调用int Join(SpaceId id)需要返回该退出状态status。</p>
<p>由于可能在id结束之后， 其它程序（如 parent）才调用 Join(SpaceId id)，因此在 id 执行 Exit(status)退出时需要将 id 的退出码 ststus 保存起来，以备 Join()使用。 </p>
<p>关于系统调用 Exit()的实现</p>
<ul>
<li>首先从 4 号寄存器读出退出码</li>
<li>然后释放该进程的内存空间及其页表，释放分配给该进程的实页（帧），释放其 pid（参 见 AddrSpace::~AddrSpace()），调用 currentThread-&gt;Finish 结束该进程对应的 线程。</li>
</ul>
<h3 id="源代码修改-2"><a href="#源代码修改-2" class="headerlink" title="源代码修改"></a>源代码修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void exit()&#123;</span><br><span class="line">    printf(&quot;\nExecute system call of Exit()\n&quot;);</span><br><span class="line">    printf(&quot;Thread: %d exit\n&quot;,currentThread-&gt;space-&gt;getSpaceId());</span><br><span class="line">    int exitCode = machine-&gt;ReadRegister(4);</span><br><span class="line">    machine-&gt;WriteRegister(2,exitCode);</span><br><span class="line">    //父进程的退出码特殊标记，由Join的实现方式决定</span><br><span class="line">    if(exitCode == 99)&#123;</span><br><span class="line">        scheduler-&gt;emptyList(scheduler-&gt;getTerminatedList());</span><br><span class="line">    &#125;</span><br><span class="line">    delete currentThread-&gt;space;</span><br><span class="line">    currentThread-&gt;Finish();</span><br><span class="line">    AdvancePC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Scheduler::emptyList(List *deleteList)&#123;</span><br><span class="line">    while (deleteList-&gt; Remove() != NULL)</span><br><span class="line">	;	 // delete all the list elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Yield的实现"><a href="#Yield的实现" class="headerlink" title="Yield的实现"></a>Yield的实现</h2><p>直接调用Thread::Yield函数即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void yield()&#123;</span><br><span class="line">    printf(&quot;\nExecute system call of Yield()\n&quot;);</span><br><span class="line">    printf(&quot;Thread: %d Yield\n&quot;,currentThread-&gt;userProgramId());</span><br><span class="line">    currentThread-&gt;Yield();</span><br><span class="line">    AdvancePC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="系统调用Exec、Join、Yield、Exit的验证"><a href="#系统调用Exec、Join、Yield、Exit的验证" class="headerlink" title="系统调用Exec、Join、Yield、Exit的验证"></a>系统调用Exec、Join、Yield、Exit的验证</h2><p>编写exec.c文件如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int pid;</span><br><span class="line">    int pid2;</span><br><span class="line">    pid = Exec(&quot;../test/join.noff&quot;);</span><br><span class="line">    Join(pid);</span><br><span class="line">    Exec(&quot;../test/halt.noff&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中join.c的代码如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int pid;</span><br><span class="line">    pid = Exec(&quot;../test/yield.noff&quot;);</span><br><span class="line">    Join(pid);</span><br><span class="line">    Exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中yield.c的代码如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Exec(&quot;../test/exit.noff&quot;);</span><br><span class="line">    Yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exit.c代码如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>make进行编译</p>
<p>![2022-05-06 14-24-47 的屏幕截图](操作系统课设总结.assets&#x2F;2022-05-06 14-24-47 的屏幕截图.png)</p>
<p>编译成功，尝试运行</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506151516132.png"></p>
<p>运行成功</p>
<h2 id="基于-FILESYS-STUB-实现文件的有关系统调用"><a href="#基于-FILESYS-STUB-实现文件的有关系统调用" class="headerlink" title="基于 FILESYS_STUB 实现文件的有关系统调用"></a>基于 FILESYS_STUB 实现文件的有关系统调用</h2><p>目前这些涉及文件的几个系统调用（Create、Open、Write、Read、Close）是基于 FILESYS_STUB 定义的方法实现的； </p>
<p>前面已经提到，Nachos 的文件系统有两个版本，基于宏 FILESYS_STUB 与 FILESYS 进行条件编译。参见..&#x2F;filesys&#x2F;filesys.h； </p>
<p>利用宏 FILESYS_STUB 对 Nachos 模块进行条件编译，实现了文件系统的部分功能，直接使用 Linux 的系统调用实现了对文件的操作，访问的是 Linux 文件系统中的文件，如 Exec(filename)访问的是..&#x2F;test 目录中 Linux 文件而不是 Nachos 硬盘 DISK 上的文件 file，因此形式为 Exec(“..&#x2F;test&#x2F;halt.noff”);</p>
<p>该文件系统实现简单、易于理解，对其的修改可以方便我们理解文件系统的操作，在接下来修改FILESYS时更加得心应手</p>
<p>由于打开文件符是Linux系统进行管理，所以Nachos在实现的时候并不需要考虑其管理问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FILESYS_STUB 		<span class="comment">//实现</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileSystem</span>(<span class="type">bool</span> format) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Create</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> initialSize)</span> </span>&#123; </span><br><span class="line">		<span class="type">int</span> fileDescriptor = <span class="built_in">OpenForWrite</span>(name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fileDescriptor == <span class="number">-1</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">		<span class="built_in">Close</span>(fileDescriptor); </span><br><span class="line">		<span class="keyword">return</span> TRUE; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">OpenFile* <span class="title">Open</span><span class="params">(<span class="type">char</span> *name)</span> </span>&#123;</span><br><span class="line">	  <span class="type">int</span> fileDescriptor = <span class="built_in">OpenForReadWrite</span>(name, FALSE);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (fileDescriptor == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenFile</span>(fileDescriptor);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Remove</span><span class="params">(<span class="type">char</span> *name)</span> </span>&#123; <span class="keyword">return</span> (<span class="type">bool</span>)(<span class="built_in">Unlink</span>(name) == <span class="number">0</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="Create函数的实现"><a href="#Create函数的实现" class="headerlink" title="Create函数的实现"></a>Create函数的实现</h3><p>功能：根据文件名，创建一个文件</p>
<p>执行流程</p>
<ul>
<li>读出文件名</li>
<li>调用create函数创建文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void create()&#123;</span><br><span class="line">    printf(&quot;\nExecute system call of Create()\n&quot;);</span><br><span class="line">    int addr = machine-&gt;ReadRegister(4);</span><br><span class="line">    char filename[128];</span><br><span class="line">    for(int i = 0;i&lt;128;i++)&#123;</span><br><span class="line">        machine-&gt;ReadMem(addr+i,1,(int *)&amp;filename[i]);</span><br><span class="line">        if(filename[i]==&#x27;\0&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!fileSystem-&gt;Create(filename,0)) </span><br><span class="line">        printf(&quot;create file %s failed!\n&quot;,filename);</span><br><span class="line">    else </span><br><span class="line">        printf(&quot;create file %s succeed&quot;,filename);</span><br><span class="line"></span><br><span class="line">    AdvancePC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Open函数的实现"><a href="#Open函数的实现" class="headerlink" title="Open函数的实现"></a>Open函数的实现</h3><p>功能：根据文件名，打开一个文件，并返回文件的OpenFileId</p>
<p>执行流程</p>
<ul>
<li>读出文件名</li>
<li>调用文件系统的Open函数打开文件</li>
<li>写回返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void open()&#123;</span><br><span class="line">    printf(&quot;\nExecute system call of Open()\n&quot;);</span><br><span class="line">    //读取要打开的文件名</span><br><span class="line">    int addr = machine-&gt;ReadRegister(4);</span><br><span class="line">    char filename[128];</span><br><span class="line">    for(int i = 0;i&lt;128;i++)&#123;</span><br><span class="line">        machine-&gt;ReadMem(addr+i,1,(int *)&amp;filename[i]);</span><br><span class="line">        if(filename[i]==&#x27;\0&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    //打开文件</span><br><span class="line">    int fileDescriptor = fileSystem-&gt;Open(filename);</span><br><span class="line">    if(fileDescriptor==-1)</span><br><span class="line">        printf(&quot;Open file %s failed!\n&quot;,filename);</span><br><span class="line">    else </span><br><span class="line">        printf(&quot;Open file %s succeed!\n&quot;,filename);</span><br><span class="line">    //返回文件标志符</span><br><span class="line">    machine-&gt;WriteRegister(2,fileDescriptor);</span><br><span class="line">    AdvancePC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Write函数的实现"><a href="#Write函数的实现" class="headerlink" title="Write函数的实现"></a>Write函数的实现</h3><p>功能 <code>void Write(char *buffer, int size, OpenFileId id)</code>，即将 buffer 中的前 size 个字节写入 id 所对应的文件中。</p>
<p>执行流程</p>
<ul>
<li>依次从寄存器中读出传入的各参数</li>
<li>调用 OpenFile 类的 WriteAt 函数将数据写入文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nExecute system call of Write()\n&quot;</span>);</span><br><span class="line">    <span class="comment">//读取参数</span></span><br><span class="line">    <span class="type">int</span> addr = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> size = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> fileId = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    OpenFile *openfile = <span class="keyword">new</span> <span class="built_in">OpenFile</span>(fileId);</span><br><span class="line">    <span class="built_in">ASSERT</span>(openfile != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        machine-&gt;<span class="built_in">ReadMem</span>(addr+i,<span class="number">1</span>,(<span class="type">int</span> *)&amp;buffer[i]);</span><br><span class="line">        <span class="keyword">if</span>(buffer[i]==<span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[size]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> writePos;</span><br><span class="line">    <span class="keyword">if</span>(fileId==<span class="number">1</span>)</span><br><span class="line">        writePos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        writePos = openfile-&gt;<span class="built_in">Length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> writeNumBytes = openfile-&gt;<span class="built_in">WriteAt</span>(buffer,size,writePos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(writeNumBytes==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write file failed!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d has written %d bytes successd!\n&quot;</span>,fileId,writeNumBytes);</span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Read函数的实现"><a href="#Read函数的实现" class="headerlink" title="Read函数的实现"></a>Read函数的实现</h3><p>功能：系统调用 <code>void Write(char *buffer, int size, OpenFileId id)</code>，将 buffer 中的前 size 个字节写入 id 所对应的文件中</p>
<p>执行流程</p>
<ul>
<li>从4、5、6号寄存器分别读出文件名、字节数和文件指针</li>
<li>设置文件内指针的位置</li>
<li>调用 OpenFile 类的 ReadAt 函数将数据写入文件</li>
<li>写入返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void read()&#123;</span><br><span class="line">    printf(&quot;\nExecute system call of Read()\n&quot;);</span><br><span class="line">    //读取参数</span><br><span class="line">    int addr = machine-&gt;ReadRegister(4);</span><br><span class="line">    int size = machine-&gt;ReadRegister(5);</span><br><span class="line">    int fileId = machine-&gt;ReadRegister(6);</span><br><span class="line"></span><br><span class="line">    char buffer[size+1];</span><br><span class="line">    OpenFile *openfile = new OpenFile(fileId);</span><br><span class="line">    int readnum = openfile-&gt;Read(buffer,size);</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">        if(!machine-&gt;WriteMem(addr+i,1,buffer[i]))</span><br><span class="line">            printf(&quot;Write wrong at %d\n&quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[size]=&#x27;\0&#x27;;</span><br><span class="line">    printf(&quot;read %d Bytes succeed!\n content: %s&quot;,readnum,buffer);</span><br><span class="line">    machine-&gt;WriteRegister(2,readnum);</span><br><span class="line">    AdvancePC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="close函数的实现"><a href="#close函数的实现" class="headerlink" title="close函数的实现"></a>close函数的实现</h3><p>功能：关闭文件指针，由于我们是利用Linux自带的文件系统，因此直接调用Close实现即可</p>
<p>执行流程</p>
<ul>
<li>从4号寄存器读出文件标识符</li>
<li>调用Close函数关闭文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void close()&#123;</span><br><span class="line">    printf(&quot;\nExecute system call of Read()\n&quot;);</span><br><span class="line">    int fileId = machine-&gt;ReadRegister(4);</span><br><span class="line">    Close(fileId);</span><br><span class="line">    printf(&quot;File %d closed succeed!\n&quot;);</span><br><span class="line">    AdvancePC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件操作的测试"><a href="#文件操作的测试" class="headerlink" title="文件操作的测试"></a>文件操作的测试</h2><p>编写文件操作测试程序filetest.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    OpenFileId Fp;</span><br><span class="line">    char buffer[50];</span><br><span class="line">    int sz;</span><br><span class="line">    Create(&quot;Ftest&quot;);</span><br><span class="line">    Fp=Open(&quot;Ftest&quot;);</span><br><span class="line">    Write(&quot;hello world&quot;,10,Fp);</span><br><span class="line">    Close(Fp);</span><br><span class="line">    Fp =Open(&quot;Ftest&quot;);</span><br><span class="line">    sz = Read(buffer,6,Fp);</span><br><span class="line">    Write(buffer,6,1);  //读出前6个字符并stdout输出</span><br><span class="line">    Close(Fp);</span><br><span class="line">    Exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>make编译后运行</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506152111304.png" alt="image-20220506152111304"></p>
<p>可以看到我们建立了一个Ftest文件，写入一段话后在读出，并输出到屏幕上，成功</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506152302399.png" alt="image-20220506152302399"></p>
<h2 id="FILESYS-SUB内文件操作的实现"><a href="#FILESYS-SUB内文件操作的实现" class="headerlink" title="FILESYS_SUB内文件操作的实现"></a>FILESYS_SUB内文件操作的实现</h2><h3 id="Makefile文件的修改"><a href="#Makefile文件的修改" class="headerlink" title="Makefile文件的修改"></a>Makefile文件的修改</h3><p>因为lab7-8中基于FILESYS实现了文件操作，因此我决定新建一个文件夹lab9来实现Nachos的文件系统下的文件操作，这样也避免了可能出现的链接失败问题</p>
<p>将thread、lab5、lab7-8中的文件复制到lab9中，并建立Makefile.local文件如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ifndef MAKEFILE_USERPROG_LOCAL</span><br><span class="line">define MAKEFILE_USERPROG_LOCAL</span><br><span class="line">yes</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">SFILES = switch$(HOST_LINUX).s</span><br><span class="line"></span><br><span class="line">CCFILES += main.cc\</span><br><span class="line">	list.cc\</span><br><span class="line">	scheduler.cc\</span><br><span class="line">	synch.cc\</span><br><span class="line">	synchlist.cc\</span><br><span class="line">	system.cc\</span><br><span class="line">	thread.cc\</span><br><span class="line">	utility.cc\</span><br><span class="line">	threadtest.cc\</span><br><span class="line">	synchtest.cc\</span><br><span class="line">	interrupt.cc\</span><br><span class="line">	sysdep.cc\</span><br><span class="line">	stats.cc\</span><br><span class="line">	timer.cc\</span><br><span class="line">	addrspace.cc\</span><br><span class="line">	bitmap.cc\</span><br><span class="line">	exception.cc\</span><br><span class="line">	progtest.cc\</span><br><span class="line">	console.cc\</span><br><span class="line">	machine.cc\</span><br><span class="line">	mipssim.cc\</span><br><span class="line">	translate.cc\</span><br><span class="line">    directory.cc\</span><br><span class="line">	filehdr.cc\</span><br><span class="line">	filesys.cc\</span><br><span class="line">	fstest.cc\</span><br><span class="line">	openfile.cc\</span><br><span class="line">	synchdisk.cc\</span><br><span class="line">	disk.cc</span><br><span class="line"></span><br><span class="line">INCPATH += -I- -I../lab9 -I../threads -I../machine -I../bin -I../filesys -I../monitor -I../network</span><br><span class="line"></span><br><span class="line">DEFINES += -DTHREADS</span><br><span class="line"></span><br><span class="line">ifdef MAKE_FILE_FILESYS_LOCAL</span><br><span class="line">DEFINES += -DUSER_PROGRAM</span><br><span class="line">else</span><br><span class="line">DEFINES += -DUSER_PROGRAM -DFILESYS_NEEDED -DFILESYS</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endif # MAKEFILE_USERPROG_LOCAL</span><br></pre></td></tr></table></figure>

<p>Makefile如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ifndef MAKEFILE_USERPROG</span><br><span class="line">define MAKEFILE_USERPROG</span><br><span class="line">yes</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">include ../lab9/Makefile.local</span><br><span class="line">include ../Makefile.dep</span><br><span class="line">include ../Makefile.common</span><br><span class="line"></span><br><span class="line">endif # MAKEFILE_USERPROG</span><br></pre></td></tr></table></figure>

<h3 id="文件标识符的建立与释放"><a href="#文件标识符的建立与释放" class="headerlink" title="文件标识符的建立与释放"></a>文件标识符的建立与释放</h3><p>由于FILESYS中没有实现文件标识符，这不便于文件的管理和系统调用的实现，因此需要对AddrSpace和OpenFile类进行修改。</p>
<h4 id="AddrSpace类的修改"><a href="#AddrSpace类的修改" class="headerlink" title="AddrSpace类的修改"></a>AddrSpace类的修改</h4><p>建立一个打开文件数组用于保存打开文件表，并用文件标识符作为下标进行索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define User_FileNum 10</span><br><span class="line"></span><br><span class="line">class AddrSpace&#123;</span><br><span class="line"></span><br><span class="line">····</span><br><span class="line"></span><br><span class="line">#ifdef FILESYS</span><br><span class="line">    int getFileDescriptor(OpenFile *openfile); //获取文件标识符</span><br><span class="line">    OpenFile *getFileId(int fd); //根据文件标识符获取打开文件</span><br><span class="line">    void releaseFileDescriptor(int fd); //释放文件标识符</span><br><span class="line">    </span><br><span class="line">  private:</span><br><span class="line">    BitMap *filemap;			//管理文件标识符</span><br><span class="line">    OpenFile *fileDescriptor[User_FileNum]; //保存打开文件表</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AddrSpace-初始化的修改"><a href="#AddrSpace-初始化的修改" class="headerlink" title="AddrSpace()初始化的修改"></a>AddrSpace()初始化的修改</h4><p>每个进程都有三个默认打开文件，stdin、stdout、stderro，其初始化需要在addrspace初始化函数中完成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FILESYS</span></span><br><span class="line">    filemap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(User_FileNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;User_FileNum;i++)</span><br><span class="line">        fileDescriptor[i]=<span class="literal">NULL</span>;</span><br><span class="line">    OpenFile *StdinFile = <span class="keyword">new</span> <span class="built_in">OpenFile</span>(<span class="string">&quot;stdin&quot;</span>);</span><br><span class="line">    OpenFile *StdoutFile = <span class="keyword">new</span> <span class="built_in">OpenFile</span>(<span class="string">&quot;stdout&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    fileDescriptor[<span class="number">0</span>]=StdinFile;</span><br><span class="line">    fileDescriptor[<span class="number">1</span>]=StdoutFile;</span><br><span class="line">    fileDescriptor[<span class="number">2</span>]=StdoutFile;</span><br><span class="line">    filemap-&gt;<span class="built_in">Mark</span>(<span class="number">0</span>);</span><br><span class="line">    filemap-&gt;<span class="built_in">Mark</span>(<span class="number">1</span>);</span><br><span class="line">    filemap-&gt;<span class="built_in">Mark</span>(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>修改~AddrSpace()释放filemap指针</p>
<h4 id="int-AddrSpace-getFileDescriptor"><a href="#int-AddrSpace-getFileDescriptor" class="headerlink" title="int AddrSpace::getFileDescriptor()"></a>int AddrSpace::getFileDescriptor()</h4><p>获取第一个空闲的文件标识符，调用filemap-&gt;find()函数实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">AddrSpace::getFileDescriptor</span><span class="params">(OpenFile *openfile)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fileDescriptorNum = filemap-&gt;<span class="built_in">Find</span>();</span><br><span class="line">    <span class="keyword">if</span>(fileDescriptorNum!=<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">        fileDescriptor[fileDescriptorNum] = openfile;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fileDescriptorNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OpenFile-AddrSpace-getFileId-int-fd"><a href="#OpenFile-AddrSpace-getFileId-int-fd" class="headerlink" title="OpenFile* AddrSpace::getFileId(int fd)"></a><strong>OpenFile</strong>* <strong>AddrSpace</strong>::<strong>getFileId</strong>(int fd)</h4><p>根据文件标识符获取打开文件，注意地址越界检查</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OpenFile* <span class="title">AddrSpace::getFileId</span><span class="params">(<span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>((fd&gt;=<span class="number">0</span>)&amp;&amp;(fd&lt;User_FileNum));</span><br><span class="line">    <span class="keyword">return</span> fileDescriptor[fd];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="void-AddrSpace-releaseFileDescriptor-int-fd"><a href="#void-AddrSpace-releaseFileDescriptor-int-fd" class="headerlink" title="void AddrSpace::releaseFileDescriptor(int fd)"></a>void <strong>AddrSpace</strong>::<strong>releaseFileDescriptor</strong>(int fd)</h4><p>根据文件标识符释放文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddrSpace::releaseFileDescriptor</span><span class="params">(<span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>((fd&gt;=<span class="number">0</span>)&amp;&amp;(fd&lt;User_FileNum));</span><br><span class="line">    <span class="keyword">delete</span> fileDescriptor[fd];</span><br><span class="line">    fileDescriptor[fd] = <span class="literal">NULL</span>;</span><br><span class="line">    filemap-&gt;<span class="built_in">Clear</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标准文件的输入输出"><a href="#标准文件的输入输出" class="headerlink" title="标准文件的输入输出"></a>标准文件的输入输出</h3><p>前面已经介绍过每个AddrSpace都有三个默认打开文件，stdin、stdout、stderro</p>
<p>我们需要相关函数来实现对这三个文件的操作</p>
<p>修改OpenFile类，添加函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OpenFile&#123;</span><br><span class="line">	</span><br><span class="line">	····</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">OpenFile</span>(<span class="type">char</span> *type) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">WriteStdout</span><span class="params">(<span class="type">char</span> *from,<span class="type">int</span> numBytes)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ReadStdin</span><span class="params">(<span class="type">char</span> *into,<span class="type">int</span> numBytes)</span></span>;</span><br><span class="line"> 	····   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">OpenFile::WriteStdout</span><span class="params">(<span class="type">char</span> *from,<span class="type">int</span> numBytes)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> file = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">WriteFile</span>(file,from,numBytes);</span><br><span class="line">    <span class="keyword">return</span> numBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">OpenFile::ReadStdin</span><span class="params">(<span class="type">char</span> *into ,<span class="type">int</span> numBytes)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> file = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ReadPartial</span>(file,into,numBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用Create的实现"><a href="#系统调用Create的实现" class="headerlink" title="系统调用Create的实现"></a>系统调用Create的实现</h3><p>基于 FILESYS 实现 Create() 系统调用：在 DISK 中创建一个文件用于 Nachos 的运行。</p>
<p>实现方法</p>
<ul>
<li>从寄存器中读出创建的文件名</li>
<li>调用 FileSystem 在基于 FILESYS 下实现的 Create 函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nExecute system call of Create()\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> addr = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">        machine-&gt;<span class="built_in">ReadMem</span>(addr+i,<span class="number">1</span>,(<span class="type">int</span> *)&amp;filename[i]);</span><br><span class="line">        <span class="keyword">if</span>(filename[i]==<span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fileSystem-&gt;<span class="built_in">Create</span>(filename,<span class="number">0</span>)) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create file %s failed!\n&quot;</span>,filename);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create file %s succeed&quot;</span>,filename);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用Open的实现"><a href="#系统调用Open的实现" class="headerlink" title="系统调用Open的实现"></a>系统调用Open的实现</h3><p>作用：打开一个文件，获得OpenFile指针并将其加入到AddrSpace类的打开文件表中</p>
<p>执行流程</p>
<ul>
<li>从寄存器读出打开文件的名字</li>
<li>获取OpenFile指针</li>
<li>将OpenFile指针加入到线程的打开文件表，并获取文件标识符</li>
<li>写回文件标识符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nExecute system call of Open()\n&quot;</span>);</span><br><span class="line">    <span class="comment">//读取要打开的文件名</span></span><br><span class="line">    <span class="type">int</span> addr = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">        machine-&gt;<span class="built_in">ReadMem</span>(addr+i,<span class="number">1</span>,(<span class="type">int</span> *)&amp;filename[i]);</span><br><span class="line">        <span class="keyword">if</span>(filename[i]==<span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    OpenFile *openfile = fileSystem-&gt;<span class="built_in">Open</span>(filename);</span><br><span class="line">    <span class="type">int</span> fileId;</span><br><span class="line">    <span class="keyword">if</span>(openfile==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open file %s failed!\n&quot;</span>,filename);</span><br><span class="line">        fileId = <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="comment">//printf(&quot;Open file %s succeed!\n&quot;,filename);</span></span><br><span class="line">        fileId = currentThread-&gt;space-&gt;<span class="built_in">getFileDescriptor</span>(openfile);</span><br><span class="line">        <span class="keyword">if</span>(fileId&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Too many files opened!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Open file %s succeed with fileid %d&quot;</span>,filename,fileId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回文件标志符</span></span><br><span class="line">    machine-&gt;<span class="built_in">WriteRegister</span>(<span class="number">2</span>,fileId);</span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用Write的实现"><a href="#系统调用Write的实现" class="headerlink" title="系统调用Write的实现"></a>系统调用Write的实现</h3><p>作用：<code>Write(char*,size,fileId)</code>的作用是向文件FileId写入char*的前size个字符</p>
<p>执行流程</p>
<ul>
<li>获取addr、size、fileId</li>
<li>根据FileId从打开文件表中获取OpenFile指针</li>
<li>从内存中读取待操作的字符串</li>
<li>若FileId为stdout或stderro则直接输出</li>
<li>写入文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;\nExecute system call of Write()\n&quot;);</span></span><br><span class="line">    <span class="comment">//读取参数</span></span><br><span class="line">    <span class="type">int</span> addr = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> size = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> fileId = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件 直接从打开文件表中打开文件</span></span><br><span class="line">    OpenFile *openfile = currentThread-&gt;space-&gt;<span class="built_in">getFileId</span>(fileId);</span><br><span class="line">    <span class="built_in">ASSERT</span>(openfile != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//char buffer[128];</span></span><br><span class="line">    <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        machine-&gt;<span class="built_in">ReadMem</span>(addr+i,<span class="number">1</span>,(<span class="type">int</span> *)&amp;buffer[i]);</span><br><span class="line">        <span class="keyword">if</span>(buffer[i]==<span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[size]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fileId==<span class="number">1</span>||fileId==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;stdout:%d\n&quot;,buffer);</span></span><br><span class="line">        openfile-&gt;<span class="built_in">WriteStdout</span>(buffer,size);</span><br><span class="line">        <span class="built_in">AdvancePC</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> writePos = openfile-&gt;<span class="built_in">Length</span>();</span><br><span class="line">    openfile-&gt;<span class="built_in">Seek</span>(writePos);</span><br><span class="line">    <span class="type">int</span> writeNumBytes = openfile-&gt;<span class="built_in">WriteAt</span>(buffer,size,writePos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(writeNumBytes==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write file failed!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d has written %d bytes succeed!\n&quot;</span>,fileId,writeNumBytes);</span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用Read的实现"><a href="#系统调用Read的实现" class="headerlink" title="系统调用Read的实现"></a>系统调用Read的实现</h3><p>作用：<code>Read(char*,size,fileId)</code>的作用是向字符串char*读入文件FileId的前size个字符</p>
<p>执行流程</p>
<ul>
<li>获取addr、size、fileId</li>
<li>根据FileId从打开文件表中获取OpenFile指针</li>
<li>从内存中读取待操作的字符串</li>
<li>判断是否从stdin读入，分别调用不同的实现函数</li>
<li>写入字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;\nExecute system call of Read()\n&quot;);</span></span><br><span class="line">    <span class="comment">//读取参数</span></span><br><span class="line">    <span class="type">int</span> addr = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> size = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> fileId = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[size+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    OpenFile *openfile = currentThread-&gt;space-&gt;<span class="built_in">getFileId</span>(fileId);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> readNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从文件中读出字符串</span></span><br><span class="line">    <span class="keyword">if</span>(fileId == <span class="number">0</span>)</span><br><span class="line">        readNum = openfile-&gt;<span class="built_in">ReadStdin</span>(buffer,size);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        readNum = openfile-&gt;<span class="built_in">Read</span>(buffer,size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入字符串到指定地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;readNum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!machine-&gt;<span class="built_in">WriteMem</span>(addr+i,<span class="number">1</span>,buffer[i]))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Write wrong at %d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[readNum]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换整数么</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; readNum; i++)</span><br><span class="line">        <span class="keyword">if</span> (buffer[i] &gt;=<span class="number">0</span> &amp;&amp; buffer[i] &lt;= <span class="number">9</span>)</span><br><span class="line">            buffer[i] = buffer[i] + <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *buf = buffer;</span><br><span class="line">    <span class="keyword">if</span> (readNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (fileId != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">DEBUG</span>(<span class="string">&#x27;f&#x27;</span>,<span class="string">&quot;Read file (%d) succeed! the content is \&quot;%s\&quot; , the length is %d\n&quot;</span>,fileId,buf,readNum);</span><br><span class="line">            <span class="built_in">DEBUG</span>(<span class="string">&#x27;H&#x27;</span>,<span class="string">&quot;Read file (%d) succeed! the content is \&quot;%s\&quot; , the length is %d\n&quot;</span>,fileId,buf,readNum);</span><br><span class="line">            <span class="built_in">DEBUG</span>(<span class="string">&#x27;J&#x27;</span>,<span class="string">&quot;Read file (%d) succeed! the content is \&quot;%s\&quot; , the length is %d\n&quot;</span>,fileId,buf,readNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\nRead file failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    machine-&gt;<span class="built_in">WriteRegister</span>(<span class="number">2</span>,readNum);</span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用Close的实现"><a href="#系统调用Close的实现" class="headerlink" title="系统调用Close的实现"></a>系统调用Close的实现</h3><p>作用：在线程的打开文件表中删除OpenFile指针并释放文件标识符</p>
<p>执行流程</p>
<ul>
<li>读入待关闭的文件标识符</li>
<li>将文件写回到磁盘</li>
<li>释放文件标识符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nExecute system call of Close()\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fileId = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    OpenFile *openfile = currentThread-&gt;space-&gt;<span class="built_in">getFileId</span>(fileId);</span><br><span class="line">    <span class="keyword">if</span>(openfile!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fileId&gt;<span class="number">2</span>)</span><br><span class="line">        	openfile-&gt;<span class="built_in">WriteBack</span>();</span><br><span class="line">        currentThread-&gt;space-&gt;<span class="built_in">releaseFileDescriptor</span>(fileId);</span><br><span class="line">        <span class="built_in">DEBUG</span>(<span class="string">&#x27;f&#x27;</span>,<span class="string">&quot;File %d closed succeed\n&quot;</span>,fileId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;failed to close File %d\n&quot;</span>,fileId);</span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现一个shell"><a href="#实现一个shell" class="headerlink" title="实现一个shell"></a>实现一个shell</h2><p>一个完整的操作系统不能缺少一个shell，通过循环读入指令并处理，实现操作系统的不断运行</p>
<p>shell本质上是系统内运行的用户进程，通过系统调用实现与操作系统内核的交互，因此要在..&#x2F;test文件夹下编写一个shell.c文件并编译为shell.noff文件运行在nachos中，但在编写shell之前，我们要先想好，我们想要实现的功能是什么</p>
<h3 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h3><p>因此我设计了一个shell，其功能如下</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>功能</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Sc_Create</td>
<td>创建文件</td>
<td>mf &lt;filename&gt;</td>
</tr>
<tr>
<td>Sc_Remove</td>
<td>删除文件</td>
<td>rm &lt;filename&gt;</td>
</tr>
<tr>
<td>Sc_Ls</td>
<td>打印文件列表</td>
<td>ls</td>
</tr>
<tr>
<td>Sc_Cat</td>
<td>打印文件内容</td>
<td>cat &lt;filename&gt;</td>
</tr>
<tr>
<td>Sc_Exec</td>
<td>运行文件</td>
<td>&lt;filename&gt;</td>
</tr>
<tr>
<td>Sc_Load</td>
<td>加载系统内文件到Nachos</td>
<td>ld &lt;filename&gt;</td>
</tr>
</tbody></table>
<h3 id="新增系统调用"><a href="#新增系统调用" class="headerlink" title="新增系统调用"></a>新增系统调用</h3><p>实现这些功能需要添加额外的系统调用</p>
<p>我们已知系统调用的声明在文件syscall.h中，以cat指令为例，说明自定义的系统调用是如何实现的</p>
<p>首先修改syscall.h文件，添加Cat函数的声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SC_Cat      12</span></span><br><span class="line"></span><br><span class="line">·····</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cat</span><span class="params">(<span class="type">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这样编写的.c可执行文件便可以搜索到新声明的函数了</p>
<p>但是这还不够，我们还要修改test文件夹下的statr.s文件，使得makefile编译时能正确链接到函数地址</p>
<p>添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">·····</span><br><span class="line"></span><br><span class="line">	.globl Cat</span><br><span class="line">	.ent	Cat</span><br><span class="line">Cat:</span><br><span class="line">	addiu $2,$0,SC_Cat</span><br><span class="line">	syscall</span><br><span class="line">	j	$31</span><br><span class="line">	.end Cat</span><br><span class="line">	</span><br><span class="line">·····</span><br></pre></td></tr></table></figure>

<p>在exception.cc文件中实现cat函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nExecute system call of Cat()\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> addr = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">        machine-&gt;<span class="built_in">ReadMem</span>(addr+i,<span class="number">1</span>,(<span class="type">int</span> *)&amp;filename[i]);</span><br><span class="line">        <span class="keyword">if</span>(filename[i]==<span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OpenFile *openFile;    </span><br><span class="line">    <span class="type">int</span> i, amountRead;</span><br><span class="line">    <span class="type">char</span> *buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((openFile = fileSystem-&gt;<span class="built_in">Open</span>(filename)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;Print: unable to open file %s\n&quot;</span>, filename);</span><br><span class="line">        <span class="built_in">AdvancePC</span>();</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;===========%s contens===========\n&quot;</span>,filename);</span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span> ((amountRead = openFile-&gt;<span class="built_in">Read</span>(buffer, <span class="number">10</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; amountRead; i++)</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buffer[i]);</span><br><span class="line">    <span class="keyword">delete</span> [] buffer;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> openFile;		<span class="comment">// close the Nachos file</span></span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述操作我们可以依次实现其他的系统调用</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nExecute system call of Remove()\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> addr = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">        machine-&gt;<span class="built_in">ReadMem</span>(addr+i,<span class="number">1</span>,(<span class="type">int</span> *)&amp;filename[i]);</span><br><span class="line">        <span class="keyword">if</span>(filename[i]==<span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fileSystem-&gt;<span class="built_in">Remove</span>(filename)) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;remove file %s failed!\n&quot;</span>,filename);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;remove file %s succeed\n&quot;</span>,filename);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ls</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nExecute system call of Ls()\n&quot;</span>);</span><br><span class="line">    fileSystem-&gt;<span class="built_in">List</span>();</span><br><span class="line">    <span class="built_in">AdvancePC</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Load</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nExecute system call of Load()\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> addr = machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">char</span> Twofile[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">        machine-&gt;<span class="built_in">ReadMem</span>(addr+i,<span class="number">1</span>,(<span class="type">int</span> *)&amp;Twofile[i]);</span><br><span class="line">        <span class="keyword">if</span>(Twofile[i]==<span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> from[<span class="number">64</span>],to[<span class="number">64</span>];</span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> indx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Twofile[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            from[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            from[i]=Twofile[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            to[indx]=Twofile[i];</span><br><span class="line">            indx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Twofile[i]==<span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;cp %s to %s\n&quot;,from,to);</span></span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line">    OpenFile* openFile;</span><br><span class="line">    <span class="type">int</span> amountRead, fileLength;</span><br><span class="line">    <span class="type">char</span> *buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">fopen</span>(from, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;	 </span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;Copy: couldn&#x27;t open input file %s\n&quot;</span>, from);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fseek</span>(fp, <span class="number">0</span>, <span class="number">2</span>);		</span><br><span class="line">    fileLength = <span class="built_in">ftell</span>(fp);</span><br><span class="line">    <span class="built_in">fseek</span>(fp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;f&#x27;</span>, <span class="string">&quot;Copying file %s, size %d, to file %s\n&quot;</span>, from, fileLength, to);</span><br><span class="line">    <span class="keyword">if</span> (!fileSystem-&gt;<span class="built_in">Create</span>(to, fileLength)) &#123;	 <span class="comment">// Create Nachos file</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;Copy: couldn&#x27;t create output file %s\n&quot;</span>, to);</span><br><span class="line">	    <span class="built_in">fclose</span>(fp);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    openFile = fileSystem-&gt;<span class="built_in">Open</span>(to);</span><br><span class="line">    <span class="built_in">ASSERT</span>(openFile != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span> ((amountRead = <span class="built_in">fread</span>(buffer, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="number">10</span>, fp)) &gt; <span class="number">0</span>)</span><br><span class="line">	    openFile-&gt;<span class="built_in">Write</span>(buffer, amountRead);	</span><br><span class="line">    <span class="keyword">delete</span> [] buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> openFile;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shell-c的实现"><a href="#shell-c的实现" class="headerlink" title="shell.c的实现"></a>shell.c的实现</h3><p>文件中原本给了一个shell.c的实现，其功能较为简单，仅仅是读入字符串，然后放入Exec()中执行</p>
<p>我们需要加入新的判断语句，来执行不同的系统调用</p>
<p>执行流程</p>
<ul>
<li>读入一行字符串</li>
<li>判断指令类型并分割字符串</li>
<li>启动系统调用</li>
</ul>
<p>实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SpaceId newProc;</span><br><span class="line">    OpenFileId input = ConsoleInput;</span><br><span class="line">    OpenFileId output = ConsoleOutput;</span><br><span class="line">    <span class="type">char</span> prompt[<span class="number">2</span>], ch, buffer[<span class="number">60</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )&#123;</span><br><span class="line">		Write(<span class="string">&quot;shell=====&gt;: &quot;</span>, <span class="number">13</span>, output);</span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">	    	Read(&amp;buffer[i], <span class="number">1</span>, input); </span><br><span class="line">		&#125; <span class="keyword">while</span>( buffer[i++] != <span class="string">&#x27;\n&#x27;</span> );</span><br><span class="line"></span><br><span class="line">		buffer[--i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( i &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">2</span> &amp;&amp; buffer[<span class="number">0</span>]==<span class="string">&#x27;l&#x27;</span> &amp;&amp; buffer[<span class="number">1</span>] == <span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">				Ls();</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(buffer[<span class="number">0</span>] == <span class="string">&#x27;m&#x27;</span> &amp;&amp; buffer[<span class="number">1</span>]==<span class="string">&#x27;f&#x27;</span> )&#123;</span><br><span class="line">				Create(&amp;buffer[<span class="number">3</span>]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(buffer[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span> &amp;&amp; buffer[<span class="number">1</span>]==<span class="string">&#x27;m&#x27;</span>)&#123;</span><br><span class="line">				Remove(&amp;buffer[<span class="number">3</span>]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(buffer[<span class="number">0</span>]==<span class="string">&#x27;c&#x27;</span>&amp;&amp; buffer[<span class="number">1</span>]==<span class="string">&#x27;a&#x27;</span>&amp;&amp;buffer[<span class="number">2</span>]==<span class="string">&#x27;t&#x27;</span>)&#123;</span><br><span class="line">				Cat(&amp;buffer[<span class="number">4</span>]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(buffer[<span class="number">0</span>]==<span class="string">&#x27;l&#x27;</span>&amp;&amp;buffer[<span class="number">1</span>]==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">				Load(&amp;buffer[<span class="number">3</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				newProc = Exec(buffer);</span><br><span class="line">				Join(newProc);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="shell的验证"><a href="#shell的验证" class="headerlink" title="shell的验证"></a>shell的验证</h2><p>验证shell命令如下</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506143602886.png" alt="image-20220506143602886"></p>
<p>运行nachos系统中的shell程序，shell程序已经提前被装载到DISK中，打印出磁盘中的文件列表，输出文件内容成功。</p>
<p>然后加载一个文本文件small到磁盘中，我们可以看到由于磁盘中已经有一个small文件，不能创建同名文件，所以系统报错</p>
<p>然后加载一个文件medium到磁盘中，成功</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506144109056.png" alt="image-20220506144109056"></p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506143826658.png" alt="image-20220506143826658"></p>
<p>删除文件small成功</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506144350160.png" alt="image-20220506144350160"></p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506144414857.png" alt="image-20220506144414857"></p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506144437559.png" alt="image-20220506144437559"></p>
<p>可以看到系统Exec成功执行，执行完毕，运行halt推出系统</p>
<p><img src="/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/image-20220506144539952.png" alt="image-20220506144539952"></p>
<h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><p>makefile不好写，直接复制usrprog文件夹下的文件</p>
<p>addrSpace下目前的内存填充方式为连续复制，与页面分配方式有出入，会产生bug</p>
<p>space在调用finish之前就会被delete，此时再调用space-&gt;getSpaceId会发生段错误，但由于我们在处理结束的进程时必须要获得spaceid</p>
<p>解决方式，提前将SpaceId赋值给thread</p>
<p>时间：currentThread-&gt;space&#x3D;space时</p>
<p>疑问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (currentThread-&gt;space != NULL) &#123;    // if this thread is a user program,</span><br><span class="line">        currentThread-&gt;SaveUserState(); // save the user&#x27;s CPU registers</span><br><span class="line">        //currentThread-&gt;space-&gt;SaveState(); //machine内地址直接给space会引起段错误</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>取消注释会引起段错误，初步判断为SaveState会引起地址访问越界</p>
<p>由于系统调用是通过文件标志符来标识文件的</p>
<p>文件标志符对应的读写错误信息的输入输出文件保存在PCB也就是Nachos的Address类中</p>
<p>因此要在Address类中实现文件标志符的管理</p>
<p>也许可以实现printf</p>
<p>尝试实现shell</p>
<p>remove</p>
<p>ls</p>
<p>cat</p>
<p>load 加载外部文件</p>
<p>实现shell</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>功能</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Sc_Create</td>
<td>创建文件</td>
<td>mf &lt;filename&gt;</td>
</tr>
<tr>
<td>Sc_Remove</td>
<td>删除文件</td>
<td>rm &lt;filename&gt;</td>
</tr>
<tr>
<td>Sc_Ls</td>
<td>打印文件列表</td>
<td>ls</td>
</tr>
<tr>
<td>Sc_Cat</td>
<td>打印文件内容</td>
<td>cat &lt;filename&gt;</td>
</tr>
<tr>
<td>Sc_Exec</td>
<td>运行文件</td>
<td>&lt;filename&gt;</td>
</tr>
<tr>
<td>Sc_Load</td>
<td>加载系统内文件到Nachos</td>
<td>ld &lt;filename&gt;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/30/ubuntu%E5%88%A9%E7%94%A8devstack%E6%90%AD%E5%BB%BAopenstack/" rel="prev" title="ubuntu利用devstack搭建openstack">
      <i class="fa fa-chevron-left"></i> ubuntu利用devstack搭建openstack
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE"><span class="nav-number">1.</span> <span class="nav-text">操作系统课设</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nachos%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93"><span class="nav-number">2.</span> <span class="nav-text">Nachos系统总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">中断控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E6%97%B6%E6%9C%BA"><span class="nav-number">2.1.1.</span> <span class="nav-text">中断响应时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.2.</span> <span class="nav-text">线程的状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80-Nachos%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="nav-number">3.</span> <span class="nav-text">实验一 Nachos系统的安装与调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84"><span class="nav-number">3.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.2.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.3.</span> <span class="nav-text">实验步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85nachos"><span class="nav-number">3.3.1.</span> <span class="nav-text">安装nachos</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.1.</span> <span class="nav-text">查询函数地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.2.</span> <span class="nav-text">查询对象地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2SWITCH%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.3.</span> <span class="nav-text">查询SWITCH函数返回地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork%E5%90%8E%E8%BF%90%E8%A1%8CSWICH%E7%9A%84%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.4.</span> <span class="nav-text">Fork后运行SWICH的返回地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C-Nachos%E7%9A%84MAKEFILES"><span class="nav-number">4.</span> <span class="nav-text">实验二 Nachos的MAKEFILES</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="nav-number">4.1.</span> <span class="nav-text">学习总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%85%B6%E4%BB%96%E7%9B%AE%E5%BD%95%E4%B8%AD%E4%BF%AE%E6%94%B9Nachos%E4%BB%A3%E7%A0%81%E5%B9%B6%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.1.1.</span> <span class="nav-text">在其他目录中修改Nachos代码并生成系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9INPATH"><span class="nav-number">4.1.2.</span> <span class="nav-text">修改INPATH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E5%8C%85%E5%90%AB%E4%BF%AE%E6%94%B9%E7%9A%84-h%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E6%96%87%E4%BB%B6%E9%9B%86"><span class="nav-number">4.1.3.</span> <span class="nav-text">寻找包含修改的.h文件的最小文件集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89-%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">5.</span> <span class="nav-text">实验三 利用信号量实现线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-1"><span class="nav-number">5.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4%E4%B8%8E%E8%A6%81%E6%B1%82"><span class="nav-number">5.2.</span> <span class="nav-text">设计步骤与要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">实验过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.3.1.</span> <span class="nav-text">理解信号量的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9prodcons-cc%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.3.2.</span> <span class="nav-text">修改prodcons++.cc的程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E5%B9%B6%E7%90%86%E8%A7%A3%EF%BC%8CThread-Fork-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.3.</span> <span class="nav-text">分析并理解，Thread::Fork()创建线程的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rs%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6"><span class="nav-number">5.3.4.</span> <span class="nav-text">-rs轮转调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">5.4.</span> <span class="nav-text">备注</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.1.</span> <span class="nav-text">C语言函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E6%9E%90"><span class="nav-number">5.5.</span> <span class="nav-text">上下文切换相关函数实现的分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-Yield"><span class="nav-number">5.5.1.</span> <span class="nav-text">Thread::Yield()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scheduler-Run-Thread-nextThread"><span class="nav-number">5.5.2.</span> <span class="nav-text">Scheduler::Run (Thread *nextThread)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-finish"><span class="nav-number">5.5.3.</span> <span class="nav-text">Thread::finish()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-sleep"><span class="nav-number">5.5.4.</span> <span class="nav-text">Thread::sleep()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-FindNextToRun"><span class="nav-number">5.5.5.</span> <span class="nav-text">Thread::FindNextToRun()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B-Nachos-%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.</span> <span class="nav-text">实验四 Nachos 的文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="nav-number">6.1.</span> <span class="nav-text">实验目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-1"><span class="nav-number">6.2.</span> <span class="nav-text">任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.2.1.</span> <span class="nav-text">硬盘初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">6.2.2.</span> <span class="nav-text">硬盘大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nachos%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4"><span class="nav-number">6.2.3.</span> <span class="nav-text">Nachos的文件系统命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FFileSystem%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.2.4.</span> <span class="nav-text">文件系统FileSystem的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nachos%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80"><span class="nav-number">6.2.5.</span> <span class="nav-text">Nachos文件系统布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E7%BB%84%E4%BF%A1%E6%81%AF"><span class="nav-number">6.2.5.1.</span> <span class="nav-text">三元组信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="nav-number">6.2.6.</span> <span class="nav-text">更多的验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8-1"><span class="nav-number">6.3.</span> <span class="nav-text">备注</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%91%BD%E4%BB%A4"><span class="nav-number">6.3.1.</span> <span class="nav-text">Linux命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#od%E5%91%BD%E4%BB%A4%E7%94%A8%E4%BA%8E%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E3%80%82"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">od命令用于输出文件内容。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hexdump%E5%91%BD%E4%BB%A4%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E6%9F%A5%E7%9C%8B%E2%80%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E2%80%9D%E6%96%87%E4%BB%B6%E7%9A%84%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81"><span class="nav-number">6.3.1.2.</span> <span class="nav-text">hexdump命令主要用来查看“二进制”文件的十六进制编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E7%A4%BA%E5%9B%BE"><span class="nav-number">6.3.2.</span> <span class="nav-text">位示图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="nav-number">6.3.3.</span> <span class="nav-text">文件目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="nav-number">6.3.4.</span> <span class="nav-text">文件头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="nav-number">6.3.5.</span> <span class="nav-text">文件大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E7%A9%BA%E9%97%B2%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">6.3.6.</span> <span class="nav-text">硬盘空闲块的管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94-%E6%89%A9%E5%B1%95Nachos%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">7.</span> <span class="nav-text">实验五 扩展Nachos的文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-2"><span class="nav-number">7.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-2"><span class="nav-number">7.2.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-1"><span class="nav-number">7.3.</span> <span class="nav-text">实验过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">7.3.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.3.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">7.4.</span> <span class="nav-text">实验结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">7.5.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8-2"><span class="nav-number">7.6.</span> <span class="nav-text">备注</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%85%AD-Nachos%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">实验六 Nachos用户程序与系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-3"><span class="nav-number">8.1.</span> <span class="nav-text">目的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-3"><span class="nav-number">8.1.1.</span> <span class="nav-text">任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">8.2.</span> <span class="nav-text">实验步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C-Nachos-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">8.2.1.</span> <span class="nav-text">运行 Nachos 应用程序的方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noff%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.2.2.</span> <span class="nav-text">.noff文件格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86noff%E6%96%87%E4%BB%B6%E8%A3%85%E5%85%A5%E5%86%85%E5%AD%98"><span class="nav-number">8.2.3.</span> <span class="nav-text">将noff文件装入内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nachos%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.2.4.</span> <span class="nav-text">Nachos应用程序的启动过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%8C%E6%88%90"><span class="nav-number">8.2.5.</span> <span class="nav-text">上下文切换的完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4"><span class="nav-number">8.2.6.</span> <span class="nav-text">运行指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E7%A1%AC%E4%BB%B6%E8%AE%BE%E7%BD%AE"><span class="nav-number">8.2.7.</span> <span class="nav-text">机器硬件设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Address%E7%B1%BB%E5%88%86%E6%9E%90"><span class="nav-number">8.2.8.</span> <span class="nav-text">Address类分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8-3"><span class="nav-number">8.3.</span> <span class="nav-text">备注</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C7-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">9.</span> <span class="nav-text">实验7 地址空间的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-4"><span class="nav-number">9.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-4"><span class="nav-number">9.2.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-2"><span class="nav-number">9.3.</span> <span class="nav-text">实验过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9makefile%E6%96%87%E4%BB%B6"><span class="nav-number">9.3.1.</span> <span class="nav-text">修改makefile文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">9.3.2.</span> <span class="nav-text">进程的创建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AddrSpace%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">9.3.3.</span> <span class="nav-text">AddrSpace初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-1"><span class="nav-number">9.3.4.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9"><span class="nav-number">9.3.5.</span> <span class="nav-text">源代码修改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#addrspace-h"><span class="nav-number">9.3.5.1.</span> <span class="nav-text">addrspace.h</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AddrSpace-AddrSpace-OpenFile-executable"><span class="nav-number">9.3.5.2.</span> <span class="nav-text">AddrSpace::AddrSpace(OpenFile *executable)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AddrSpace-AddrSpace"><span class="nav-number">9.3.5.3.</span> <span class="nav-text">AddrSpace::~AddrSpace()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AddrSpace-Print"><span class="nav-number">9.3.5.4.</span> <span class="nav-text">AddrSpace::Print()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%80%83%E8%99%91%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-Exec-%E4%B8%8E-Exit-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9B"><span class="nav-number">9.3.5.5.</span> <span class="nav-text">考虑系统调用 Exec()与 Exit()的设计实现方案；</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8-4"><span class="nav-number">9.4.</span> <span class="nav-text">备注</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%85%AB"><span class="nav-number">10.</span> <span class="nav-text">实验八</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-5"><span class="nav-number">10.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-5"><span class="nav-number">10.2.</span> <span class="nav-text">任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">10.2.1.</span> <span class="nav-text">系统调用宏定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.3.</span> <span class="nav-text">系统调用的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nachso%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">10.4.</span> <span class="nav-text">Nachso系统调用参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84Nachos%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">10.5.</span> <span class="nav-text">编写自己的Nachos应用程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="nav-number">10.6.</span> <span class="nav-text">系统调用的解决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AdvancePC"><span class="nav-number">10.7.</span> <span class="nav-text">AdvancePC()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Exec%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-number">10.8.</span> <span class="nav-text">系统调用Exec的实现思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">10.8.1.</span> <span class="nav-text">执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BDStartProcess-int-spaceId"><span class="nav-number">10.8.2.</span> <span class="nav-text">重载StartProcess(int spaceId)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9AddrSpace"><span class="nav-number">10.8.3.</span> <span class="nav-text">修改AddrSpace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">10.8.4.</span> <span class="nav-text">修改源代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Join%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.9.</span> <span class="nav-text">Join的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-number">10.9.1.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8thread%E7%B1%BB%E4%B8%AD%E5%AE%9E%E7%8E%B0Join"><span class="nav-number">10.9.2.</span> <span class="nav-text">在thread类中实现Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8thread%E7%B1%BB%E4%B8%AD%E4%BF%AE%E6%94%B9finish"><span class="nav-number">10.9.3.</span> <span class="nav-text">在thread类中修改finish</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8thread%E7%B1%BB%E4%B8%AD%E5%AE%9E%E7%8E%B0terminated"><span class="nav-number">10.9.4.</span> <span class="nav-text">在thread类中实现terminated()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9-1"><span class="nav-number">10.9.5.</span> <span class="nav-text">源代码修改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exit%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.10.</span> <span class="nav-text">Exit的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9-2"><span class="nav-number">10.10.1.</span> <span class="nav-text">源代码修改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Yield%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.11.</span> <span class="nav-text">Yield的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Exec%E3%80%81Join%E3%80%81Yield%E3%80%81Exit%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="nav-number">10.12.</span> <span class="nav-text">系统调用Exec、Join、Yield、Exit的验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-FILESYS-STUB-%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%89%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">10.13.</span> <span class="nav-text">基于 FILESYS_STUB 实现文件的有关系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Create%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.13.1.</span> <span class="nav-text">Create函数的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Open%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.13.2.</span> <span class="nav-text">Open函数的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.13.3.</span> <span class="nav-text">Write函数的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.13.4.</span> <span class="nav-text">Read函数的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.13.5.</span> <span class="nav-text">close函数的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-number">10.14.</span> <span class="nav-text">文件操作的测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FILESYS-SUB%E5%86%85%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.15.</span> <span class="nav-text">FILESYS_SUB内文件操作的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Makefile%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">10.15.1.</span> <span class="nav-text">Makefile文件的修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="nav-number">10.15.2.</span> <span class="nav-text">文件标识符的建立与释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AddrSpace%E7%B1%BB%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">10.15.2.1.</span> <span class="nav-text">AddrSpace类的修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AddrSpace-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">10.15.2.2.</span> <span class="nav-text">AddrSpace()初始化的修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-AddrSpace-getFileDescriptor"><span class="nav-number">10.15.2.3.</span> <span class="nav-text">int AddrSpace::getFileDescriptor()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenFile-AddrSpace-getFileId-int-fd"><span class="nav-number">10.15.2.4.</span> <span class="nav-text">OpenFile* AddrSpace::getFileId(int fd)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-AddrSpace-releaseFileDescriptor-int-fd"><span class="nav-number">10.15.2.5.</span> <span class="nav-text">void AddrSpace::releaseFileDescriptor(int fd)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">10.15.3.</span> <span class="nav-text">标准文件的输入输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Create%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.15.4.</span> <span class="nav-text">系统调用Create的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Open%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.15.5.</span> <span class="nav-text">系统调用Open的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Write%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.15.6.</span> <span class="nav-text">系统调用Write的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Read%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.15.7.</span> <span class="nav-text">系统调用Read的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Close%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.15.8.</span> <span class="nav-text">系统调用Close的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAshell"><span class="nav-number">10.16.</span> <span class="nav-text">实现一个shell</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1"><span class="nav-number">10.16.1.</span> <span class="nav-text">功能设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">10.16.2.</span> <span class="nav-text">新增系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shell-c%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.16.3.</span> <span class="nav-text">shell.c的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="nav-number">10.17.</span> <span class="nav-text">shell的验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="nav-number">10.18.</span> <span class="nav-text">问题及解决</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="一枚常指针"
      src="/images/profile_photo.jpg">
  <p class="site-author-name" itemprop="name">一枚常指针</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">一枚常指针</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
