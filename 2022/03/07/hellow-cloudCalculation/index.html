<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="操作系统复习 OS的发展简史早期的OS-简单的监控程序+人工操作缺点  用户独占全机，资源浪费 CPU等待人工操作 CPU既负责计算，又负责传输（单控制方式  矛盾  人机矛盾：人工操作方式与机器利用率的矛盾 CPU与I&#x2F;O设备间速度不匹配的矛盾  解决方法：  通道技术 脱机输入输出方式">
<meta property="og:type" content="article">
<meta property="og:title" content="hellow cloudCalculation">
<meta property="og:url" content="http://example.com/2022/03/07/hellow-cloudCalculation/index.html">
<meta property="og:site_name" content="Const_Point">
<meta property="og:description" content="操作系统复习 OS的发展简史早期的OS-简单的监控程序+人工操作缺点  用户独占全机，资源浪费 CPU等待人工操作 CPU既负责计算，又负责传输（单控制方式  矛盾  人机矛盾：人工操作方式与机器利用率的矛盾 CPU与I&#x2F;O设备间速度不匹配的矛盾  解决方法：  通道技术 脱机输入输出方式">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="e:/OneDrive%20-%20mail.sdu.edu.cn/md/image/image-20211210170232550.png">
<meta property="og:image" content="e:/OneDrive%20-%20mail.sdu.edu.cn/md/image/image-20211210170347255.png">
<meta property="article:published_time" content="2022-03-07T09:27:22.000Z">
<meta property="article:modified_time" content="2022-03-09T14:47:49.637Z">
<meta property="article:author" content="一枚常指针">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:/OneDrive%20-%20mail.sdu.edu.cn/md/image/image-20211210170232550.png">

<link rel="canonical" href="http://example.com/2022/03/07/hellow-cloudCalculation/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>hellow cloudCalculation | Const_Point</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Const_Point</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tag">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>tag</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/hellow-cloudCalculation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile_photo.jpg">
      <meta itemprop="name" content="一枚常指针">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Const_Point">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          hellow cloudCalculation
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-07 17:27:22" itemprop="dateCreated datePublished" datetime="2022-03-07T17:27:22+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-09 22:47:49" itemprop="dateModified" datetime="2022-03-09T22:47:49+08:00">2022-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>操作系统复习</p>
<h1 id="OS的发展简史"><a href="#OS的发展简史" class="headerlink" title="OS的发展简史"></a>OS的发展简史</h1><h2 id="早期的OS-简单的监控程序-人工操作"><a href="#早期的OS-简单的监控程序-人工操作" class="headerlink" title="早期的OS-简单的监控程序+人工操作"></a>早期的OS-简单的监控程序+人工操作</h2><p>缺点</p>
<ul>
<li>用户独占全机，资源浪费</li>
<li>CPU等待人工操作</li>
<li>CPU既负责计算，又负责传输（单控制方式</li>
</ul>
<p>矛盾</p>
<ul>
<li>人机矛盾：人工操作方式与机器利用率的矛盾</li>
<li>CPU与I&#x2F;O设备间速度不匹配的矛盾</li>
</ul>
<p>解决方法：</p>
<ul>
<li>通道技术</li>
<li>脱机输入输出方式</li>
</ul>
<span id="more"></span>

<h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><p>工作方式：</p>
<ul>
<li>系统操作员奖用户作业组成一批作业输入计算机，</li>
<li>系统形成一个自动转接的作业流</li>
<li>系统自动、依次执行每个作业</li>
<li>操作员交付作业结果给用户</li>
</ul>
<p>单道批处理系统</p>
<p>多道批处理系统</p>
<ul>
<li>单道程序系统<ul>
<li>系统只能同时运行一个作业</li>
<li>单个用户独享内存空间</li>
</ul>
</li>
<li>多道程序系统<ul>
<li>系统同时运行多个作业    </li>
<li>运行作业等待时切换至内存另一个作业</li>
<li>多用户共享内存空间</li>
</ul>
</li>
</ul>
<p>需要解决的问题</p>
<ul>
<li>同步互斥、内存保护、文件管理、设备管理</li>
</ul>
<p>管理程序的功能</p>
<ul>
<li>存储器、处理机、设备、文件管理</li>
</ul>
<p>新的概念</p>
<ul>
<li>存储器管理、CPU调度</li>
</ul>
<p>多道程序系统特点</p>
<ul>
<li>优点：作业自动调度执行、缩短了作业之间的间隔时间、资源利用率高、系统吞吐量大</li>
<li>缺点：作业平均周转时间长、对小型作业不利 &#x3D;&#x3D;无交互能力&#x3D;&#x3D;</li>
</ul>
<h3 id="单道批处理系统小结"><a href="#单道批处理系统小结" class="headerlink" title="单道批处理系统小结"></a>单道批处理系统小结</h3><p>工作流程</p>
<ul>
<li>作业合成一批输入到外存上，同时在系统中配上监控程序</li>
<li>监控程序将作业逐个送入内存并运行</li>
</ul>
<p>特征</p>
<ul>
<li>自动性</li>
<li>顺序性</li>
<li>单道性</li>
</ul>
<p>优点</p>
<ul>
<li>减少了人工操作的时间、提高机器的利用率和系统吞吐量</li>
</ul>
<p>缺点：</p>
<ul>
<li>对某些作业来说，当它发出I&#x2F;O请求之后，CPU必须等待I&#x2F;O的完成，因为I&#x2F;O设备的低俗性，从而使得机器的利用率很低</li>
</ul>
<h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p>特征：</p>
<ul>
<li>调度性</li>
<li>无序性</li>
<li>多道性</li>
</ul>
<p>优点</p>
<ul>
<li>资源的利用率高</li>
<li>系统吞吐量大</li>
<li>作业流程自动化</li>
</ul>
<p>缺点：</p>
<ul>
<li>平均周转周期长 &#x3D;&#x3D;平均周转周期长是什么意思&#x3D;&#x3D;</li>
<li>无交互能力  </li>
<li>调试程序困难</li>
</ul>
<p>需解决的问题</p>
<ul>
<li>处理器管理、内存管理、I&#x2F;O设备管理、文件及作业管理问题</li>
</ul>
<p>操作系统的形成</p>
<ul>
<li>为解决上述问题、在多道程序系统中增设一组软件加以解决，同时增设方便用户使用的计算机的软件，形成了操作系统</li>
</ul>
<p>操作系统：是一组控制和管理计算机硬件和软件资源，合理的组织计算工作流程，以方便用户使用的程序集合</p>
<h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p>时间片：</p>
<ul>
<li>操作系统将CPU的时间划分为若干个片段，称为时间片</li>
<li>操作系统以时间片为单位，轮流为每个终端用户服务</li>
<li>每次为一个终端服务一个时间片<ul>
<li>利用人的错觉，使人感觉不到系统是在分时为自己提供服务</li>
</ul>
</li>
</ul>
<p>工作特点</p>
<ul>
<li><p>CPU通过在作业之间的切换来执行多个位于内存中或物理存储器上的作业</p>
<ul>
<li>CPU只能分配给那些在内存中的作业</li>
</ul>
</li>
<li><p>作业在内存和物理存储器之间来回切换</p>
</li>
<li><p>允许用户与系统之间的联机通信（交互）</p>
<ul>
<li>当OS执行完一条命令之后，他将接受用户通过键盘输入的下一条控制指令</li>
</ul>
</li>
<li><p>联机系统必须提供给用户访问数据和代码</p>
</li>
<li><p>多道性、同时性、独立性、及时性、交互性</p>
</li>
</ul>
<p>响应时间：终端用户发出命令到处理机运行完毕返回结果给终端的时间</p>
<p>虚拟内存：允许作业的执行不完全在物理内存中，而是暂时放在磁盘上，根据需要调入调出，所以允许运行比物理内存大的程序</p>
<p>MULTICS：公用计算服务系统</p>
<h3 id="UNIX：现代操作系统的代表"><a href="#UNIX：现代操作系统的代表" class="headerlink" title="UNIX：现代操作系统的代表"></a>UNIX：现代操作系统的代表</h3><p>促使其成功的因素：</p>
<ul>
<li>C语言编写，可移植</li>
<li>系统源代码非常有效，系统用以适应特殊需求</li>
<li>是一个良好的、通用的、多用户、多任务、分时操作系统</li>
</ul>
<h2 id="桌面系统"><a href="#桌面系统" class="headerlink" title="桌面系统"></a>桌面系统</h2><p>CP&#x2F;M操作系统</p>
<p>针对个人计算机操作系统的需求，设计了CP&#x2F;M操作系统</p>
<ul>
<li>Control Program&#x2F;Microprocessor or Microcomputer</li>
</ul>
<p>其具有良好的层次结构</p>
<ul>
<li>利用BIOS把操作系统的其他模块与硬件配置分隔开，所以他的可移植性好，具有较好的可适应性和易学易用性<ul>
<li>BIOS: Basic Input Output System</li>
</ul>
</li>
</ul>
<h2 id="并行系统"><a href="#并行系统" class="headerlink" title="并行系统"></a>并行系统</h2><p>这类操作系统有多个紧密通信的处理器，也称为多处理器系统或紧耦合系统</p>
<p>紧耦合系统：处理器共享计算机总线、内存、时钟；通信常通过共享内存的方式来实现</p>
<p>主要优点：</p>
<ul>
<li>增加吞吐量</li>
<li>经济节约</li>
<li>增加可靠性<ul>
<li>功能退化</li>
<li>容错系统</li>
</ul>
</li>
</ul>
<p>非对称处理</p>
<ul>
<li>每个处理器被赋予一个特定的任务，主处理器为从处理器调度和安排工作</li>
<li>类似于超大型系统</li>
</ul>
<p>对称处理</p>
<ul>
<li>每个处理器都运行同一个操作系统的拷贝，这些拷贝需要互相通信</li>
<li>许多处理器可能同时运行而性能上不会有多大损失</li>
</ul>
<p>若干个位于不同位置的处理器之间组成分布式计算</p>
<p>紧耦合系统：每个处理器都有自己的内存；处理器互相之间通过不同的通信线路进行通信，如高速总线或电话线</p>
<h2 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h2><p>服务器可按照体系架构分为</p>
<ul>
<li>RISC（精简指令集计算）架构服务器</li>
<li>CISC（复杂指令集计算）的IA架构服务器</li>
</ul>
<p>Cluster集群技术定义如下：一组想互独立的服务器在网络中表现为单一的系统，并以单一系统的模式加以管理，此单一系统为客户工作站提供高可靠的服务</p>
<p>IA：通常将采用英特尔处理器的服务器称为IA（Intel Architecture）架构服务器</p>
<p>集群就是一组计算机，他们作为一个整体向用户提供一组网络资源</p>
<h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>对处理器操作或对数据流动有严格时间要求</p>
<ul>
<li>软实时系统<ul>
<li>关键实时任务优先级高于其他任务优先级</li>
</ul>
</li>
<li>硬实时系统<ul>
<li>对系统内所有延迟都有限制</li>
</ul>
</li>
</ul>
<h1 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h1><p>计算机系统的四个组成部分</p>
<ul>
<li>计算机硬件</li>
<li>操作系统</li>
<li>系统程序</li>
<li>用户程序、用户</li>
</ul>
<p>什么是 操作系统</p>
<ul>
<li><p>用户视角</p>
<ul>
<li>执行用户程序，使解决用户问题更容易。</li>
<li>便于使用计算机系统</li>
</ul>
</li>
<li><p>系统视角</p>
<ul>
<li>以一种高效的方式利用硬件资源</li>
<li>操作系统看作资源分配器</li>
<li>操作系统管理这些资源</li>
<li>解决冲突请求，以有效和公平的使用资源</li>
</ul>
</li>
</ul>
<p>操作系统是：</p>
<p>为应用程序提供基础的程序</p>
<p>管理计算机硬件的程序。</p>
<p>充当计算机和计算机硬件的用户之间的中介的程序。</p>
<h2 id="计算机系统操作"><a href="#计算机系统操作" class="headerlink" title="计算机系统操作"></a>计算机系统操作</h2><p>现代计算机系统由一个或多个CPU和若干个设备控制器通过共同的总线相连而成，提供对共享内存的访问</p>
<p>打开电源或重启——运行初始化程序（引导程序）——定位操作系统并将其装入内存——执行第一个进程</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>&#x3D;&#x3D;引导程序&#x3D;&#x3D;：通常位于ROM或EEPROM，成为计算机硬件中的固件。用来初始化系统的所有部分（CPU寄存器，设备控制器和内存</p>
<p>计算机的启动过程一般是指计算机从加电到加载操作系统的过程</p>
<ul>
<li>加电</li>
<li>自检<ul>
<li>进行POST（Power-On Self Test，加电后自检</li>
</ul>
</li>
<li>初始化设备<ul>
<li>系统BIOS 查找显卡的BIOS</li>
</ul>
</li>
<li>测试设备<ul>
<li>标准设备检测完毕后，开始检测和配置系统中安装的即插即用设备</li>
</ul>
</li>
<li>更新ESCD（扩展系统配置数据<ul>
<li>nESCD 是系统BIOS 用来与操作系统交换硬件配置信息的一种手段</li>
</ul>
</li>
<li>启动操作系统<ul>
<li>将启动盘的主引导扇区读入到内存</li>
</ul>
</li>
</ul>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断：硬件可随时通过系统总线向CPU发出信号，触发中断。软件通过系统调用（或者其他别的特别操作）触发中断</p>
<p>软件 trap：是由错误或用户请求引起的软件生成的中断（例如，系统调用）。</p>
<p>发生中断：调用一个通用子程序检查中断信息——使用中断处理指针表（中断向量）——间接调用中断处理子程序</p>
<p>现代操作都是以中断为驱动的</p>
<ul>
<li>若无事，操作系统等待事件发生</li>
<li>事件的发生通常由硬件或软件的中断发出信号</li>
</ul>
<p>中断处理会保存但子程序调用不用保存的内容：程序状态字寄存器</p>
<p>内部异常处理后不会返回到发生异常的指令继续执行</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>内存是处理器可以直接访问的唯一的大容量存储区域</p>
<p>辅存：一般是磁盘，主存储器的扩展，提供大的非易失性存储容量</p>
<ul>
<li>磁盘表面划分为轨道，轨道又细分为扇区</li>
<li>磁盘控制器决定设备和计算机之间的逻辑交互</li>
</ul>
<h2 id="I-x2F-O结构"><a href="#I-x2F-O结构" class="headerlink" title="I&#x2F;O结构"></a>I&#x2F;O结构</h2><p>I&#x2F;O设备有缓冲区</p>
<p>DMA（直接内存访问</p>
<p>用于高速IO设备，能以接近内存速度传送信息</p>
<p>设备控制器无需CPU干预直接将数据块从缓冲存储器传输到主存</p>
<p>每个块只产生一个中断，而不是每个字节一个中断</p>
<h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><ul>
<li><p>单处理器系统</p>
<ul>
<li>只有一个通用CPU能够执行通用指令集，包括来自用户进程的指令</li>
<li>所有其它系统也有其他专用处理器</li>
</ul>
</li>
<li><p>多处理器系统</p>
<ul>
<li><p>有多个紧密通信的CPU，共享计算机总线，有时还包括时钟、内存和外设等</p>
</li>
<li><p>也被称为紧耦合系统</p>
</li>
<li><p>优点</p>
<ul>
<li>增加吞吐量、规模经济、增加可靠性</li>
</ul>
</li>
<li><p>非对称多处理：每个处理器都有各自特定的任务，主处理器分配任务给从处理器，IO只有主处理器完成</p>
</li>
<li><p>对称多处理：所有处理器一视同仁，可以在任何CPU上处理IO</p>
</li>
</ul>
</li>
<li><p>集群系统</p>
<ul>
<li>将多台计算机组合成一个系统</li>
<li>有两个或多个耦合在一起的单独系统组成</li>
<li>集群计算机共享存储，并通过局域网连接或更快的内部连接</li>
</ul>
</li>
</ul>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p>操作系统拥有多道程序处理能力，多道程序设计通过组织作业（编码或数据）使CPU总有一个作业在执行，从而提高了CPU利用率</p>
<p>系统中的总作业子集被保存在内存中，选择一个工作并通过作业调度运行</p>
<p>三种基本类型</p>
<ul>
<li>批处理系统</li>
<li>分时系统，分时系统-交互式计算</li>
<li>实时系统，硬实时系统、软实时系统</li>
</ul>
<h2 id="操作系统的操作"><a href="#操作系统的操作" class="headerlink" title="操作系统的操作"></a>操作系统的操作</h2><p>操作系统必须保证错误的或者恶意的用户程序不能导致操作系统和其他程序的错误执行</p>
<p>问题</p>
<ul>
<li>无限循环、占用资源的进程（CPU保护</li>
<li>进程互相修改或修改操作系统（内存保护</li>
<li>直接发出IO指令或执行非法IO指令的用户（IO保护</li>
</ul>
<p>两种独立的操作模式，为区分操作系统代码和用户定义代码的执行</p>
<ul>
<li>用户模式</li>
<li>监督程序模式（内核模式、管理模式、特权模式、系统模式）</li>
</ul>
<p>将能引起损害的机器指令作为<strong>特权指令</strong>。用户模式下想要执行特权指令，硬件不会执行，会认为是非法指令，并以陷阱的形式通知给操作系统。</p>
<p>特权指令只能在操作系统代码中执行，而不是在用户程序中执行</p>
<p>系统引导时，硬件开始处于<strong>内核模式</strong>。接着装入操作系统，开始进入用户模式。出现陷阱或中断，会进入内核模式</p>
<p>PSW：内核（0）用户（1）提供系统运行用户代码或内核代码时区分的能力</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统提供了一系列预定功能，通过一组称为<strong>系统调用</strong>的接口呈现给编程人员，系统调用把应用的请求传递给内核，系统调用相应的内核函数完成所需处理，并将结果返回给应用程序</p>
<p>对操作系统的保护：硬件检测，软件处理</p>
<p>系统调用服务程序是操作系统的一部分，执行系统调用时，它被硬件视为一个软件中断</p>
<ul>
<li>为操作系统的中断向量和中断服务程序提供内存保护，涉及到存储器管理的寄存器不允许用户设置，特权指令</li>
<li>几乎所有的IO指令都是特权指令</li>
<li>Load-Timer是一个特权指令，保护以防止无限循环</li>
</ul>
<p>操作系统的功能</p>
<ul>
<li>进程管理、内存管理、存储管理、IO子系统</li>
</ul>
<h2 id="操作系统结构-1"><a href="#操作系统结构-1" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p>两个服务器的两个接口</p>
<ul>
<li><p>命令界面</p>
<ul>
<li>命令行CLI</li>
<li>图形用户界面</li>
<li>Batch</li>
</ul>
</li>
<li><p>编程界面</p>
<ul>
<li>系统调用</li>
<li>API</li>
</ul>
</li>
</ul>
<p>![image-20211204152441903](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211204152441903.png)</p>
<p>操作系统服务为用户提供有用功能</p>
<ul>
<li>用户界面</li>
<li>程序执行</li>
<li>IO操作</li>
<li>文件系统操作</li>
<li>通信</li>
<li>错误检测</li>
</ul>
<p>另一组操作系统功能通过资源共享来确保系统本身的高效运行</p>
<ul>
<li>资源分配</li>
<li>统计account：跟踪那些用户使用多少和使用何种计算机资源</li>
<li>保护和安全</li>
</ul>
<p>用户界面</p>
<ul>
<li><p>命令行CLI</p>
<ul>
<li>CLI允许直接命名条目</li>
<li>命令解释器（Unix中被称为shell</li>
</ul>
</li>
<li><p>用户图形界面GUI</p>
</li>
<li><p>Batch</p>
<ul>
<li>批处理文件（batch file）是包含一系列命令的文本文件，有命令解释器解释执行</li>
<li>扩展名一般是 .bat</li>
</ul>
</li>
</ul>
<h2 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用时用户程序和操作系统内核之间的接口</p>
<p>该接口以系统编程语言（如C或汇编语言）中的普通函数的形式存在</p>
<p>系统调用的目的</p>
<ul>
<li>从操作系统内核获得服务，这些服务在没有底层操作系统操作时无法完成</li>
<li>这些任务由运行在系统模式下的内核来完成。</li>
<li>这样，对关键共享硬件(如内存、磁盘和中断)的访问就可以免受错误用户的影响，因为用户程序只能在用户模式下运行。</li>
</ul>
<p>API是什么</p>
<ul>
<li>对操作系统提供的服务的编程接口，通常以高级语言编写</li>
<li>程序主要通过高级应用编程接口（API）而不是系统调用</li>
<li>好处<ul>
<li>编程更方便</li>
<li>系统调用更难使用</li>
<li>对于某些基于OS的设备效率更高</li>
</ul>
</li>
</ul>
<h2 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h2><p>通常，每个系统调用与某个数字相关联</p>
<ul>
<li>系统调用接口根据这些数字维护一个索引表</li>
<li>类似于中断向量</li>
</ul>
<p>系统调用接口调用操作系统内核中预期的系统调用，并返回系统调用的状态和返回值</p>
<p>执行系统调用的过程</p>
<p>传递系统调用参数-&gt;执行陷入（trap）指令-&gt;执行相应的服务程序-&gt;返回用户态</p>
<h2 id="系统调用的类型"><a href="#系统调用的类型" class="headerlink" title="系统调用的类型"></a>系统调用的类型</h2><p>Process control 进程控制</p>
<p>File management 文件管理</p>
<p>Device management 设备管理</p>
<p>Information maintenance 信息维护</p>
<p>Communications 通信</p>
<h2 id="操作系统结构-2"><a href="#操作系统结构-2" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p>简单结构、分层方法、微内核、模块、虚拟机</p>
<h3 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h3><p>MS-DOS、原始的Unix操作系统</p>
<p>用最少的空间提供最多的功能</p>
<p>未划分模块</p>
<h3 id="分层方法"><a href="#分层方法" class="headerlink" title="分层方法"></a>分层方法</h3><p>操作系统分成若干层，最底层（层0）为硬件，最高层（层N）为用户接口。每层只考虑较低层的功能和服务</p>
<p>优点</p>
<ul>
<li>每层都是利用较低层所提供的功能实现的，并为较高层隐藏了一定的数据结构、操作和硬件的存在</li>
</ul>
<p>缺点</p>
<ul>
<li>主要困难为对层的详细定义</li>
<li>与其他方法相比效率较差</li>
</ul>
<p>Unix</p>
<p>主要分为两层：系统程序、内核</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>微内核方法将所有非基本部分从内核中移走，并将它们实现为系统或用户程序，这样得到了更小的内核。</p>
<p>主要功能：使客户程序和运行在用户空间的各种服务之间进行通信</p>
<p>![image-20211204162248069](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211204162248069.png)</p>
<p>优点：</p>
<ul>
<li>便于扩充操作系统</li>
<li>很容易从一种硬件平台一直到另一种硬件平台设计</li>
<li>安全可靠</li>
</ul>
<p>缺点：由于系统功能总开销的增加导致系统性能下降（用户空间到内核空间通信的性能开销</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>大多数现代操作系统实现内核模块</p>
<ul>
<li>采用面向对象的办法</li>
<li>每个核心组件是分开的</li>
<li>每部分与已知接口的其他部分通信</li>
<li>每部分根据需要加载到内核</li>
</ul>
<p>类似于层，但更加灵活</p>
<p>![image-20211204162902774](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211204162902774.png)</p>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>指可以像真实机器一样运行程序的计算机的软件实现，是通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</p>
<ul>
<li><p>基于宿主操作系统上实现（Host Operating System ）</p>
</li>
<li><p>提供一个虚拟层，将一套真实的硬件系统虚拟成多套硬件系统</p>
</li>
<li><p>在每套虚拟硬件上可以安装不同的操作系统</p>
</li>
</ul>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>概念：进程是执行中的程序。包含了程序代码和当前活动（通过程序计数器和处理器寄存器内容表示）两个部分，当可执行文件加载到内存时，程序变为进程</p>
<p>进程是程序在一个数据集合上的运行活动，是系统进行资源分配和调度的一个独立单位；（汤子赢版）</p>
<p>具体有：</p>
<ul>
<li>文本段（代码段</li>
<li>数据段（全局变量、静态变量</li>
<li>栈（stack）包含临时数据<ul>
<li>函数参数、返回地址、局部变量，随函数调用和返回而增长或缩小</li>
</ul>
</li>
<li>堆（heap）进程运行期间动态分配的内存<ul>
<li>malloc或new</li>
</ul>
</li>
<li>当前活动：程序计数器、堆栈指针、处理器寄存器</li>
<li>PCB：进程控制块</li>
</ul>
<p>程序是被动实体、进程是活动实体</p>
<p>一个程序不能两次属于同一个进程</p>
<ul>
<li>一个程序可被执行多次</li>
<li>每次运行都是一个可执行程序不同的运行活动——OS为其创建的进程也不同</li>
<li>即使每次运行的代码段相同，但处理的数据可能不同</li>
<li>代码段相同、数据段相同，但PCB、进程号、堆、栈等系统分配资源肯定不同</li>
</ul>
<p>一个程序可对应多个进程，一个进程也可以有多个程序段共同完成一项任务</p>
<h2 id="进程的五个基本特征"><a href="#进程的五个基本特征" class="headerlink" title="进程的五个基本特征"></a>进程的五个基本特征</h2><ul>
<li>动态性<ul>
<li>动态性是进程最基本的特征，表现为：进程由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡</li>
<li>进程具有一定的生命期</li>
</ul>
</li>
<li>独立性<ul>
<li>进程实体是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调度的基本单位</li>
<li>在不支持多线程的系统中，进程是CPU独立调度的基本单位<ul>
<li>进程拥有资源，因此在上下文切换时耗时大、运行效率低</li>
<li>支持线程的系统中，进程是独立获得资源的基本单位，线程是独立调度的基本单位</li>
</ul>
</li>
</ul>
</li>
<li>并发性<ul>
<li>多个进程能在一段时间内同时执行</li>
</ul>
</li>
<li>异步性<ul>
<li>进程按各自独立的、不可预知的速度向前推进，进程按照异步方式运行</li>
<li>OS中必须采取措施包整个程序之间能协调运行</li>
</ul>
</li>
<li>结构特征<ul>
<li>从结构上看，进程实体由程序段、数据段、堆、栈、PCB等组成</li>
</ul>
</li>
</ul>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程有五种状态</p>
<ul>
<li>new：进程正在创建中</li>
<li>running：正在执行指令</li>
<li>waiting：进程等待某些事件发生（如IO完成或接收信号</li>
<li>ready：等待分配给处理器</li>
<li>terminated：进程已完成执行</li>
</ul>
<p>![image-20211204170256611](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211204170256611.png)</p>
<ul>
<li>new：进程运行所需信息不完整，尚无法执行</li>
</ul>
<p>用户登陆系统：创建新进程</p>
<h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p>系统为了管理进程设置的一个专门的数据结构，用来记录进程的外部特征，描述进程的运动变化过程</p>
<p>系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志</p>
<p>进程和PCB是一一对应的</p>
<p>PCB内保存的信息</p>
<ul>
<li>进程状态</li>
<li>程序计数器：进程要执行的下个指令的地址</li>
<li>CPU寄存器：与程序计数器一起，在出现中断时状态信息需要保存</li>
<li>CPU调度信息：优先级、调度队列指针</li>
<li>存储管理信息</li>
<li>记账信息：使用 CPU，启动后时钟消耗时间，时间限制</li>
<li>IO状态信息</li>
<li>下一个PCB的指针</li>
</ul>
<p>![image-20211204171624058](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211204171624058.png)</p>
<p>CPU在进程间的切换</p>
<h3 id="PCB表"><a href="#PCB表" class="headerlink" title="PCB表"></a>PCB表</h3><p>PCB表：系统把所有PCB组织在一起，并把它们放在内存的固定区域，就构成了一个系统全局的PCB表</p>
<p>PCB表的大小决定了系统中最多可同时存在的进程个数，称为系统的并发度</p>
<p>一个进程与一个PCB是一一映射</p>
<p>链接结构：同一状态进程的PCB组成一个链表，不同状态的进程对应多个不同链表</p>
<p>索引结构：对具有相同状态的进程，分别设置各自的PCB索引表，表明PCB在PCB表中的地址</p>
<p>单处理机中，进程间不可并行（不是并发）</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>目的：使CPU的利用最大化，需要优化进程调度的方法</p>
<p>进程调度程序选择一个进程到CPU上执行（一个CPU一个时间段只能执行一个程序，其余程序需要等待CPU空闲重新调度</p>
<h3 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h3><ul>
<li><p>作业（Job）队列：包含系统中所有的进程</p>
</li>
<li><p>就绪（ready）队列：包含了系统中的，驻留在内存中就绪的，准备运行的进程。</p>
</li>
<li><p>设备（Device）队列：包含了等待特定IO设备的进程列表</p>
<ul>
<li>进程可能会有IO请求，请求时可能IO设备在处理其他请求，所以需要等待</li>
</ul>
</li>
</ul>
<p>![image-20211204201307469](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211204201307469.png)</p>
<p>![img](E:\OneDrive - mail.sdu.edu.cn\md\image\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70.png)</p>
<h3 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h3><ul>
<li><p>长期调度程序（long-term schedule）&#x2F;作业调度程序（job schedule）</p>
<ul>
<li>负责从缓冲池中选择进程，装入内存以便执行</li>
<li>常用于批处理系统（提交的进程比可立即执行的进程多</li>
<li>不常用（秒、分钟级别</li>
<li>控制进内存中进程的数量</li>
<li>争取IO为主和CPU为主的进程良好混合，以平衡CPU和IO设备的利用率</li>
</ul>
</li>
<li><p>短期调度程序（short-term schedule）&#x2F;CPU调度程序（CPU schedule）</p>
<ul>
<li>从执行的进程中选择进程，并为之分配CPU</li>
<li>频繁调用短期调度（毫秒级</li>
<li>控制CPU的利用率和系统吞吐量</li>
</ul>
</li>
<li><p>中期调度程序</p>
<ul>
<li>将进程从内存（或CPU竞争中）移出，从而降低多道程序设计的难度，之后，进程可被重新调入内存，并从中断处执行</li>
</ul>
</li>
<li><p>进程的类型</p>
<ul>
<li>IO为主（主要是IO传输、许多的CPU bursts</li>
<li>CPU为主（主要是计算，很少的CPU bursts</li>
</ul>
</li>
</ul>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>出现原因</p>
<ul>
<li>中断使CPU从当前任务改变为运行内核子程序，因此当发生中断时，系统需要保存当前程序的上下文，在恢复程序时需要恢复程序的上下文</li>
<li>将CPU切换到另一个进程需要保存当前程序的状态并恢复另一个程序的状态，任务：上下文切换</li>
<li>进程的上下文就是进程的PCB</li>
</ul>
<p>类型：</p>
<ul>
<li>状态保存：保存当前CPU状态（不论是内核模式还是用户模式</li>
<li>状态恢复：重新开始之前保存的状态</li>
</ul>
<p>上下文切换是额外开销，切换时系统不能做其他任何有用的工作。</p>
<p>时间消耗为几毫秒，具体的时间消耗与硬件支持密切相关</p>
<p>有的操作系统提供了多组寄存器集合，上下文切换只需要改变当前寄存器组指针</p>
<h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>进程树：进程执行过程中，能够继续创建进程（系统调用），父进程创建子进程，以此类推形成进程树</p>
<p>一般系统有一个根进程，负责创建其他所有进程，只有一棵</p>
<p>通过进程标识符（PID）识别和管理进程</p>
<p>UNIX的进程0和1</p>
<ul>
<li>0进程：一个特殊进程，在系统引导时被创建</li>
<li>1进程：当0进程fork一个子进程1后，0进程就变成了对换进程（swaper</li>
<li>1进程被称为init进程，是系统中其他每个进程的祖先</li>
<li>进程0是系统中唯一一个不通过fork创建的进程</li>
</ul>
<p>资源共享选项</p>
<ul>
<li>父子进程共享所有资源</li>
<li>子进程获得父进程资源的子集</li>
<li>不共享任何资源</li>
</ul>
<p>地址空间选项</p>
<ul>
<li>父进程的副本（有相同的程序和数据</li>
<li>子进程内装入一个新程序</li>
</ul>
<p>执行选项</p>
<ul>
<li>父子进程并发执行</li>
<li>父进程等待子进程执行完毕</li>
</ul>
<p>关于fork和exec</p>
<ul>
<li>fork命令创建一个新的进程</li>
<li>exec命令在fork命令后执行，用于将新的程序装入进程的内存空间</li>
</ul>
<p>UNIX进程创建</p>
<ul>
<li><p>fork：</p>
<ul>
<li>内核为子进程做一个父进程的上下文的拷贝</li>
<li>子进程与父进程共享子进程创建之前父进程的所有资源</li>
<li>父进程和子进程在不同的地址空间上运行</li>
</ul>
</li>
<li><p>资源共享</p>
<ul>
<li>继承创建之前父进程拥有的所有资源</li>
<li>创建之后，父子进程开始资源分离</li>
</ul>
</li>
<li><p>一般情况下父进程等待子进程结束，并回收子进程</p>
<ul>
<li>收集子进程相关信息，如占用的CPU时间等，归到父进程</li>
<li>进程结束后，其进程表等资源不会被系统释放，父进程回收子进程后才会释放</li>
<li>如果父进程由于执行错误等某种原因被强行终止，会将子进程归属到1号进程</li>
</ul>
</li>
</ul>
<p>内核为系统调用fork完成下列操作：</p>
<ul>
<li><p>为子进程在进程表中分配一个空项（empty slot）(PCB)</p>
</li>
<li><p>为子进程赋予一个唯一的进程标识号(PID)</p>
</li>
<li><p>为子进程分配独立的（内存）地址空间</p>
</li>
<li><p>复制父进程的上下文到子进程的地址空间</p>
<ul>
<li><p>将父进程的PCB、数据、栈、PC等内容到子进程的相应地址空间中</p>
</li>
<li><p>对于代码：子进程可能调用exec()装入一个新的程序而覆盖父进程的代码，因此有的系统不真正将父进程的<strong>代码</strong>复制到一个新的内存物理区，只是增加该取的引用数即可。</p>
</li>
<li><p><strong>注</strong>：子进程的<strong>PCB</strong>中有父进程访问的文件、设备、运行环境等，如打开的文件，PC等；栈中有局部变量；</p>
</li>
</ul>
</li>
<li><p><strong>对父进程返回</strong>子进程的进程号<strong>，对子进程</strong>返回零。</p>
</li>
</ul>
<p>fork的返回值</p>
<ul>
<li>正确执行<ul>
<li>父进程返回子进程的进程号，非零的正整数</li>
<li>子进程，返回0</li>
</ul>
</li>
<li>未成功创建<ul>
<li>返回-1</li>
</ul>
</li>
</ul>
<p>fork的功能</p>
<ul>
<li>内核为子进程做一个父进程的上下文拷贝<ul>
<li>复制父进程的PCB为子进程的PCB</li>
<li>在新的地址空间中复制父进程的一个拷贝（有不同的实现</li>
</ul>
</li>
<li>关于资源<ul>
<li>创建子进程之前父进程的资源：子进程继承</li>
<li>创建子进程之后进程的资源：各自独立</li>
</ul>
</li>
<li>父进程和子进程在不同的地址空间上运行</li>
</ul>
<p>注意：</p>
<p>子进程会继承父进程的缓冲区、文件、设备描述符</p>
<p>PCB：除进程号以外的所有内容</p>
<p>进程退出时均自动清理缓存</p>
<p>注：“\n”, fflush(stdout)都有清空输出缓存的功能</p>
<p>close（fd）的作用</p>
<ul>
<li>释放系统为打开文件所分配的资源，如：文件描述符、文件控制块、文件表中所占用的表项</li>
<li>清空释放读写缓存，将最后写入到缓存的内容物理写入到磁盘的文件中，避免导致副作用</li>
</ul>
<p>系统调用execve</p>
<ul>
<li>执行成功：将用path所指定的可执行文件的副本覆盖调用execve的进程空间，进程号不变，它绝对不会再返回到调用进程</li>
<li>调用失败返回-1</li>
<li>系统调用exec之后，子进程不再执行原来的代码，而是执行新程序</li>
<li>进程中在系统调用exec之后的语句不会被执行</li>
</ul>
<p>系统调用wait</p>
<ul>
<li>如果没有子进程，wait直接返回</li>
<li>子进程结束，父进程尚在运行并且未调用wait，子进程处于zombie僵死状态，并没有被系统撤销，等待父进程回收<ul>
<li>子进程僵死，执行的累计时间加到父进程PCB相应字段中</li>
<li>释放进程表项，可被分配给新进程</li>
</ul>
</li>
<li>子进程尚在运行，父进程未调用wait，而是结束执行退出，子进程成为孤儿进程，将给1号进程代管<ul>
<li>父进程进入睡眠，并在子进程执行完毕后被唤醒</li>
</ul>
</li>
</ul>
<p>创建多个子进程形成进程树的问题</p>
<p>![image-20211207150907900](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211207150907900.png)</p>
<p>![image-20211207150923157](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211207150923157.png)</p>
<p>内核为打开文件维护的3个数据结构</p>
<ul>
<li>进程级的文件描述符表<ul>
<li>每一条目记录了单个文件描述符的相关信息</li>
</ul>
</li>
<li>系统级的（打开）文件表<ul>
<li>给出了一个打开文件相关的全部信息<ul>
<li>当前文件读写偏移量</li>
<li>文件访问模式</li>
<li>对该文件i-node对象的引用</li>
</ul>
</li>
</ul>
</li>
<li>系统级的（文件系统）i-node表（FCB，索引节点表<ul>
<li>文件索引节点表</li>
<li>打开一个文件时，将磁盘上的文件的索引节点装入到内核维护的索引节点表中</li>
<li>设置访问文件是的一些控制信息，如引用数，表示一个文件目前被打开的次数</li>
</ul>
</li>
</ul>
<p>子进程使用相同的文件描述符而继承的存取父进程在创建子进程之前已经打开和创建的文件，因此对于同一个文件也就是用相同的文件表项</p>
<p>signal</p>
<ul>
<li>可以在进程中利用signal()系统调用注册自己定义的信号处理函数，当进程收到该信号后，就执行注册的信号处理函数</li>
<li>如果不注册，则当进程收到该信号后，就执行系统默认的信号处理函数</li>
</ul>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>进程终止时间：</p>
<ul>
<li>执行完最后语句，并使用系统调用exit请求操作系统删除自身</li>
<li>一个进程通过适当的系统调用终止另一个进程（通常这个进程需要是被终止进程的父进程，并且需要知道被终止进程的标识符</li>
</ul>
<p>父进程终止子进程的原因一般有</p>
<ul>
<li>子进程使用的资源超过了父进程分配的资源</li>
<li>分配给子进程的任务不再需要</li>
<li>父进程退出，在这种情况下，操作系统不允许子进程继续<ul>
<li>在有些操作系统中，如果一个进程终止，那么它的所有子进程都终止。这叫做级联终止</li>
</ul>
</li>
</ul>
<p>进程终止后：</p>
<ul>
<li>进程会返回状态值（通常为整数）到父进程，所有进程资源都会被操作系统释放</li>
<li>如果此时父进程终止，那么所有子进程都会以1号进程作为父进程</li>
</ul>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>独立进程：不能影响其他进程且不被其他进程影响</p>
<p>协作进程：能影响其他进程或被其他进程影响</p>
<p>优点：</p>
<ul>
<li>信息共享</li>
<li>提高计算速度：将一个任务分解为子任务，并将多个子任务并行执行</li>
<li>模块化：以模块化方式构建系统，将系统功能划分为独立的进程或线程</li>
<li>方便</li>
</ul>
<p>因此需要一个进程间的通信机制（IPC）来允许进程相互交换数据与信息。</p>
<ul>
<li>共享内存</li>
<li>信息传递</li>
</ul>
<p>在UNIX中有管道，类似于信息传递</p>
<ul>
<li><p>共享内存</p>
<ul>
<li>共享内存应该同时属于要共享该存储区的所有进程的地址空间，否则无法访问</li>
<li>读写时需要进程之间同步</li>
<li>通信结束后需要将共享内存鱼其地址空间剥离</li>
</ul>
</li>
<li><p>消息传递</p>
<ul>
<li>两个操作：发送（消息大小固定或可变），接受</li>
<li>P和Q想要沟通需要并通过发送、接受交换消息</li>
<li>通信链路的实现<ul>
<li>物理的：共享内存、硬件总线或网络</li>
<li>逻辑的：逻辑属性</li>
</ul>
</li>
<li>直接通信</li>
<li>间接通信</li>
</ul>
</li>
</ul>
<p>消息传递可以是阻塞的，也可以是非阻塞的</p>
<ul>
<li>阻塞是同步的</li>
<li>非阻塞是异步的</li>
</ul>
<p>int shmget (key_t key, int size, int shmflg)：新建或获取一段键值为key，大小为size，标志为shmflg的共享内存，返回共享内存标识符</p>
<p>int <strong>msgget</strong>(key_t key, int msgflg)：新建或获取一个消息队列，返回消息队列标识符。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>![image-20211207164353520](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211207164353520.png)</p>
<ul>
<li><p>隶属关系</p>
<ul>
<li>一个进程至少需要一个线程，可以拥有多个线程，这些线程运行在其所属进程的上下文中</li>
<li>线程隶属于进程，线程不能脱离进程而独立存在</li>
<li>一个线程只能属于一个进程</li>
</ul>
</li>
<li><p>拥有资源</p>
<ul>
<li>进程是拥有资源的基本单位，隶属于同一个进程的多个线程共享该进程的代码、数据、堆、打开的文件（包括标准设备）等IO资源</li>
<li>线程不能共享进程（主线程）的栈</li>
<li>因此线程只拥有其运行所必需的资源，如寄存器、栈、程序计数器等</li>
</ul>
</li>
<li><p>CPU调度与分派的基本单位</p>
<ul>
<li>线程是进程的实体，线程运行在其所属进程的上下文中</li>
<li>线程是CPU调度与分派的基本单位（CPU调度</li>
<li>进程不再是一个可执行的实体</li>
</ul>
</li>
</ul>
<p>线程拥有独立的栈和寄存器集的原因</p>
<ul>
<li>栈和寄存器集是定义程序执行的动态上下文的组件</li>
<li>栈会随着函数的调用和返回而增长和收缩，并且每次执行指令后寄存器内容都会发生变化</li>
<li>栈（stack）包含临时数据<ul>
<li>函数参数、返回地址、局部变量，随函数调用和返回而增长或缩小</li>
</ul>
</li>
</ul>
<p>引入进程的原因</p>
<ul>
<li>多个程序并发执行，提高资源利用率，提高系统吞吐量</li>
</ul>
<p>引入线程的原因</p>
<ul>
<li>隶属于同一个进程的多个线程可以并发执行，缩短了进程任务执行时间</li>
<li>减少进程并发执行时所付出的时空开销（如上下文切换），使操作系统有更好的并发性</li>
<li>进一步提高了资源利用率</li>
</ul>
<p>进程的劣势</p>
<ul>
<li><p>进程是资源的拥有者，因此在进程的创建、撤销以及切换中，系统必须为之付出很大地时空开销</p>
</li>
<li><p>进程切换的频率不宜过高</p>
</li>
<li><p>系统中设置的进程数目不宜过多</p>
</li>
<li><p>限制了并发程度的进一步提高</p>
</li>
</ul>
<p>将进程的两个属性分开，作为独立分配资源的单位，不作为调度和分派的基本单位</p>
<p>调度</p>
<ul>
<li>同一进程中，线程的切换不会引起进程切换</li>
<li>不同进程中的线程之间的切换要引起进程的切换</li>
</ul>
<p>并发性</p>
<ul>
<li>引入线程的系统中，同一进程的多个线之间可以并发执行，使系统具有更好的并发性，进一步提高了资源利用率和系统吞吐量</li>
</ul>
<p>优点</p>
<ul>
<li>响应性：允许程序在某些部分被阻塞或长时间操作的情况下继续运行</li>
<li>资源共享：线程共享他们所隶属的内存和资源</li>
<li>经济：为创建进程分配的内存和资源是相同的，上下文切换也是一样的</li>
<li>MP架构的使用：单线程进程只能运行在一个CPU上，而属于一个进程的线程可以运行在不同的CPU上</li>
</ul>
<p>拥有资源</p>
<ul>
<li>进程是拥有资源的独立单位；</li>
<li>线程仅拥有比不可少的资源，可以访问其隶属进程的资源；例如进程的代码段、数据段及系统资源，如已打开的文件、I&#x2F;O设备等，可供同一进程的线程共享；</li>
</ul>
<p>系统开销</p>
<ul>
<li><p>系统创建及撤销进程时的开销远远大于创建及撤销线程时的开销；</p>
</li>
<li><p>进程切换时的开销也远远大于线程切换时的开销；</p>
</li>
<li><p>由于同一进程中的多个线程具有相同的地址空间，致使他们之间的同步和通信的实现，也变得比较容易；</p>
</li>
<li><p>在有的OS中，线程的切换、同步和通信都无需OS内核的干预；</p>
</li>
</ul>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>用户级线程：管理无需通过核心线程干预</p>
<p>核心线程：用户级线程的运行需要映射到相应的核心线程才能完成</p>
<p>用户级线程</p>
<ul>
<li><p>存在于用户空间中，创建、撤销、线程间同步与通信等功能无需利用系统调用来实现，是通过用户级线程库来实现（如pthread</p>
</li>
<li><p>用户级线程的切换也无需内核的支持，通过用户级线程库来管理</p>
</li>
<li><p>切换规则比进程调度和切换规则简单，线程切换速度特别快</p>
</li>
<li><p>线程的管理是与内核无关的，不需要通过系统调用来完成</p>
</li>
<li><p>核心感知不到用户级线程的存在</p>
</li>
<li><p>执行时，需要将用户线程映射到核心线程，由核心线程控制用户线程的执行</p>
<ul>
<li><p>如果OS不支持多线程机制，OS内核只能感知到进程的存在（一个线程），因此即使用户创建了多个用户线程，这些用户线程也不能分派到多个CPU上并行执行；</p>
<p><strong>当正在执行的用户线程被阻塞，进程就被阻塞，其他用户线程也无法执行；</strong></p>
</li>
</ul>
</li>
</ul>
<p>三个主要的线程库</p>
<ul>
<li><p>POSIX Pthreads (for the user-level library-pthread)用户级线程库</p>
</li>
<li><p>Win32 threads (user-level library)用户级</p>
</li>
<li><p>Java threads (Windows,UNXI and Linux, for the user-level library)用户级</p>
</li>
</ul>
<p>线程</p>
<ul>
<li>系统支持线程，核心线程的管理由内核完成</li>
<li>现成的创建、撤销和切换都是依靠内核来实现</li>
<li>需要直接或间接通过系统调用来完成</li>
<li>线程控制块（TCB）：内核通过TCB感知线程存在，并对其加以控制</li>
<li>内核支持线程是OS内核可感知的，用户级线程不可感知</li>
<li>OS只为核心线程分配CPU等资源</li>
</ul>
<p>映射模型</p>
<ul>
<li><p>多对一：许多用户级线程映射到单个内核线程</p>
<ul>
<li><p>优点</p>
<ul>
<li>线程管理由用户空间中的线程库完成，效率高</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>一次只有一个线程可以访问内核</li>
<li>多线程无法在多处理器上并行运行</li>
<li>如果一个线程进行阻塞，整个进程将会阻塞</li>
</ul>
</li>
<li><p>用户不支持线程的系统</p>
</li>
</ul>
</li>
<li><p>一对一模型：每个用户线程映射到一个内核线程上</p>
<ul>
<li>优点：<ul>
<li>比多对一模型有更好的并发性</li>
<li>一个线程阻塞时，其他线程能够继续调用</li>
<li>多个线程能够并发运行在多处理器</li>
</ul>
</li>
<li>缺点：<ul>
<li>创建内核线程的开销会影响应用程序的功能</li>
</ul>
</li>
</ul>
</li>
<li><p>多对多模型：将许多用户级线程多路复用成更少或相等数量的内核线程</p>
<ul>
<li>开发人员可以根据需要创建多个用户线程</li>
<li>允许多个线程在多处理器上并行运行</li>
</ul>
</li>
</ul>
<h2 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h2><p>线程库为程序员提供了创建和管理线程的API</p>
<p>&#x3D;&#x3D;实现线程库的两种方法&#x3D;&#x3D;</p>
<ul>
<li>提供一个完全位于用户空间的库，不提供内核支持<ul>
<li>用户空间中的所有代码和数据结构都存在于用户空间中</li>
<li>调用库中的函数导致用户空间中的本地呼叫，而不是系统调用</li>
</ul>
</li>
<li>提供内核直接支持的内核级库<ul>
<li>库空间中的所有代码和数据结构都存在于内核空间中</li>
<li>调用库中API中的函数通常会导致对内核的系统调用</li>
</ul>
</li>
</ul>
<h2 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h2><p>系统调用fork和exec</p>
<ul>
<li><p>程序中一个线程调用了fork，两种解决方案</p>
<ul>
<li>复制所有线程</li>
<li>只复制调用了系统调用fork的线程</li>
</ul>
</li>
<li><p>exec工作方式</p>
<ul>
<li>如果一个线程调用exec，那么exec参数指定的程序会替换整个进程，包括所有线程</li>
</ul>
</li>
<li><p>如果fork之后立即调用exec，那么没必要复制所有线程</p>
</li>
<li><p>如果fork后不调用exec，那么另一进程应该复制所有线程</p>
</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>用于服务器上，如web服务器</p>
<p>请求到来时为其创建一个线程，并在完成工作后丢弃它</p>
<p>问题：浪费时间、没有效率，无限线程可能耗尽系统资源</p>
<p>解决方案：线程池</p>
<ul>
<li><p>在进程开始时创建一定数量的线程，并放入到池中以等待工作。当服务器收到请求时，唤醒池中的一个线程，并将要处理的请求传递给它，一旦线程完成了任务，它会返回池中等待下一个工作。若池中没有可用线程，服务器会一直等待知道有空线程为止</p>
</li>
<li><p>优点:</p>
<ul>
<li>通常用现有线程处理请求要比等待创建新的线程要快</li>
<li>线程池限制了在任何时候可用线程的数量</li>
</ul>
</li>
</ul>
<h1 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h1><p>在多重程序操作系统中</p>
<ul>
<li>多个进程同时保存在内存中</li>
<li>每当进程阻塞时，另一个进程可以接管CPU<ul>
<li>最大化CPU利用率、由CPU调度实现</li>
</ul>
</li>
</ul>
<p>调度是操作系统的基本功能，CPU调度是操作系统设计的核心</p>
<p>CPU调度也叫：进程调度或线程调度</p>
<p>进程的行为或属性</p>
<ul>
<li>大部分的进程，其CPU执行区间和IO执行区间是交替进行的</li>
<li>CPU执行区间与IO执行区间有时称为CPU执行器与IO执行期</li>
</ul>
<p>进程执行从CPU区间（CPU burst）开始，之后IO区间（IO burst）和CPU区间交替执行，最终最后的CPU区间通过系统请求中止执行</p>
<p>经过大量CPU区间的长度测试发现</p>
<ul>
<li>短的CPU区间数量多，长CPU区间数量少</li>
<li>IO约束程序通常具有很多短CPU区间，CPU约束程序可能有少量的长CPU区间</li>
</ul>
<p>这种分布有助于选择合适的CPU调度算法</p>
<h3 id="CPU程序调度"><a href="#CPU程序调度" class="headerlink" title="CPU程序调度"></a>CPU程序调度</h3><p>当CPU空闲时，操作系统必须从就绪队列中选择一个进程来执行。进程选择由短期调度程序或CPU调度程序执行。调度程序从内存中选择一个能够执行的进程，并为之分配CPU</p>
<p>就绪队列可以实现为</p>
<ul>
<li>先进先出队列</li>
<li>优先队列</li>
<li>树</li>
<li>无序链表</li>
</ul>
<p>就绪队列中的记录通常为PCB</p>
<h3 id="抢占调度"><a href="#抢占调度" class="headerlink" title="抢占调度"></a>抢占调度</h3><p>非抢先式调度</p>
<ul>
<li>又称为非剥夺式调度</li>
<li>分派程序一旦把处理机分配给某进程后便让它一直运行下去，知道进程执行结束（或错误退出），或者进程等待某事件而被阻塞时，才把处理机分配给另一个进程</li>
</ul>
<p>抢先式调度</p>
<ul>
<li>又称为剥夺式调度</li>
<li>当线程&#x2F;进程正在处理器上运行时，系统可根据所规定的原则剥夺（抢先）分配给此进程&#x2F;线程的处理器的执行权，将其移入就绪队列中，选择调度其他进程&#x2F;线程执行</li>
<li>一个进程的CPU burst被分割成多个执行段</li>
</ul>
<p>![image-20211207204957008](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211207204957008.png)</p>
<p>当调度只能发生在1和4两种情况下：非抢占的</p>
<p>否则是抢占的</p>
<p>进程在操作系统内核程序临界区中不能进行调度与切换：√</p>
<p>进程处于临界区时不能进行处理及调度：×</p>
<p>临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥的访问临界资源</p>
<p>临界区：访问临界资源的那段代码</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列</p>
<h3 id="分派程序"><a href="#分派程序" class="headerlink" title="分派程序"></a>分派程序</h3><p>分派程序（dispatch）是一个模块，用来将CPU的控制交给由短期调度程序选择的进程</p>
<p>功能包括</p>
<ul>
<li>切换上下文</li>
<li>切换到用户模式</li>
<li>跳转到用户程序的合适位置，以重新启动程序</li>
</ul>
<p>分派程序停止一个进程而启动另一个所花费的时间称为分派延迟</p>
<h2 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h2><ul>
<li><p>CPU利用率：要使CPU尽可能忙</p>
</li>
<li><p>吞吐量：指一个时间单元内所完成的进程的数量</p>
</li>
<li><p>周转时间：从进程提交到进程完成的时间段称为周转时间</p>
<ul>
<li>周转时间是所有时间段之和，包括等待进入内存、在就绪队列中等待、在CPU上执行和IO执行</li>
</ul>
</li>
<li><p>等待时间：在就绪队列中等待所花费的时间之和</p>
<ul>
<li>CPU调度算法只影响等待时间</li>
</ul>
</li>
<li><p>响应时间：从提交请求到产生第一响应的时间</p>
<ul>
<li>在交互式系统中，周转时间可能不是最好的标准，周转时间通常收到输出设备的速度限制</li>
</ul>
</li>
</ul>
<p>需要使CPU使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。</p>
<p>绝大多数情况下需要优化平均值，有时需要优化最大值或最小值，而不是平均值</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先到先服务调度-First-Come，First-Served-scheduling"><a href="#先到先服务调度-First-Come，First-Served-scheduling" class="headerlink" title="先到先服务调度(First-Come，First-Served scheduling)"></a>先到先服务调度(First-Come，First-Served scheduling)</h3><p>貌似公平</p>
<p>护航效应：短进程落后于长进程，所有其他进程都等待一个大进程释放CPU</p>
<p>有利于长作业，对短作业不利，系统吞吐量小</p>
<p>该算法通常作为其他调度算法的基本算法</p>
<p>非抢占</p>
<h3 id="最短作业优先算法（shortest-job-first-scheduling-SJF"><a href="#最短作业优先算法（shortest-job-first-scheduling-SJF" class="headerlink" title="最短作业优先算法（shortest-job-first scheduling,SJF"></a>最短作业优先算法（shortest-job-first scheduling,SJF</h3><p>将每个进程关联他的下一个CPU burst的长度，CPU空闲时将分配给具有最短CPU区间的进程</p>
<p>两个方案</p>
<ul>
<li>非抢占：一旦进程分配给一个CPU，就不能被抢占，直到CPU区间执行完毕</li>
<li>抢占：新进程到达时，其CPU区间小于当前执行的进程的剩余时间，则抢占<ul>
<li>又被称为最短剩余时间优先（SRTF</li>
</ul>
</li>
</ul>
<p>平均等待时间最小，但是困难在于如何确定下一个CPU区间的长度</p>
<ul>
<li>系统吞吐量大，平均周转时间短</li>
<li>有利于短作业，不利于长作业</li>
<li>饥饿问题：进程长时间得不到调度</li>
</ul>
<h3 id="优先级调度-priority-scheduling-algorithm"><a href="#优先级调度-priority-scheduling-algorithm" class="headerlink" title="优先级调度(priority scheduling algorithm)"></a>优先级调度(priority scheduling algorithm)</h3><p>将每个进程与优先级相关联，CPU优先分配给优先级高的进程</p>
<p>优先级定义方式</p>
<ul>
<li>内部定义<ul>
<li>使用可测量的数据来计算：时间限制、内存要求、打开文件数量、平均IP区间的比率</li>
</ul>
</li>
<li>外部定义<ul>
<li>操作系统之外的标准：进程的重要性等</li>
</ul>
</li>
</ul>
<p>优先级调度可以是</p>
<ul>
<li>抢占的</li>
<li>非抢占的</li>
</ul>
<p>调度算法的一个重要问题，无限阻塞或者饥饿问题。可以运行但是等待CPU的进程可认为是阻塞的，优先级调度算法会使某个有低优先级的进程无穷等待CPU</p>
<p>解决方式：老化（aging）逐渐增加在系统中等待的进程的优先级</p>
<p>高响应比调度算法</p>
<ul>
<li><p>优先级（相应比）&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间&#x3D;（等待时间&#x2F;要求服务时间）+1</p>
</li>
<li><p>每次调度时，系统重新计算各作业或各进程的相应比</p>
</li>
<li><p>算法既照顾了短作业，又考虑了作业到达的先后次序，也不会使得长作业长期得不到服务</p>
</li>
</ul>
<p>IO时间多的进程应该优先得到被调度程序选中的机会，才可以使CPU与IO设备并行工作</p>
<h3 id="轮转法调度-round-robin-RR"><a href="#轮转法调度-round-robin-RR" class="headerlink" title="轮转法调度(round-robin,RR)"></a>轮转法调度(round-robin,RR)</h3><p>专门为分时系统设计</p>
<p>类似FCFS调度，但增加了抢占以切换进程</p>
<p>定义一个较小的时间单元称为时间片，将就绪队列作为循环队列。CPU调度程序循环就绪队列，为每个进程分配不超过一个时间片的CPU</p>
<p>算法性能依赖于时间片的大小</p>
<p>时间片非常大——RR算法与FCFS算法一样</p>
<p>时间片很小——处理器共享，性能变为$1&#x2F;n$</p>
<h3 id="多级队列调度-Multilevel-Queue-Scheduling"><a href="#多级队列调度-Multilevel-Queue-Scheduling" class="headerlink" title="多级队列调度(Multilevel Queue Scheduling)"></a>多级队列调度(Multilevel Queue Scheduling)</h3><p>比如前台（交互）进程和后台（批处理）进程相变比，前台进程有更高的响应时间要求，因此有更高的优先级</p>
<ul>
<li><p>将就绪队列依照进程的类型将其分为多个队列，每个队列设置相应的优先级</p>
</li>
<li><p>每个队列有自己的调度算法</p>
<ul>
<li>比如前台队列采用RR，后台队列采用FCFS</li>
</ul>
</li>
<li><p>队列之间必须有调度</p>
<ul>
<li>通常采用固定优先级抢占调度（有饥饿的可能性<ul>
<li>只有当高优先级队列为空的时候，才调度低优先级队列中的进程</li>
</ul>
</li>
<li>时间片：在队列间划分时间片（80%的时间在前台，20%的时间在后台<ul>
<li>高优先级队列中的进程获得更多的CPU执行时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多级反馈队列调度-Multilevel-Feedback-Queue-Scheduling"><a href="#多级反馈队列调度-Multilevel-Feedback-Queue-Scheduling" class="headerlink" title="多级反馈队列调度(Multilevel Feedback-Queue Scheduling)"></a>多级反馈队列调度(Multilevel Feedback-Queue Scheduling)</h3><p>多级反馈队列调度允许进程在队列之间移动</p>
<p>根据不同CPU区间的特点以区分进程</p>
<ul>
<li>进程使用过多的CPU时间——移到较低优先级队列</li>
<li>将IO约束和交互进程留在更高优先级队列</li>
<li>在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列——防止饥饿</li>
</ul>
<p>通常，多级反馈队列调度程序可由下列参数来定义</p>
<ul>
<li>队列数量</li>
<li>每个队列的调度算法</li>
<li>用以确定何时升级&#x2F;降级到更高&#x2F;更低优先级队列的方法</li>
<li>用以确定进程在需要服务时应进入哪个队列的方法</li>
</ul>
<p>特点</p>
<ul>
<li>不同队伍有不同的优先级</li>
<li>不同队伍有不同的调度算法</li>
<li>不同的队伍有不同的时间片总量</li>
<li>只有高优先级的队列为空时，才会调度低优先级队列</li>
<li>当一个进程执行完一个时间片，但尚未结束，则降级进入低级队列</li>
<li>创建进程进入最高优先级队列</li>
</ul>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><ul>
<li>本地调度：线程库如何决定哪个线程被调度<ul>
<li>选择用户线程与核心线程的映射顺序</li>
</ul>
</li>
<li>全局调度：内核如何决定接下来执行那一个线程<ul>
<li>调度核心线程获得CPU执行权</li>
</ul>
</li>
</ul>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><ul>
<li><p>同步：进程之间需要协作</p>
<ul>
<li>操作之间的偏序关系</li>
</ul>
</li>
<li><p>互斥：进程需要共享哪一些资源</p>
</li>
</ul>
<p>偏序关系图</p>
<ul>
<li>操作A必须在操作B开始之前完成，称A为B的前驱</li>
<li>偏序图中圆圈表示操作，有向弧连接两个操作，说明操作之间的偏序关系</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>同步的概念</p>
<p>并发执行环境下，保持操作之间的偏序关系的行为，称为同步</p>
<p>应用程序实现同步</p>
<p>如何实现：</p>
<ul>
<li>执行一个操作之前，程序判断是否具备执行的条件<ul>
<li>偏序图中在它之前的那些操作是否已经结束执行</li>
<li>执行过程中判断，动态判断</li>
</ul>
</li>
<li>没执行完则需等待</li>
</ul>
<p>临界资源</p>
<p>在一段时间内只允许一个进程访问的资源</p>
<p>互斥的概念</p>
<ul>
<li><p>定义：临界资源不能同时访问</p>
</li>
<li><p>互斥是对操作之间并发执行的约束</p>
</li>
</ul>
<p>实现</p>
<ul>
<li>另一操作正在使用临界资源，则当前操作必须等待</li>
<li>单处理机中，存在并发，并不能自动满足互斥的条件</li>
</ul>
<p>互斥的原因</p>
<ul>
<li>与资源有关</li>
<li>和操作有关：读&#x2F;写</li>
</ul>
<p>伯恩斯坦条件：读&#x2F;写、写&#x2F;写操作不能同时访问同一个资源</p>
<p>背景</p>
<ul>
<li>进程可以并发执行</li>
<li>进程可随时中端、导致部分完成执行</li>
<li>并发访问共享数据可能导致数据不一致</li>
<li>维护数据一致性需要确保协作过程有序执行</li>
</ul>
<p><strong>竞争条件</strong> ：多个并发进程同时访问和操作共享数据且执行结果与访问发生的特定顺序有关</p>
<p>原子操作：不间断的完整完成的操作</p>
<ul>
<li>一个操作中的所有动作要么全做，要么全不做</li>
<li>操作不可分割、不允许中断</li>
<li>原子操作在核心态下运行</li>
<li>常驻内存</li>
</ul>
<p>原语</p>
<ul>
<li>完成一定功能的一个过程</li>
<li>是原子操作、不允许中断</li>
</ul>
<p>临界资源</p>
<ul>
<li>一段时间内只允许一个进程访问的资源</li>
<li>互斥的共享、互斥的访问</li>
</ul>
<p>临界区</p>
<ul>
<li>程序中访问临界资源的那段代码</li>
<li>进程对临界区必须互斥的访问</li>
<li>将对临界资源的互斥访问转化为对临界区的互斥访问</li>
</ul>
<h3 id="解决临界区问题"><a href="#解决临界区问题" class="headerlink" title="解决临界区问题"></a>解决临界区问题</h3><ul>
<li>互斥：忙则等待，保证临界区互斥访问</li>
<li>前进：有空让进，当无进程在临界区执行时，若有进程进入应允许，否则可能会出现饥饿现象</li>
<li>有限等待：当一个进程申请进入临界区，应限制其他进程进入临界区的次数，以便申请的进程有机会进入临界区</li>
<li>让权等待：等待的时候释放CPU的执行权（非必须</li>
</ul>
<p>两种方法用于处理操作系统内的临界区问题</p>
<ul>
<li>抢占内核：允许处于内核模式的进程被抢占</li>
<li>非抢占内核：不允许内核模式的进程被抢占</li>
</ul>
<p>非抢占内核的内核数据结构从根本上不会导致竞争条件，对于抢占内核需要认真设计以确保内核数据结构不会导致竞争条件</p>
<p>但抢占内核更受欢迎，</p>
<ul>
<li>更适合实时编程，能允许实时进程抢占处于内核模式运行的其他进程。</li>
<li>响应更快，处于内核模式的进程在释放CPU之前不会运行过久</li>
</ul>
<h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><p>一种经典的基于软件的临界区问题算法</p>
<p>在两个进程之间共享两个数据项</p>
<blockquote>
<p>int turn; &#x2F;&#x2F;turn表示哪个进程可以进入临界区：若turn&#x3D;&#x3D;i，则进程i允许进入临界区内执行</p>
<p>boolean flag[2];&#x2F;&#x2F;表示哪个进程想要进入临界区</p>
</blockquote>
<p>变量turn相当于门票或令牌</p>
<ul>
<li>获得令牌，进入，没获得令牌，等待</li>
<li>退出时移交令牌</li>
<li>两进程轮流访问临界资源</li>
</ul>
<blockquote>
<p>进程Pi</p>
<p>do{ </p>
<p>flag[i]&#x3D;TRUE;</p>
<p>turn&#x3D;j;</p>
<p>while(flag[j]&amp;&amp;turn&#x3D;&#x3D;j);</p>
<pre><code>临界区
</code></pre>
<p>flag[i]&#x3D;FALSE;</p>
<pre><code>剩余区 
</code></pre>
<p>}while(TRUE)</p>
</blockquote>
<p>一种谦让过程</p>
<p>Pi：已准备好，但先让turn&#x3D;j，查看Pj是否要运行</p>
<p>登记+令牌</p>
<ul>
<li>登记，并把令牌交给另一个进程</li>
<li>退出时消除登记信息</li>
<li>若双方都已登记，拥有令牌的进程会进入</li>
<li>对方尚未登记，但拥有令牌，自己会进入</li>
<li>对方已登记且用有令牌，自己等待</li>
<li>进入时令该令牌转交</li>
</ul>
<p>满足三个条件</p>
<h2 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h2><p>单处理器——禁止中断</p>
<ul>
<li>当前运行的代码将在没有抢占的情况下运行</li>
<li>同上在多处理器上效率太低、耗费时间</li>
<li>使用这种方法的操作系统不能广泛的拓展</li>
</ul>
<p>锁机制</p>
<p>进入临界区前需要得到锁，退出临界区时需要释放锁</p>
<blockquote>
<p>do{<br>请求锁<br> 临界区<br>释放锁<br> 剩余区<br>}while(TRUE)</p>
</blockquote>
<p>特殊硬件指令以允许能原子的（不可中断）检查和修改字的内容或交换两个字的内容</p>
<p>TestAndSet 指令：两个指令同时执行在不同的CPU上，那么它们会按任意顺序来顺序执行</p>
<blockquote>
<p>boolean <strong>TestAndSe</strong>t (boolean *target)<br>    {<br>​        boolean rv &#x3D; *target;  <strong>&#x2F;&#x2F;取锁的状态(test)</strong><br>​        *target &#x3D; TRUE;      <strong>&#x2F;&#x2F;加锁(set)</strong><br>​        return rv:           <strong>&#x2F;&#x2F;返回锁原来的状态</strong><br>​     }</p>
</blockquote>
<p>使用方式</p>
<blockquote>
<p>do{<br> while(TestAndSetLock(&amp;lock);&#x2F;&#x2F;do nothing<br>     &#x2F;&#x2F;critical section<br> lock&#x3D;FALSE;<br>     &#x2F;&#x2F;remainder section<br>}while(TRUE);</p>
</blockquote>
<p>swap指令：互换两个变量的值</p>
<blockquote>
<p>void Swap(boolean *a,boolean *b)<br>{<br>boolean temp&#x3D;*a;<br>*a&#x3D;*b;<br>*b&#x3D;temp;<br>}</p>
</blockquote>
<p>使用方式</p>
<blockquote>
<p>do{<br> key&#x3D;TRUE;<br> while(key&#x3D;&#x3D;TRUE)<br>     Swap(&amp;lock,&amp;key);<br>    &#x2F;&#x2F; <em>key 与lock的值互换，lock now is true,</em><br>    &#x2F;&#x2F; <em>if lock原值为false，then key now is false;</em><br>    <strong>&#x2F;&#x2F;如果原来已经加锁，<strong><strong>自己也加锁，</strong></strong>并等待</strong></p>
<p>​        &#x2F;&#x2F;critical section<br>​    lock&#x3D;FALSE;<br>​        &#x2F;&#x2F;remainder section<br>}while(TRUE);</p>
</blockquote>
<p>这两种算法解决了互斥，但没有解决有限等待，因为所有的程序执行均为随即执行</p>
<p>解决有限等待的算法</p>
<blockquote>
<p>do{<br>waiting[i]&#x3D;TRUE;<br>key&#x3D;TRUE;<br>while(waiting[i]&amp;&amp;key)<br> key&#x3D;TestAndSet(&amp;lock);<br>waiting[i]&#x3D;FALSE;<br> &#x2F;&#x2F;critical section<br>j&#x3D;(i+1)%n;<br>while((j!&#x3D;i)&amp;&amp;!waiting[j])<br> j&#x3D;(j+1)%n;<br>if(j&#x3D;&#x3D;i)<br> lock&#x3D;FALSE;<br>else<br> waiting[j]&#x3D;FALSE<br> &#x2F;&#x2F;remainder section<br>}while(TRUE);</p>
</blockquote>
<p>为了满足有限等待，当一个进程退出其临界区时，它会循环地扫描数组waiting[i]并根据这一顺序而指派第一个等待进程作为下一个进入临界区的进程。因此，任何等待进入临界区的进程只需要等待n−1次。<br>然而，对于硬件设计人员，在多处理器上实现原子指令TestAndSet并不简单。</p>
<h2 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h2><p>应用层面解决临界区问题：信号量</p>
<p>一个不需要忙等待的同步工具</p>
<ul>
<li>整型变量 Semaphore S<ul>
<li>受保护，只能赋值或wait（）or  signal（）</li>
</ul>
</li>
<li>两个标准操作：wait（）   signal（）<ul>
<li>又称为P、V操作</li>
</ul>
</li>
<li>操作为原子操作、不可中断</li>
</ul>
<p>定义</p>
<blockquote>
<p>wait(S)<br>{<br>while(S&lt;&#x3D;0)<br> ;&#x2F;&#x2F;no-op<br>S–;<br>}</p>
</blockquote>
<blockquote>
<p>signal(S)<br>{<br>S++;<br>}</p>
</blockquote>
<p>用法</p>
<ul>
<li>计数信号量：值域不受限制</li>
<li>二进制信号量：为0或为1</li>
</ul>
<blockquote>
<p>do<br>{<br>wait(mutex);<br> &#x2F;&#x2F;critical section<br>signal(mutex);<br> &#x2F;&#x2F;remainder section<br>}while(TRUE);</p>
</blockquote>
<p>实现</p>
<p>wait和signal修改共享变量semaphore，因此也是临界区</p>
<p>忙等待：在进入代码段中连续的循环</p>
<p>这种类型的信号量也称为自旋锁</p>
<ul>
<li>优点<ul>
<li>不用进行上下文切换，减少了系统开销</li>
<li>若锁占用的时间短，就很有用</li>
<li>实现代码短</li>
<li>常用于多处理器系统中</li>
</ul>
</li>
<li>缺点<ul>
<li>浪费CPU时钟</li>
</ul>
</li>
</ul>
<p>解决方式</p>
<ul>
<li>每个信号量有一个关联队列，队列中有两个数据信息<ul>
<li>值：整型变量</li>
<li>队列中下一个记录的指针</li>
</ul>
</li>
<li>两个操作<ul>
<li>block：将调用操作的进程放在一个合适的等待队列上    <ul>
<li>将调用它的进程挂起</li>
</ul>
</li>
<li>wakeup（P）：将一个进程从等待队列中移除并放置在就绪队列中<ul>
<li>恢复进程P的执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此信号量定义如下</p>
<blockquote>
<p>typedef struct<br>{<br> int value;                  &#x2F;&#x2F;记录了这个信号量的值<br> struct process *list;       &#x2F;&#x2F;储存正在等待这个信号量的进程（PCB链表指针）<br>}semaphore;</p>
</blockquote>
<p>因此wait和signal定义修改如下</p>
<blockquote>
<p>wait(semaphore *S)<br>     {<br>S-&gt;value–;<br>if(S-&gt;value&lt;0)                  &#x2F;&#x2F;没有资源<br>{<br>add this process to S-&gt;list;      &#x2F;&#x2F;进入等待队列<br>block();                          &#x2F;&#x2F;堵塞<br>}<br>}</p>
<p>signal(semaphore *S)<br>{<br> S-&gt;value++;<br> if(S-&gt;value&lt;&#x3D;0)<br> {                  &#x2F;&#x2F;上面++后，S仍然还&lt;&#x3D;0，说明资源供不应求，等待者还有很多，于是唤醒等待队列中的一个<br>     remove a process P from S-&gt;list;<br>     wakeup(P);                        &#x2F;&#x2F;切换到就绪状态<br> }<br>}</p>
</blockquote>
<p>资源信号量：s.value的初值代表系统中某类资源的数目</p>
<p>当s.value&lt;0，其绝对值代表在信号量链表队列S.L的长度，即在该信号量下等待的进程数</p>
<h3 id="死锁与饥饿"><a href="#死锁与饥饿" class="headerlink" title="死锁与饥饿"></a>死锁与饥饿</h3><p>死锁：两个或多个进程无限地等待一个时间，而该事件只能由这些等待进程之一来产生</p>
<p>饥饿：进程在信号量内无限期等待</p>
<p>解决思路</p>
<ul>
<li>将相关问题抽象为前驱图<ul>
<li>节点是进程所对应的需要协调的操作</li>
<li>边是进程之间的依赖关系</li>
</ul>
</li>
<li>每条边设置一个信号量</li>
<li>根据问题设置信号量初值</li>
<li>对于每一个节点<ul>
<li>若有入边，需要在协调的操作前加wait，信号量与其前驱中signal使用的相同<ul>
<li>wait个数与其入边的数目相同</li>
</ul>
</li>
<li>如果有出边，需要在协调的操作后加signal，信号量与其后继中wait使用的相同<ul>
<li>signal个数与其出边的数目相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p><strong>一个生产者、一个消费者，共享一个缓冲区</strong></p>
<ul>
<li>一个输入进程向缓冲区中放入数据，输出进程冲缓冲区将数据输出</li>
<li>缓冲区每次只能放一个数</li>
<li>开始时为空</li>
</ul>
<p>算法描述三要素</p>
<ul>
<li>信号量设置</li>
<li>信号量初值</li>
<li>算法描述</li>
</ul>
<blockquote>
<p>semaphore empty&#x3D;1,full&#x3D;0;</p>
<p>生产者（输入进程）结构</p>
<p><strong>do {</strong><br>​    <strong>生成出一件产品；</strong><br>​     <strong>…</strong><br><strong>wait(empty);</strong><br>​    <strong>…</strong><br>add <strong>data</strong> to buffer<br>​    <strong>…</strong><br><strong>signal(full);</strong><br><strong>} while (1);</strong></p>
<p>消费者（输出进程）结构</p>
<p><strong>do {</strong><br><strong>wait(full)；</strong><br>​     <strong>…</strong><br>remove data from buffer；<br>​     <strong>…</strong><br><strong>signal(empty);</strong><br>​       <strong>…</strong><br><strong>消费取走的产品；</strong><br><strong>} while (1);</strong></p>
</blockquote>
<p><strong>一个生产者，一个消费者，共享N个缓冲区</strong></p>
<p>缓冲区编号从0~N-1</p>
<ul>
<li><p>设下标in跟踪生产者的送数过程，初始为0，每送入一个数据，in&#x3D;(in+1)%N</p>
</li>
<li><p>设下标out记录消费者的取数过程，初始为0，每取走一个数据，out&#x3D;(out+1)%N</p>
</li>
</ul>
<blockquote>
<p>semaphore empty&#x3D;n,full&#x3D;0;</p>
<p>int in,out;</p>
</blockquote>
<p><strong>多个生产者，多个消费者，共享N个缓冲区</strong></p>
<ul>
<li>生产者进程<ul>
<li>共享变量 in </li>
<li>互斥信号量</li>
</ul>
</li>
<li>消费者进程<ul>
<li>共享变量out</li>
<li>互斥信号量</li>
</ul>
</li>
<li>协同信号量</li>
</ul>
<blockquote>
<p>semaphore mutex1&#x3D;1,mutex2&#x3D;1,empty&#x3D;N,full&#x3D;0;</p>
<p>int in&#x3D;0;out&#x3D;0</p>
<p>先同步，申请缓冲池</p>
<p>再互斥，生产者消费者自己互斥</p>
</blockquote>
<p>为简化P-C模型的实现，将缓冲池视为一个临界资源；<br>生产者与消费者均互斥访问缓冲池；</p>
<p>总结</p>
<ul>
<li>wait和signal操作成对出现<ul>
<li>互斥信号量，成对出现在一个程序中</li>
<li>同步信号量，出现在不同程序中</li>
</ul>
</li>
<li>同步在前，互斥在后</li>
</ul>
<p><strong>一个共享对象，多个读者可同时访问，只允许一个写者访问</strong></p>
<ul>
<li>读读不互斥</li>
<li>读写互斥</li>
<li>写写互斥</li>
</ul>
<p>分析</p>
<ul>
<li>写者之间简单互斥</li>
<li>读者：两个特殊读者<ul>
<li>第一个进入的：拒绝写者</li>
<li>最后一个离开的：释放锁，唤醒写者</li>
</ul>
</li>
</ul>
<blockquote>
<p>semaphore mutex;&#x2F;&#x2F;用于互斥readcount的修改</p>
<p>semaphore wrt;&#x2F;&#x2F;写者互斥锁</p>
<p>int readcount;</p>
<p>The structure of a writer process</p>
<p>while (true) {<br>​     wait (wrt) ;<br>​     &#x2F;&#x2F; writing is performing;<br>​      signal (wrt) ;<br>}</p>
<p>The structure of a reader process   </p>
<p>​    while (true) {<br>​       wait (mutex) ;<br>​       readcount ++ ;<br>​       if (readcount &#x3D;&#x3D; 1) wait (wrt) ;<br>​       signal (mutex) ;<br>​         &#x2F;&#x2F; reading is performed<br>​       wait (mutex) ;<br>​       readcount - - ;<br>​       if (readcount &#x3D;&#x3D; 0) signal (wrt) ;<br>​       signal (mutex) ;<br>​    }</p>
</blockquote>
<p>上述方案容易出现写者饥饿现象</p>
<p>解决方案：写者优先，有写者到来时，该写者阻止后续读者访问该对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Reader: while(true) &#123;</span><br><span class="line">                wait(w);         //尽管有读者在读，但封锁刚到来的读者</span><br><span class="line">                 wait(rmutex);</span><br><span class="line">                 if readcount=0 then wait(wmutext);</span><br><span class="line">                 readcount:=readcount+1;</span><br><span class="line">                 signal(rmutex);</span><br><span class="line">                 signal(w);</span><br><span class="line">                  perform read operation;</span><br><span class="line">                 wait(rmutext);</span><br><span class="line">                 readcount:=readcount-1;</span><br><span class="line">                 if readcount=0 then signal(wmutext);</span><br><span class="line">                 signal(rmutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">writer:</span><br><span class="line">        while(true) &#123;</span><br><span class="line">                 wait(w);</span><br><span class="line">                 wait(wmutex);</span><br><span class="line">                  perform write operation;</span><br><span class="line">                 signal(wmutex);</span><br><span class="line">                 signal(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>简单方案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The structure of Philosopher i:</span><br><span class="line"></span><br><span class="line">While (true)  &#123; </span><br><span class="line">          wait ( chopstick[i] );</span><br><span class="line">	     wait ( chopStick[ (i + 1) % 5] );	</span><br><span class="line">	             // eat</span><br><span class="line">	     signal ( chopstick[i] );</span><br><span class="line">	     signal (chopstick[ (i + 1) % 5] );</span><br><span class="line">                 //  think</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：可能会引起死锁</p>
<p>解决方式</p>
<ul>
<li>最多只允许四个哲学家同时坐在桌子上</li>
<li>只有两只筷子都可获得时才能拿起筷子<ul>
<li>信号量集</li>
<li>管程</li>
</ul>
</li>
<li>使用非对称解决方法<ul>
<li>奇数哲学家先拿起左边的筷子，再拿起右边的筷子</li>
<li>偶数哲学家拿起右边的筷子，再拿起左边的筷子</li>
</ul>
</li>
<li>最后一个哲学家先拿起右边的筷子，其他哲学家先拿起左边的筷子</li>
</ul>
<h3 id="睡眠的理发师问题"><a href="#睡眠的理发师问题" class="headerlink" title="睡眠的理发师问题"></a>睡眠的理发师问题</h3><p>理发店里有接待室和理发室构成，理发室一把理发椅，接待室有n把椅子</p>
<p>顾客到达理发店</p>
<ul>
<li>若座位已满选择离开，若理发室忙，等待室有座位，则在椅子上等待</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Customer:</span><br><span class="line">While (1) &#123;</span><br><span class="line">      wait(waitingMutex);          //实现对waiting的互斥访问</span><br><span class="line">if (waiting &lt; CHAIRS)  &#123;   //如果有座位空闲</span><br><span class="line">   waiting=waiting +1;       //</span><br><span class="line">   signal(waitingMutex);</span><br><span class="line">   signal(customers);        //通知理发师（相当于在诊所中交上病例）</span><br><span class="line">   wait(barberReady);       //等待理发师呼叫（相当于等待医生）</span><br><span class="line">&#125; </span><br><span class="line">else   &#123;                             // 理发店已满，离开</span><br><span class="line">   signal(waitingMutex);</span><br><span class="line">   leaving；</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Barber:</span><br><span class="line">while (true)  &#123;</span><br><span class="line">	wait(customers);  //检查有无顾客（医生查检查是否还有无病例）</span><br><span class="line">                             //如果没有顾客，睡眠（等待顾客）</span><br><span class="line">	wait(waitingMutex);         // 实现对waiting的互斥访问）</span><br><span class="line">	waiting=waiting-1;</span><br><span class="line">	signal(waitingMutex);      //释放waiting的访问权</span><br><span class="line"></span><br><span class="line">	signal(barberReady);  //理发师准备好可以服务（呼叫顾客）（呼叫病人）</span><br><span class="line">	cut-hair;               //理发（看病）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><ul>
<li>抽烟者问题。假设一个系统中有三个抽烟者进程，每个抽烟者不断地卷烟并抽烟。</li>
<li>抽烟者卷起并抽掉一颗烟需要有三种材料：烟草、纸和火柴。</li>
<li>一个抽烟者有烟草，一个有纸，另一个有火柴。</li>
<li>系统中还有一个供应者进程，它们无限地供应所有三种材料，但每次仅轮流提供三种材料中的两种。</li>
<li>得到缺失的两种材料的抽烟者在卷起并抽掉一颗烟后会发信号通知供应者，让它继续提供另外的两种材料。</li>
<li>在两种材料被相应的吸烟者取走之前，不允许供应新的材料。</li>
<li>这一过程重复进行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore tobacco_paper = 0 // waiting for tobacco and paper</span><br><span class="line">semaphore tobacco_matches = 0 // waiting for tobacco and matches</span><br><span class="line">semaphore paper_matches = 0 // waiting for paper and matches</span><br><span class="line">semaphore doneSmoking = 1</span><br></pre></td></tr></table></figure>



<h3 id="捡棋子问题"><a href="#捡棋子问题" class="headerlink" title="捡棋子问题"></a>捡棋子问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">捡黑子进程</span><br><span class="line">While (true) </span><br><span class="line">&#123;</span><br><span class="line">    wait(black);</span><br><span class="line">     捡一个黑子；</span><br><span class="line">    signal(white); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">捡白子进程</span><br><span class="line">While (true) </span><br><span class="line">&#123;</span><br><span class="line">    wait(white);</span><br><span class="line">     捡一个白子；</span><br><span class="line">    signal(black); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置初值，black&#x3D;M，white&#x3D;N，思考两进程之间执行次数的制约</p>
<ul>
<li><p>捡黑子的次数比捡白子的次数最多多M次；</p>
</li>
<li><p>捡白子的次数比捡黑子的次数最多多N次</p>
</li>
</ul>
<h3 id="保证并发度的情况下实现临界资源互斥"><a href="#保证并发度的情况下实现临界资源互斥" class="headerlink" title="保证并发度的情况下实现临界资源互斥"></a>保证并发度的情况下实现临界资源互斥</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  float a;</span><br><span class="line">  float b;</span><br><span class="line">&#125;  cnum;</span><br><span class="line">cnum x,y,z; //全局变量</span><br><span class="line"></span><br><span class="line">//计算两复数之和</span><br><span class="line">cnum add(cnum p, cnum q) &#123;</span><br><span class="line">   cnum s;</span><br><span class="line">   s.a=p.a+q.a;</span><br><span class="line">   s.b=p.b+q.b;</span><br><span class="line">   return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>变量</strong></th>
<th>Thread1和thread2</th>
<th>Thread1和thread3</th>
<th>Thread2和thread3</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>不共享</td>
<td>不共享</td>
<td>不共享</td>
</tr>
<tr>
<td>y</td>
<td>同时读</td>
<td><strong>读写互斥</strong></td>
<td><strong>读写互斥</strong></td>
</tr>
<tr>
<td>z</td>
<td>不共享</td>
<td>不共享</td>
<td><strong>读写互斥</strong></td>
</tr>
</tbody></table>
<p>为了提高线程之间的并发度：仅保证相关临界区互斥访问即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex_y1=1;   // 用于thread1与thread3互斥访问y；Semaphore mutex_y2=1;   // 用于thread2与thread3互斥访问y；Semaphore mutex_z=1;     // 用于thread2与thread3互斥访问z；thread1 &#123;   cnum w;   P(mutex_y1);   w=add(x,y);   V(mutex_y1)   …….   &#125;thread2 &#123;   cnum w;   P(mutex_y2);   P(mutex_z);   w=add(y,z);   V(mutex_z);   V(mutex_y2);   …….   &#125;thread3 &#123;   cnum w;   w.a=1;   w.b=1;   P(mutex_z);   z=add(z,w);   V(mutex_z);   P(mutex_y1);   P(mutex_y2);   y=add(y,w);   V(mutex_y2);   V(mutex_y1);   …….   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>信号量及wait、signal操作存在的问题</p>
<ul>
<li>wait与signal位置倒置：违反互斥</li>
<li>signal写为wait：引发死锁</li>
<li>遗漏wait或signal：违反互斥或引发死锁</li>
<li>wait顺序不当：引发死锁</li>
</ul>
<p>解决方式</p>
<p>提供更高层的方便用户同步机制，系统将其映射到底层的信号量及wait、signal操作</p>
<ul>
<li>monitor管程</li>
</ul>
<p>可把管程的定义理解为一个类定义，与一般的类不同的是，管程有条件变量，用于控制进程之间的同步</p>
<p>并发的进程要互斥的访问管程</p>
<ul>
<li>同一时间只能有一个进程在管程内活动</li>
</ul>
<p>条件变量</p>
<ul>
<li>进程等待的原因有很多，为区分这些原因</li>
<li>在不同信号量的等待队列中的进程，等待原因是不同的</li>
<li>管程中对每个条件变量都予以声明</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>一组死锁进程各自拥有资源并且等待这组进程中其他进程拥有的资源</p>
<p>死锁：一组处于等待（阻塞）状态的进程，每个进程持有其他进程所需要的资源，而又等待使用其他进程所拥有的资源，致使这组进程互相等待，均无法向前推进</p>
<p>饥饿</p>
<ul>
<li>无限阻塞：一个进程可能永远不会从它挂起的信号量队列中移除</li>
<li>无限就绪：就绪进程因不满足调度策略所需的条件，长时间得不到调度</li>
</ul>
<p>死锁产生原因</p>
<ul>
<li>竞争资源：系统中供进程共享的资源，数目不足以满足进程需求，进程之间要竞争使用这些资源，可能会产生死锁</li>
<li>进程间推进顺序不当：请求和释放资源的顺序不当，导致进程之间互相等待对方所占用的资源</li>
</ul>
<h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>正常操作模式下，进程只能按如下顺序使用资源</p>
<ul>
<li>申请：申请不能立即被允许，那么申请进程必须等待，直到它获得该资源为止</li>
<li>使用：进程对资源进行操作</li>
<li>释放：进程释放资源</li>
</ul>
<p>资源申请和释放为系统调用</p>
<p>死锁发生的必要条件</p>
<p>系统中下面四个条件同时满足，那么可能会引起死锁</p>
<ul>
<li>互斥：一次只有一个进程使用资源</li>
<li>占有并等待：一个进程必须占有至少一个资源，并在等待其他进程占有的另一资源</li>
<li>非抢占：资源不能被抢占，只能在完成进程任务后释放</li>
<li>循环等待：存在一个集合p0到pn，pi等待的资源被pi+1占有</li>
</ul>
<p>四个条件不独立</p>
<p>不是必要条件：多实例资源</p>
<p>申请某类资源任何一个实例均可，不能具体到申请哪个实例</p>
<p>![image-20211209222528116](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211209222528116.png)</p>
<p>此时，进程p1、p2、p3均占有资源，并进入等待状态，且互相等待对方所占用的资源</p>
<p>找出死锁点</p>
<ul>
<li>死锁进程一定处于阻塞状态</li>
<li>每个进程的操作应预留一个申请操作，以便以后执行该申请操作时使进程进入等待状态</li>
</ul>
<p>资源分配图</p>
<p>P：进程     R：资源</p>
<p>Pi-&gt;Rj：表示进程Pi已经申请了资源类型为Rj的一个实例，称为申请边</p>
<p>Pj-&gt;Pi：表示资源类型Rj已经分配给进程Pi，称为分配边</p>
<p>可得</p>
<ul>
<li>若分配图没有环，则系统就没有进程死锁</li>
<li>若分配图有环，那么可能存在死锁</li>
<li>若每类型只有一个实例，环是死锁存在的充分必要条件。若每类型不止一个实例，环是死锁的必要条件</li>
</ul>
<h2 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h2><ul>
<li>使用协议以预防或避免死锁，确保系统不会进入死锁状态<ul>
<li>死锁预防：采取防污染措施，禁止出现污染<ul>
<li>对进程使用资源加上诸多限制条件，以防止系统出现死锁现象</li>
</ul>
</li>
<li>死锁避免：根据环评结果，决定是否通过项目的审批<ul>
<li>基于进程及系统的一些先验知识，当进程申请资源时，若发现满足该资源的请求可能导致死锁发生，则拒绝该申请</li>
</ul>
</li>
</ul>
</li>
<li>允许系统进入死锁状态，检测并加以修复</li>
<li>忽略问题，认为死锁不可能发生</li>
</ul>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>互斥条件不可破坏</p>
<p>占有并等待</p>
<p>系统保证当进程申请一个资源时，不能占有其他资源</p>
<ul>
<li>要求进程在开始执行前申请并分配它需要的所有资源<ul>
<li>（资源静态分配策略，占有不等待</li>
<li>申请资源的系统调用在其他系统调用前执行</li>
</ul>
</li>
<li>当进程不拥有资源时才可以申请资源；进程使用完并释放一种资源后，才可以申请另一种资源<ul>
<li>等待不占有</li>
</ul>
</li>
</ul>
<p>优点：简单，安全、易于实现</p>
<p>缺点：</p>
<ul>
<li>资源利用率低、可能发生饥饿</li>
<li>进程直到运行时才知道它需要多少资源</li>
</ul>
<p>非抢占</p>
<ul>
<li>抢占的资源被添加到正在等待的进程的资源列表中，系统中阻塞的进程的资源被分配给其他等待该资源的进程</li>
<li>如果申请资源而未满足，则释放自己已经获得的资源</li>
</ul>
<p>问题</p>
<ul>
<li><p>进程只有能重新获得旧资源和正在申请的新资源时才能重新启动</p>
</li>
<li><p>适用于状态可保存及恢复的及的资源，如CPU寄存器、内存等</p>
</li>
<li><p>不适用于像互斥锁、信号量及打印机这类需要互斥非共享使用的资源</p>
</li>
</ul>
<p>循环等待</p>
<p>强制对所有资源类型进行完全排序，并要求每个进程按照递增顺序来申请资源</p>
<ul>
<li>进程可在任何时候申请资源，但请求必须按照资源编号递增的顺序提出</li>
<li>或当进程申请资源编号小于占有资源编号时，应先释放资源</li>
</ul>
<p>问题</p>
<ul>
<li>限制了新类型设备的增加</li>
<li>先申请到的资源被长期闲置，造成资源浪费</li>
<li>包括抽象资源时，系统中潜在的资源数目会很大，以至于编号方法无法使用</li>
<li>增加编程人员负担</li>
</ul>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>要求系统获得以后如何申请资源的附加信息</p>
<ul>
<li>要求进程声明他可能需要的每种类型资源的最大数量</li>
<li>死锁避免算法动态的检查资源分配状态，确保永远不会有循环等待条件</li>
<li>资源分配状态由可用资源、已分配资源的数量以及进程最大需求数定义</li>
</ul>
<p>安全状态</p>
<p>如果系统能按照某个顺序未每个进程分配资源（不超过其最大值）并能避免死锁，那么系统状态就是安全的。</p>
<p>即若存在一个安全序列，那么系统处于安全状态，若没有这样的顺序存在，系统处于不安全状态</p>
<p>进程顺序{P1,P2,…,Pn}，如果对于每个Pi，Pi仍然可以申请的资源数小于当前可用资源加上所有进程Pj（其中j小于i）所占用资源，那么这一顺序称为安全序列。</p>
<ul>
<li>安全状态——可避免死锁</li>
<li>不安全状态——有可能导致死锁</li>
<li>避免——确保系统不会进入不安全状态</li>
</ul>
<p>![img](E:\OneDrive - mail.sdu.edu.cn\md\image\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70.png)</p>
<p>避免算法</p>
<p>总体思想：</p>
<ul>
<li><p>当进程提出资源请求时，系统进行假分配，然后检测假分配之后的状态是否安全</p>
</li>
<li><p>若不安全，则不满足系统请求</p>
</li>
<li><p>安全，满足请求</p>
</li>
<li><p>单实例资源：资源分配图</p>
</li>
<li><p>多实例资源：银行家算法</p>
</li>
</ul>
<p>资源分配图</p>
<p>需求边（虚线表示</p>
<ul>
<li>进程Pi可能在将来某个时候申请资源Rj</li>
<li>只有申请边变为分配边而不会导致环路时，才允许申请</li>
</ul>
<p><img src="E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211210170232550.png" alt="image-20211210170232550" style="zoom:50%;" /><img src="E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211210170347255.png" alt="image-20211210170347255" style="zoom:50%;" /></p>
<p>算法</p>
<ul>
<li>将一个claim边转变为申请边</li>
<li>若资源是可获得的，将申请边转变为分配边，否则Pi等待</li>
<li>如果检测到一个环路，那么请求不被允许，否则请求被允许</li>
</ul>
<p>银行家算法</p>
<ul>
<li>多实例资源</li>
<li>每个进程必须事先声明最大使用数量</li>
<li>当进程申请资源时可能不得不等待，判断资源分配是否会使系统仍处于安全状态</li>
<li>当进程获得它所需的所有资源时，他必须在有限时间内返回</li>
</ul>
<p>所需数据结构</p>
<ul>
<li><p>n为系统进程个数、m为资源类型的种类</p>
</li>
<li><p>Available：长度为m的向量，表示每种资源类型的现有实例的数量</p>
<ul>
<li>Available[j]&#x3D;k：资源类型Rj现在又k个实例</li>
</ul>
</li>
<li><p>Max：n×m矩阵，定义每个进程的最大需求</p>
<ul>
<li>Max[i][j]&#x3D;k：进程Pi最多申请k个资源类型Rj的实例</li>
</ul>
</li>
<li><p>Allocation：n×m矩阵，定义每个进程现在所分配的各种资源类型的实例数量</p>
<ul>
<li>Allocation[i][j]&#x3D;k：进程Pi已经分配了k个资源类型Rj的实例</li>
</ul>
</li>
<li><p>Need：n×m矩阵，定义每个进程还需要的剩余资源数量</p>
<ul>
<li>Need[i][j]&#x3D;k：进程Pi还需要k个资源类型Rj的实例</li>
</ul>
</li>
<li><p>向量X和Y，若X≤Y，则X每个分量都≤Y的每个分量</p>
</li>
</ul>
<p>安全性算法</p>
<ul>
<li><p>创建Work和Finish向量，长度分别为m和n，work&#x3D;available，Finish每项均为false</p>
</li>
<li><p>查找i满足</p>
<ul>
<li><p>(a) Finish [i] &#x3D; false</p>
<p>(b) Needi ≤ Work</p>
</li>
<li><p>若没有i满足，跳至步骤4</p>
</li>
</ul>
</li>
<li><p>Work&#x3D;Work+Allocation[i]</p>
<ul>
<li>Finish[i]&#x3D;true</li>
<li>goto step2</li>
</ul>
</li>
<li><p>如果所有的Finish[i]&#x3D;&#x3D;true，那么系统处于安全状态</p>
<ul>
<li>否则系统处于不安全状态</li>
</ul>
</li>
</ul>
<p>银行家算法（对于进程Pi的资源分配算法</p>
<p>request[i]：Pi的需求向量</p>
<ol>
<li><p>Request[i]≤Need[i]</p>
<ol>
<li>满足，跳至步骤2</li>
<li>不满足报错</li>
</ol>
</li>
<li><p>Request[i]≤Available[i]</p>
<ol>
<li>满足，步骤3</li>
<li>不满足，等待</li>
</ol>
</li>
<li><p>假分配，按照如下规则</p>
<ol>
<li><p><em>Available</em> &#x3D; <em>Available</em> – <em>Request;</em></p>
<p><em>Allocationi</em> &#x3D; <em>Allocationi</em> + <em>Requesti</em>;</p>
<p><em>Needi</em> &#x3D; <em>Needi</em> – <em>Request*<em>i</em></em>;*</p>
</li>
</ol>
</li>
<li><p>检查状态修改的安全性</p>
<ol>
<li>安全，将资源分配给Pi</li>
<li>不安全，Pi必须等待，并恢复旧的资源分配状态</li>
</ol>
</li>
</ol>
<p>总结</p>
<ul>
<li><p>一个实例的情况，采取具有calimed edge的RAG图</p>
<ul>
<li>进程提出资源请求，假装满足</li>
<li>在RAG图中检测到环，不满足</li>
<li>否则，满足</li>
</ul>
</li>
<li><p>多个实例的情况，采取银行家算法</p>
</li>
</ul>
<p>银行家算法可以避免死锁</p>
<p>系统处于安全状态是，系统中一定无死锁进程</p>
<h2 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h2><p>单实例模型</p>
<p>检测等待图中是否有环路</p>
<p>![image-20211210195449284](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211210195449284.png)</p>
<p>资源分配图化简后仍存在回路</p>
<p>死锁定理：系统处于死锁状态当且仅当系统的资源分配图是不可完全简化的，即RAG图简化后不会使所有进程成为孤立点</p>
<p>复杂度n^2^</p>
<p>多实例模型</p>
<ol>
<li><p>设 Work and Finish 分别是长度为m 和 n的向量，初始化为</p>
<p>(a) Work &#x3D; Available;</p>
<p>(b) 所有i，若Allocationi $\ne$ 0, 则Finish[i]&#x3D; false，否则 Finish[i]&#x3D;true</p>
<p>​    &#x3D;&#x3D;不占有的进程比不可能产生死锁，因此直接置为true&#x3D;&#x3D;</p>
</li>
<li><p>找一个进程 i ，满足: (a) Finish[i] &#x3D;&#x3D; false; (b) Requesti $\le$ Work；若不存在这样的 i ，转 4</p>
</li>
<li><p>进程结束：Work &#x3D; Work+Allocationi；Finish[i] &#x3D; true；转 2</p>
</li>
<li><p>若存在i，使 Finish[i] &#x3D;&#x3D; false, 则系统处于死锁状态</p>
</li>
</ol>
<p>死锁检测算法的应用</p>
<p>调用频率取决于</p>
<ul>
<li>死锁发生的频率</li>
<li>需要回滚的进程数量<ul>
<li>每一个不相交的循环</li>
</ul>
</li>
</ul>
<p>如果任意调用检测算法，那么在资源图中可能有许多环路，无法分辨死锁进程</p>
<h2 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h2><ul>
<li>终止所有死锁进程<ul>
<li>代价大</li>
</ul>
</li>
<li>一次终止一个进程，直到消除死锁<ul>
<li>开销大，需要每次都检测</li>
</ul>
</li>
</ul>
<p>如何决定终止的顺序</p>
<ul>
<li>执行的时间、还需多长时间</li>
<li>使用的资源</li>
<li>需要的资源</li>
<li>需要终止进程的数量</li>
<li>交互进程or批处理进程</li>
</ul>
<p>问题</p>
<ul>
<li>如何决定终止的进程：最大限度减少成本</li>
<li>回滚：使进程返回某个安全状态<ul>
<li>最简单的方法：终止并重新执行</li>
<li>有效的方法：回滚到足够打破死锁，系统需要维护进程状态的更多信息</li>
</ul>
</li>
<li>饥饿：确保不会发生饥饿，最常用的方法是在代价因素上加上回滚次数</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>基本硬件</p>
<ul>
<li>程序必须被放入内存中并且在进程中执行</li>
<li>CPU能直接访问的存储器只有内存和处理器中的寄存器</li>
<li>寄存器可在一个时钟周期中访问</li>
<li>主存访问需要多个时钟周期</li>
<li>Cache用于协调访问速度差异</li>
<li>内存保护</li>
</ul>
<h2 id="逻辑地址与物理地址"><a href="#逻辑地址与物理地址" class="headerlink" title="逻辑地址与物理地址"></a>逻辑地址与物理地址</h2><ul>
<li>名地址与名空间<ul>
<li>编程时使用名字表示地址：变量名、标号等</li>
<li>变量名、标号等构成程序的名空间</li>
</ul>
</li>
<li>逻辑地址与逻辑地址空间<ul>
<li>编译时无法确定程序在运行时所分配的地址空间</li>
<li>假设从0开始编址</li>
<li>CPU寻址给出的形式都是逻辑地址，MMU转化为物理地址</li>
</ul>
</li>
<li>物理地址与物理地址空间<ul>
<li>程序运行时，使用的内存地址</li>
</ul>
</li>
</ul>
<p>运行时完成地址映射（现在的OS多采用</p>
<ul>
<li>运行时将指令使用的逻辑地址映射为物理地址（边执行边变换</li>
<li>需要硬件支持（MMU</li>
<li>支持虚拟存储机制（程序可以装入到内存的任何位置</li>
</ul>
<h2 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h2><p>内存管理单元<strong>Memory-Management Unit</strong> **(**MMU)</p>
<ul>
<li>硬件设备，完成虚拟地址到物理地址的映射</li>
<li>重定位寄存器（relocation register），加上用户进程生成的地址<ul>
<li>基址寄存器</li>
</ul>
</li>
<li>用户只处理逻辑地址</li>
</ul>
<p>基址寄存器和界限地址寄存器定义了逻辑地址空间</p>
<ul>
<li>这些寄存器的值只能由OS设置</li>
</ul>
<p>![image-20211210204957533](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211210204957533.png)</p>
<h2 id="用户程序的运行"><a href="#用户程序的运行" class="headerlink" title="用户程序的运行"></a>用户程序的运行</h2><p>编写源程序</p>
<p>编译</p>
<p>链接</p>
<ul>
<li>静态链接（.lib）<ul>
<li>运行之前完成链接，将所有的程序模块链接起来形成可执行文件，运行时直接装入内存</li>
<li>链接及装入过程费时，有些用不到的模块不需要链接及装入</li>
<li>不便于模块的升级</li>
<li>运行速度快</li>
</ul>
</li>
<li>动态链接<ul>
<li>运行时仅链接需要的模块</li>
<li>运行调用时进行链接</li>
<li>减少了链接需要的时间</li>
<li>节省内存空间</li>
<li>便于模块升级、共享</li>
</ul>
</li>
</ul>
<p>装入</p>
<ul>
<li><p>绝对装入方式</p>
<ul>
<li>运行时装入所有模块</li>
<li>装入时费时，浪费内存；但管理简单，运行时速度快</li>
</ul>
</li>
<li><p>动态运行时装入  (Dynamic Loading)</p>
<ul>
<li>运行时可只装入主控模块</li>
<li>其它模块被调用时再装入；</li>
<li>提高了内存的利用率，只有需要的模块才被装入；</li>
<li>管理复杂，运行时速度降低；</li>
<li>支持虚拟存储</li>
</ul>
</li>
</ul>
<p>执行</p>
<p>Swap交换</p>
<ul>
<li>一个进程可以被暂时从内存中交换到后备存储器，然后再被带回内存继续执行;</li>
<li>后备存储-快速磁盘，足够大，以容纳所有用户的所有内存映像的副本;必须提供对这些内存映像的直接访问;</li>
<li>滚出，滚入交换变量，用于基于优先级的调度算法;换掉低优先级的进程，以便加载和执行高优先级的进程;</li>
<li>交换时间的主要部分是转移时间;总传输时间与交换的内存数量成正比;</li>
</ul>
<p>在许多系统(如UNIX、Linux和Windows)上都可以找到交换的修改版本;</p>
<p>系统维护一个随时准备运行的进程队列，这些进程在磁盘上有内存映像;</p>
<h2 id="关注的问题"><a href="#关注的问题" class="headerlink" title="关注的问题"></a>关注的问题</h2><ul>
<li>逻辑地址空间与物理地址空间的管理方法<ul>
<li>分区管理、页式管理、段式管理、段页管理等</li>
</ul>
</li>
<li>逻辑地址到物理地址的映射方法<ul>
<li>地址变换、重定位、地址绑定</li>
</ul>
</li>
<li>存储保护机制</li>
<li>内存共享方法</li>
<li>碎片、零头</li>
</ul>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><p>内存中主要分为以下两部分</p>
<ul>
<li>常驻操作系统（与中断向量一起保留在低内存</li>
<li>用户进程（在高内存<ul>
<li>单分区分配</li>
<li>多分区分配</li>
</ul>
</li>
</ul>
<p>重定向寄存器：用来保护用户进程区分自己和别的进程、数据、操作系统</p>
<ul>
<li>重定向寄存器：物理地址的最小值</li>
<li>界限地址寄存器：逻辑地址的范围值</li>
</ul>
<p>单分区分配</p>
<ul>
<li>用户区中只有一个分区、每个时刻只能运行一道程序</li>
</ul>
<p>多分区分配</p>
<ul>
<li>将用户区划分成多个分区</li>
<li>每个分区同时只能运行一道程序</li>
<li>技术<ul>
<li>静态（固定）分区管理</li>
<li>动态分区管理</li>
</ul>
</li>
</ul>
<p><strong>静态分区分配</strong></p>
<ul>
<li><p>系统初始化时，将内存分为多个分区</p>
<ul>
<li>分区数目、大小固定</li>
<li>每个分区只能运行一道程序</li>
</ul>
</li>
<li><p>分区表</p>
<ul>
<li>记录分区位置、大小、使用情况</li>
<li>用于分区管理</li>
</ul>
</li>
<li><p>内碎片</p>
</li>
<li><p>地址映射及保护（使用重定向寄存器、界限地址寄存器</p>
</li>
</ul>
<p><strong>动态分区管理</strong></p>
<ul>
<li>基本思想<ul>
<li>系统初始化时，用户使用的内存空间只划分为一个分区</li>
<li>对进程所需内存按需分配</li>
</ul>
</li>
<li>分区表：对已分配的分区进行管理</li>
<li>空闲分区表：对空闲分区进行管理</li>
<li>分区分配算法</li>
<li>地址映射和存储保护（重定向寄存器、界限地址寄存器</li>
<li>外碎片</li>
<li>段式管理使用该内存管理方法</li>
</ul>
<p>孔：可用的内存块</p>
<p>进程到达时，从一个足够大的孔中为它分配内存</p>
<p>系统维护的信息：已分配分区、空闲分区</p>
<p>![image-20211211203337922](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211211203337922.png)</p>
<p>动态分区问题</p>
<ul>
<li>首次适应：分配第一个足够大的孔<ul>
<li>查找从头开始一旦找到足够大的孔，就停止</li>
</ul>
</li>
<li>最佳适应：分配最小的足够大的孔。<ul>
<li>孔按照大小排列</li>
<li>可以产生最小剩余孔</li>
</ul>
</li>
<li>最差适应：分配最大的孔，为了防止外碎片产生<ul>
<li>孔按照大小排列</li>
<li>产生最大剩余孔</li>
</ul>
</li>
<li>下一个适应：基于首次适应</li>
</ul>
<p>首次适应和最佳适应在速度和存储利用率方面优于最差适应</p>
<h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>外碎片：总的内存空间可以满足请求，但是是不连续的</p>
<p>内碎片：分配的内存可能略大于需求的内存，这个大小差异是一个分区的内部未被使用的内存</p>
<p>通过紧缩减少外部碎片</p>
<ul>
<li>移动内存内容，将所有的空闲块放入一个大块中</li>
<li>紧缩仅在重定位是动态的并在运行时可采用</li>
</ul>
<h3 id="分区式存储管理的特点"><a href="#分区式存储管理的特点" class="headerlink" title="分区式存储管理的特点"></a>分区式存储管理的特点</h3><ul>
<li>整个作业或进程存放在一段连续的内存区域</li>
<li>管理简单</li>
<li>对于较大的作业，有事找到一个足够大的连续区域比较困难</li>
</ul>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>连续内存分配的问题</p>
<ul>
<li>产生碎片</li>
<li>查找大的连续分区困难</li>
<li>不是很好的支持虚拟存储机制</li>
</ul>
<p>解决方式：非连续内存分配</p>
<p>分页</p>
<ul>
<li>进程的物理地址空间可以是非连续的，只要物理地址可用就行</li>
<li>帧（页框）：将物理地址划分为固定大小的块</li>
<li>页：逻辑内存分为同样大小的块</li>
<li>n页大小的程序，需要n个可用的空闲帧</li>
<li>建立页表来将逻辑地址转化为物理地址<ul>
<li>页号、页内偏移</li>
</ul>
</li>
</ul>
<p>存储保护</p>
<ul>
<li>页号越界检查（或设置相应的标志位（有效位</li>
<li>共享页的访问权限</li>
</ul>
<p>页面共享：通过页表实现</p>
<p>逻辑地址划分</p>
<ul>
<li>页号：用作页表索引，页表包含物理内存中每一页的基址</li>
<li>页内偏移：结合基址来定义发送到内存单元的物理内存地址</li>
</ul>
<p>地址变换过程</p>
<ul>
<li>mmu将逻辑地址划分为页号与页内地址</li>
<li>查找工作由硬件执行</li>
<li>检索前将页号与页表长度比较，页号大于等于页表长度，越界</li>
<li>页表内位置：页表始址+页号*页表项长度</li>
<li>帧号与页内偏移拼接得到物理地址</li>
</ul>
<p>硬件实现</p>
<ul>
<li>页表可以由一组专门的寄存器实现<ul>
<li>一个页表项用一个或多个寄存器，速度快</li>
<li>成本高，容量有限</li>
</ul>
</li>
<li>页表大多驻留在内存中，系统中可设置如下寄存器<ul>
<li>PTBR——页表起始地址</li>
<li>PRLR——页表长度</li>
</ul>
</li>
<li>进程未执行时，页表的起始地址和页表长度存放在PCB中</li>
</ul>
<p>访问一个字节需要两次内存访问</p>
<ul>
<li>页表项</li>
<li>实际物理地址</li>
</ul>
<p>加速：转换表缓冲区TLBs（translation look-aside buffer</p>
<ul>
<li>键（标签</li>
<li>值</li>
</ul>
<p>当关联内存根据给定值查找时，它会同时与所有键进行比较。如果找到条目，那么就得到相应的值域</p>
<p>![image-20211211220052722](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211211220052722.png)</p>
<p>有的TLB中还有保护地址空间标识码（ASID）：用来唯一标志进程，并提供地址空间保护</p>
<h3 id="地址变换过程中OS与CPU的分工"><a href="#地址变换过程中OS与CPU的分工" class="headerlink" title="地址变换过程中OS与CPU的分工"></a>地址变换过程中OS与CPU的分工</h3><p>（1）根据当前执行的进程的PCB保存的进程页表设置系统的PTBR及PTLR的内容；（软件-OS）</p>
<p>（2）CPU对执行的指令进行解析，分离出欲访问存储单元的逻辑地址；（ 硬件）</p>
<p>（3）MMU将逻辑地址根据规定的页面大小分成页号（P）与页内偏移量（d）两部分；（MMU，硬件）</p>
<p>（4）根据页号P进行地址越界检查（MMU，硬件），如果产生地址越界，则对越界进行处理（软件）</p>
<p>（5）如果没有产生地址越界，则依据页号P查找页表，得到页号P所对应的物理帧号f；（MMU，硬件）</p>
<p>（6）将帧号f作为物理地址的高位部分，页内偏移量d作为物理地址的低位部分，形成逻辑地址所对应的物理地址，送入MAR；（硬件）</p>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><ul>
<li><p>检查页号是否超出了自己的地址空间所定义的范围（要访问的是否是非法页面，即非法地址）</p>
</li>
<li><p>检查对该页框（帧）的访问许可：只读、读写、执行等；</p>
<ul>
<li>在页表中设置相应的位表示该页框的访问许可；</li>
</ul>
</li>
<li><p>每个页表项设置有效-无效位</p>
<ul>
<li>有效：关联的页面在进程的逻辑地址空间中</li>
<li>无效：该页不在进程的逻辑地址空间中</li>
</ul>
</li>
</ul>
<h3 id="共享页"><a href="#共享页" class="headerlink" title="共享页"></a>共享页</h3><p>共享：非自修改代码，永远不会修改自己</p>
<p>static：在函数内定义，表示只被初始化一次</p>
<p>共享代码</p>
<ul>
<li>一个只读代码的副本，在进程间共享</li>
<li>非自修改</li>
<li>在所有进程的逻辑地址空间的相同位置<ul>
<li>共享页面通常包含对自身的引用</li>
<li>条件跳转、循环</li>
</ul>
</li>
</ul>
<h3 id="层次页表"><a href="#层次页表" class="headerlink" title="层次页表"></a>层次页表</h3><p>一个页框无法容纳整个页表，为页表分配多个页框</p>
<p>层次页表：将一个大的页表分解成多个较小的页表</p>
<p>![image-20211211222255877](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211211222255877.png)</p>
<p>![两级页表方案](E:\OneDrive - mail.sdu.edu.cn\md\image\2-1Q10P95Ub96.gif)</p>
<h3 id="hash页表"><a href="#hash页表" class="headerlink" title="hash页表"></a>hash页表</h3><ul>
<li><p>采用虚拟页码作为哈希表值。哈希页表的每一个条目都包括一个链表</p>
</li>
<li><p>该链表的元素哈希到同一位置（这表示它们有了哈希冲突）。每个元素由三个字段组成：虚拟页码，映射的帧码，指向链表内下一个元素的指针。</p>
</li>
<li><p>该算法的工作如下：虚拟地址的虚拟页码哈希到哈希表。用虚拟页码与链表内的第一个元素的第一个字段相比较。如果匹配，那么相应的帧码（第二个字段）就用来形成物理地址。如果不匹配，那么与链表内的后续节点的第一个字段进行比较。以查找匹配的页码</p>
</li>
</ul>
<p>![image-20211211224637512](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211211224637512.png)</p>
<h3 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h3><p>正向页表，对每个虚拟页，页表都有一条页表项</p>
<ul>
<li>表示方式自然，但若空间很大，页表很占内存</li>
</ul>
<p>反向页表</p>
<ul>
<li><p>对于每个真正的内存页或帧，倒置页表有一个条目。</p>
</li>
<li><p>每个条目包含保存在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息。</p>
</li>
<li><p>整个系统只有一个页表，并且每个物理内存的页只有一条相应的条目</p>
</li>
</ul>
<p>![倒置页表](E:\OneDrive - mail.sdu.edu.cn\md\image\2-1Q10Q00R5R9.gif)</p>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>分页的问题</p>
<ul>
<li>实际内存与用户理解的内存不一致</li>
<li>共享困难</li>
</ul>
<p>分区的问题</p>
<ul>
<li>一个作业逻辑空间视为一个连续的整体</li>
<li>为一个大作业找连续的分区比较困难</li>
</ul>
<p>用户理解的内存</p>
<ul>
<li>程序的每部分为独立的单位</li>
<li>内存中最好也按照该逻辑单位进行管理</li>
<li>便于程序模块的共享</li>
</ul>
<p>分段的基本思想</p>
<ul>
<li>作业分段，内存按动态分区管理</li>
<li>内存分配以段为单位</li>
<li>作业不连续，但是段内连续</li>
<li>每个段有段名和长度</li>
<li>逻辑地址格式：段号，段内偏移</li>
<li>段表：段与段所在内存位置的对应关系</li>
</ul>
<p>段表项</p>
<ul>
<li>基址：包含本段在内存中的的起始物理地址</li>
<li>界限：本段长度</li>
</ul>
<p>段</p>
<ul>
<li><strong>Segment-table base register (STBR)</strong> ：段表在内存中的位置</li>
<li>**Segment-table length register (STLR)**：程序使用的段数</li>
</ul>
<p>内存保护</p>
<ul>
<li>段表项中关联<ul>
<li>有效位</li>
<li>读写权限</li>
<li>段界限</li>
</ul>
</li>
<li>与段相关的保护位：代码共享发生在段级别</li>
<li>段长度不同：动态内存分配</li>
</ul>
<h2 id="分段与分页的区别"><a href="#分段与分页的区别" class="headerlink" title="分段与分页的区别"></a>分段与分页的区别</h2><ul>
<li><p>页是信息的物理单位：方便系统管理</p>
<p>段是信息的逻辑单位：满足用户需要</p>
</li>
<li><p>页的大小固定且由系统决定：机器硬件实现</p>
<p>段的长度不固定、取决于用户编写的程序：编译程序根据信息的性质划分</p>
</li>
<li><p>分页的作业地址是一维的：只需一个地址记忆符</p>
<p>分段的作业地址是二维的：段名+段内地址</p>
</li>
</ul>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p>基本思想</p>
<ul>
<li>作业先分段，各段再分页</li>
<li>内存分配以页为单位</li>
<li>作业有段表，记录段起始位置和段长</li>
<li>每个段有页表</li>
</ul>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>绝对装入方式：作业运行前，将作业全部装入，知道运行完之后才释放内存</p>
<ul>
<li>作业在每次运行时并非使用到或暂时未使用到全部数据或程序</li>
<li>有的模块因IO长期等待、很少运行，仍需占用内存</li>
<li>编写程序长度大于实际物理内存</li>
</ul>
<p>局部性原理</p>
<ul>
<li>时间局部性<ul>
<li>某条指令执行后，不久可能重复执行。循环结构</li>
<li>某个数据结构访问后，不久可能重复访问。数组+循环</li>
</ul>
</li>
<li>空间局部性<ul>
<li>访问某个内存单元后，附近的存储单元也被访问</li>
<li>顺序性、数组+循环</li>
</ul>
</li>
</ul>
<p>虚拟存储器、cache</p>
<p>基本思想</p>
<ul>
<li>在虚拟地址空间中编址</li>
<li>程序运行时只装入当前要运行的那部分页面或段</li>
<li>缺页、缺段：请求调页</li>
<li>内存已满：置换功能</li>
</ul>
<p>虚拟内存指仅把作业的一部分装入内存便可以运行作业，具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</p>
<ul>
<li>逻辑容量：内存容量和外存容量之和</li>
<li>运行速度：接近内存速度</li>
<li>每位成本：接近外存</li>
</ul>
<p>优点</p>
<ul>
<li>将一个大的用户程序在较小的内存空间中运行</li>
<li>内存中可同时装入更多的进程并发执行</li>
<li>在虚拟地址空间中编制，简化了编程工作</li>
<li>提高了并发度、吞吐量、减少IO时间</li>
</ul>
<h2 id="虚拟内存的实现"><a href="#虚拟内存的实现" class="headerlink" title="虚拟内存的实现"></a>虚拟内存的实现</h2><p>相关问题</p>
<ul>
<li>访问页面时，检测一个页是否已存在在内存</li>
<li>不在内存时如何处理</li>
<li>内存无空闲页框时如何处理</li>
<li>页面置换过于频繁时，会引起系统不稳定如何处理</li>
</ul>
<h3 id="按需调页"><a href="#按需调页" class="headerlink" title="按需调页"></a>按需调页</h3><p>在需要的时候将页面放入内存</p>
<ul>
<li>IO更少</li>
<li>所需内存更少</li>
<li>响应更快</li>
<li>支持更多用户</li>
</ul>
<p>懒惰交换（lazy swapper）：除非需要页，否则不交换到内存中</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>是否在内存</p>
<ul>
<li>页表中指明对应页是否在内存<ul>
<li>有效位和无效位<ul>
<li>valid：对应页有效且在内存</li>
<li>invalid：对应页无效或不在内存</li>
</ul>
</li>
<li>若为i，需要 <strong>page fault</strong> 进一步判断i的含义（无效还是不在内存</li>
</ul>
</li>
<li>存在位：existence bit，用于指明相应页是否在内存</li>
</ul>
<p>判断页是非法还是合法但不在内存</p>
<ul>
<li>两个页表<ul>
<li>每个进程维护一个进程页表包含当前内存分配状态：有效页及其是否在内存中</li>
<li>操作系统维护一个页表来执行进程</li>
<li>操作系统将系统页表保存到旧的进程页表，或从计划调度的进程获取系统页表</li>
</ul>
</li>
<li>在页表中每个页表项添加一个存在未exitence bit<ul>
<li>表明是否在内存</li>
</ul>
</li>
</ul>
<p>页不在内存时如何处理</p>
<p>系统中断：page fault（页面失效、页面错误、缺页中断</p>
<ul>
<li>看另一个表来判断<ul>
<li>系统页表和进程页表</li>
<li>页面非法：abort</li>
<li>不在内存：调入内存</li>
</ul>
</li>
<li>获得一个空页框</li>
<li>从磁盘中交换页框</li>
<li>重新设置页表，设置有效位无效位为v</li>
<li>重启造成页面错误的指令</li>
</ul>
<p> 问题</p>
<ul>
<li>缺页中断是在指令执行期间发生<ul>
<li>可能产生多次缺页中断</li>
</ul>
</li>
<li>有时重启被中断的指令不可行</li>
</ul>
<p>Page Fault Rate</p>
<p>Effective Access Time（ETA）&#x3D;（1 – <em>p</em>) x memory access </p>
<p>​        + <em>p</em> (page fault overhead</p>
<p>​        + swap page out</p>
<p>​       + swap page in</p>
<p>​       + restart overhead )</p>
<h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><ul>
<li><p>写时复制允许父进程和子进程共享同一页</p>
<ul>
<li>fork调用不真正复制父进程到子进程空间，而仅仅是建立一个引用</li>
</ul>
</li>
<li><p>只有修改后，才会导致真正的复制</p>
</li>
</ul>
<h2 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h2><p>在内存中找到一些没有实际使用的页面，并将其替换掉</p>
<p>性能：希望导致最少数量的页面错误</p>
<p>同一页可能被多次装入内存</p>
<p>完成了逻辑内存和物理内存的分离</p>
<p>修改page fault例程，包括页面替换，防止内存过度分配</p>
<p>使用脏位：只将修改的页写入磁盘</p>
<ol>
<li><p>在磁盘上找到所需页面的位置(如何找到?)</p>
</li>
<li><p>寻找空闲帧:-如果有空闲帧，使用它-如果没有空闲帧，使用页面替换</p>
<p>选择被替换帧帧的算法-如果这个受害者帧被读取后被修改过</p>
<p>然后将被替换帧写入磁盘;</p>
<p>更改页并相应地更改页框。</p>
</li>
<li><p>将需要的页面放入(新的)空闲页框中，更新页和页表</p>
</li>
<li><p>重新启动进程</p>
</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>分配给进程的页框越多，产生页面错误次数就越少</p>
<p>但当分配的页框数大于5时，错误次数下降缓慢</p>
<p>即使分配过多的帧，对于提高进程的执行效率作用不是很明显；</p>
<h3 id="先进先出页面置换"><a href="#先进先出页面置换" class="headerlink" title="先进先出页面置换"></a>先进先出页面置换</h3><p>系统维护一个为作业的页面分配物理帧顺序的先进先出队列；</p>
<p>最后分配的总是放在队尾；</p>
<p>首先淘汰队首的页面；</p>
<p>特点</p>
<ul>
<li>简单直观、易于编程理解</li>
<li>性能并不总是很好<ul>
<li>被替换的页面可能是初始化模块，以后不被需要</li>
<li>被替换的可能为早期初始化、但常被使用的变量</li>
</ul>
</li>
<li>可能导致Belady’s Anomaly<ul>
<li>more frames more page faults，页框越多页面错误越多</li>
</ul>
</li>
</ul>
<h3 id="最优置换"><a href="#最优置换" class="headerlink" title="最优置换"></a>最优置换</h3><p>belady提出的理论上的算法：被淘汰的页面是以后永不使用，或在最长未来时间内不再被访问的页面</p>
<p>理论上的，无法实现，因为无法获取未来页面使用序列</p>
<p>可用于比较研究，作为上限</p>
<h3 id="最近最少使用LRU"><a href="#最近最少使用LRU" class="headerlink" title="最近最少使用LRU"></a>最近最少使用LRU</h3><p>淘汰最近最久未使用的页</p>
<p>两种方法</p>
<ul>
<li>计数器：页表中记录页的访问时间<ul>
<li>难以维持时间</li>
<li>时钟溢出</li>
</ul>
</li>
<li>堆栈：引用某页后，将其在堆栈删除并放在顶部<ul>
<li>淘滩栈底的页面</li>
</ul>
</li>
</ul>
<h3 id="近似LRU页置换"><a href="#近似LRU页置换" class="headerlink" title="近似LRU页置换"></a>近似LRU页置换</h3><ul>
<li><p>页表项关联引用位 </p>
<ul>
<li>reference-bit</li>
</ul>
</li>
<li><p>引用时将引用位置1</p>
</li>
<li><p>编号最小的页面为LRU页面</p>
</li>
<li><p>每隔一段时间清零</p>
</li>
</ul>
<p>开始时所有引用位清零</p>
<p><strong>附加引用位算法</strong></p>
<p>![image-20211212172001282](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211212172001282.png)</p>
<p><strong>二次机会算法（Clock）</strong></p>
<p>基本算法为FIFO算法</p>
<p>检查引用位</p>
<ul>
<li>为1：给第二次机会，选择下一个FIFO页，引用位清零，到达时间为当前时间</li>
<li>为0：直接替换</li>
</ul>
<p>实现方式：循环队列</p>
<p><strong>增强型二次机会算法</strong></p>
<p>在二次机会算法上，再增加一个修改位</p>
<ul>
<li>(0,0)最近没有使用且也没有修改。—用于置换的最佳页</li>
<li>(0,1)最近没有使用但修改过。—不是很好，因为在置换之前需要将页写出到磁盘</li>
<li>(1,0)最近使用过但没有修改—它有可能很快又要被使用</li>
<li>(1,1)最近使用过且修改过—它有可能很快又要被使用，且置换之前需要将页写出到磁盘</li>
</ul>
<p>当页需要置换时，每个页都属于这四种类型之一。置换在最低非空类型中所碰到的页，可能要多次搜索整个循环队列。</p>
<h3 id="基于计数的算法"><a href="#基于计数的算法" class="headerlink" title="基于计数的算法"></a>基于计数的算法</h3><p>LFU最近最少用</p>
<p>MFU最常用</p>
<h2 id="页框分配"><a href="#页框分配" class="headerlink" title="页框分配"></a>页框分配</h2><p>每个进程需要最小页框的数量</p>
<p>两种分配方式</p>
<ul>
<li>固定分配<ul>
<li>平等分配</li>
<li>比例分配<ul>
<li>进程规模、优先级</li>
</ul>
</li>
</ul>
</li>
<li>动态分配</li>
</ul>
<p>全局分配和局部分配</p>
<p>全局置换允许进程从所有帧集合中选择一个进行置换，而不管该帧是否已分配给其他进程，</p>
<ul>
<li>它可以从其他进程抢夺帧，比如高优先级抢夺低优先级的帧；</li>
</ul>
<p>局部置换要求每个进程仅从其自己的分配帧中进行选择<br>全局置换通常有更好的吞吐量，且更为常用。一个问题是不能控制页错误率。因为局部置换不能使用其他进程的不常用的内存。</p>
<h2 id="系统颠簸"><a href="#系统颠簸" class="headerlink" title="系统颠簸"></a>系统颠簸</h2><p>如果一个进程在换页上用的时间多于执行时间，那么这个进程就在<strong>颠簸（thrashing）</strong>，颠簸其实就是频繁的页调度行为。</p>
<ul>
<li>页框数量不足</li>
</ul>
<p>系统颠簸会导致</p>
<ul>
<li>CPU利用率低-&gt;系统认为应该增加并发度-&gt;添加新的进程-&gt;CPU利用率更低</li>
</ul>
<p>分配的帧数小于局部区域的大小，系统就会颠簸</p>
<p>局部</p>
<ul>
<li>进程访问的页的集合，这些页在使用上具有关联性</li>
<li>一段程序或数据一般由若干个局部组成，在任何时刻t，进程总处于一个或多个局部中<ul>
<li>当所有的局部都装入内存，缺页率会很低</li>
<li>从一个局部迁移到一个新的局部，缺页率会升高</li>
</ul>
</li>
</ul>
<p><strong>预防系统颠簸</strong></p>
<p>为进程分配足够多的帧（至少能容纳当前的一个局部</p>
<p>根据局部性原理，每个进程<strong>最近使用的页框数</strong>作为<strong>将要使用的页框数的近似值</strong>；</p>
<p>对一个时间段对每个进程访问的页面进行采样，<strong>作为对进程一个局部的近似；</strong></p>
<p>即根据在一个时间窗口内每个进程所访问的页面踪迹，得出<strong>该时间段内每个进程所访问的页面集合，即每个进程的</strong>工作集；</p>
<p><strong>将该工作集的大小作为每个进程需求内存的下限；</strong></p>
<p><strong>如果所有进程需要的页框数之和 &gt; <strong>系统</strong>可用</strong>的页框数，则可能导致系统<strong>抖动</strong>，<strong>需挂起或终止部分进程，以释放内存</strong>，将它们分配给其它的<strong>进程；</strong></p>
<p>工作集窗口：固定数量的页面引用,例如:取10000指令,或100页;</p>
<p>工作集：最近工作集窗口页面引用中的一组页面</p>
<p>工作集大小：在最近的工作集窗口中引用的页面总数(随时间变化)</p>
<p>对一个时间段（窗口）对进程访问的页面进行采样，得出其运行所需的最小帧数，作为将来一段时间内该进程所需内存的近似值，<strong>并根据该数值对进程的内存进行调整。</strong></p>
<p>应用</p>
<p>OS监视每个进程的工作集，为进程分配足够的内存以容纳进程的整个工作集（页框数&gt;&#x3D;WSS）；</p>
<p>如果进程有多余的页框，可以把它们分配给其它进程并启动该进程；</p>
<p>注：当进程的局部转移后，需要的内存的页框数也随之改变，每个进程需要的页框数是动态改变的；</p>
<p>这里进程所需页框数也只是一个近似估计值；</p>
<p>如果所有进程的WSS之和超过了系统可用的页框数，则选择一个进程并挂起，令其释放内存，将释放出的内存分配给其他需要的进程；</p>
<h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>文件的内存映射</p>
<p>使用虚拟内存技术，可以将文件IO处理为常规内存访问</p>
<p>文件访问按照普通请求页面调度来进行</p>
<ul>
<li>页大小的部分文件就被读入到内存中</li>
<li>文件的读写按照普通内存访问来处理</li>
</ul>
<p>通过内存而不是read() write()系统调用来处理文件I&#x2F;O，从而简化文件访问</p>
<p>还允许多个进程映射同一个文件，从而共享内存中的页面。</p>
<h2 id="内核内存分配"><a href="#内核内存分配" class="headerlink" title="内核内存分配"></a>内核内存分配</h2><p>内核内存分配通常从空闲内存池中获取</p>
<p>内核内存分配与普通用户不同</p>
<ul>
<li>内核分配内存时，有时需要的空间不到一页<ul>
<li>谨慎分配内存，减少浪费</li>
</ul>
</li>
<li>有些硬件需要直接和物理内存交互，因此需要分配连续的物理页</li>
</ul>
<h2 id="其他需要考虑的事情"><a href="#其他需要考虑的事情" class="headerlink" title="其他需要考虑的事情"></a>其他需要考虑的事情</h2><p>预调页</p>
<p>为了减少进程启动时的大量缺页中断</p>
<p>页大小</p>
<p>页大小的选择需要考虑</p>
<ul>
<li>碎片：页要小</li>
<li>页表大小：大页面</li>
<li>IO开销：大页面</li>
<li>局部性：小页面<ul>
<li>总的IO减少，局部性将会得到改善</li>
<li>小页面会更好的匹配局部性</li>
</ul>
</li>
</ul>
<p>TLB(translation look-aside buffers)页表缓冲</p>
<p>TLB命中率</p>
<p>TLBreach：从TLB访问的内存量</p>
<ul>
<li>&#x3D;TLB大小*页面大小</li>
</ul>
<p>增加页面大小</p>
<ul>
<li>这可能会导致碎片的增加，因为并非所有应用程序都需要大的页面大小</li>
</ul>
<p>提供多种页面大小</p>
<ul>
<li>这允许需要较大页面大小的应用程序有机会使用它们，而不会增加碎片</li>
</ul>
<p>IO锁：页有时需要被锁定在内存中</p>
<p>对于一些特殊的页面，如用于I&#x2F;O缓冲去的页面，不能置换出去</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h2><p>文件是记录在外存上的相关信息的具有名称的集合。其具有<strong>连续的</strong>逻辑地址空间.通常，文件表示数据和程序。</p>
<p>文件属性</p>
<ul>
<li>名称：按人们易读的方式保存的信息</li>
<li>标识符：用户不可读，用于在文件系统内进行该文件的标识</li>
<li>类型：用于操作系统辨认并执行</li>
<li>位置：文件位于硬盘上的位置的指针</li>
<li>大小：大小</li>
<li>保护：控制谁可以读、写、执行</li>
<li>时间、日期和用户标识：创建，上次修改，上次访问时间等信息，用于保护，安全，使用跟踪</li>
</ul>
<p>有关文件的信息保存在目录结构中，目录结构保存在磁盘上</p>
<ul>
<li>目录表+FCB<ul>
<li>文件控制块</li>
</ul>
</li>
<li>目录表+Inode<ul>
<li>索引节点</li>
</ul>
</li>
</ul>
<p>文件操作</p>
<p>创建：包含到文件系统中找到空间和在目录中为文件创建一个条目<br>写：需要执行系统调用。另外需要搜索目录查找文件位置和为该文件维护一个写位置的指针并在发生写操作时不断更新指针位置<br>读：需要执行系统调用。过程同写，需要搜索过程和维护读指针的位置<br>重定位：设置文件位置指针为给定值。该操作不需要真正的IO操作，也叫做寻址（seek）<br>删除：搜索，释放相关空间，并删除相应条目。<br>截短文件（truncate）：将文件长度设置为0KB，并释放相关空间，但不改变其他属性（不删除条目）。如截短一个命名为a.txt的文本文件后，它的大小会变为0kb，但文件名和其他属性可能没有变化。</p>
<ul>
<li>上述的操作都涉及到为给定的文件搜索其在目录中的相关位置，为了避免不断搜索，在首次使用文件时，和使用完毕文件时，还需要执行两个操作：<ul>
<li>​    打开（open）：为系统调用。将执行搜索，并将相关文件的所有内容都移动到内存中，需要操作时，通过该表的索引指定文件，并直接在内存中进行操作，从而避免了重新搜索和IO操作。</li>
<li>​    关闭（close）：为系统调用。将文件的索引从信息表中删除，并将相关信息从内存写到外存。</li>
</ul>
</li>
</ul>
<p>操作系统维护包含所有打开文件的信息表（open-file table），当需要文件操作时，通过该表的索引指定文件。<br> ![image-20211212212517534](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211212212517534.png)</p>
<ul>
<li>文件指针：读和写操作的指针</li>
<li>文件打开计数器：一个文件可以被多个进程打开，文件打开计数器记录该操作，当计数器为0时，可以删除该文件条目。</li>
<li>文件磁盘位置：定位文件在磁盘的位置</li>
<li>访问权限：每个进程用一个访问模式访问文件。</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>文件系统实现对文件的按名存取</p>
<p>文件目录表：文件系统中的数据结构，实现文件名与文件在磁盘物理位置之间的映射关系</p>
<p>硬盘的物理格式化与逻辑格式化</p>
<p>物理格式化：将一个混沌的磁盘表面划分为磁道与扇区</p>
<p>逻辑格式化</p>
<ul>
<li>划分磁盘的逻辑块</li>
<li>创建文件系统</li>
<li>建立文件系统在磁盘上的布局</li>
<li>建立文件系统的数据结构：<ul>
<li>引导块、超级块、目录表、FCB表（索引节点表）文件分配表（FAT）、空闲块索引表</li>
</ul>
</li>
</ul>
<p>磁盘的逻辑块与物理块</p>
<ul>
<li><p>逻辑块：文件系统将磁盘视为一个逻辑空间，该逻辑空间由大小相等的一些磁盘块组成，一个逻辑块是文件系统操作的基本单位；</p>
<ul>
<li>文件系统以逻辑块为单位为文件分配硬盘空间</li>
</ul>
</li>
<li><p>物理块：数据在磁盘上的最小存取单位，也就是每进行一次I&#x2F;O操作，最小传输的数据大小</p>
<ul>
<li><p>一般物理块小于小于等于逻辑块大小；</p>
<p>通常，一个物理块对应一个扇区；</p>
</li>
</ul>
</li>
</ul>
<p>主引导记录：操作系统对磁盘进行读写时对分区合法性的判别、分区引导信息的定位；</p>
<p>存放在主引导扇区</p>
<p>效率 - 快速定位文件</p>
<p>命名 - 方便用户</p>
<p>​    两个用户可以为不同文件具有相同的名称</p>
<p>​    同一个文件可以有几个不同的名称</p>
<p>​        如文件共享，链接文件，快捷方向</p>
<p>分组 - 按属性进行文件分组文件，（例如，所有Java程序，所有游戏，……）</p>
<p>文件共享</p>
<p><strong>目录结构</strong></p>
<ul>
<li><p>单目录结构：文件系统只有根目录，没有子目录</p>
<ul>
<li>分组问题</li>
</ul>
</li>
<li><p>双层目录结构：每个用户一个目录</p>
<ul>
<li>路径名、分组问题</li>
</ul>
</li>
<li><p>树形目录结构</p>
<ul>
<li><strong>路径名：</strong>路径名有绝对路径和相对路径两种形式，<strong>绝对路径</strong>从根路径开始，<strong>相对路径</strong>从当前目录开始</li>
<li>目录删除<ul>
<li>强制要求如果目录不为空就无法删除目录。如MS-DOS系统</li>
<li>递归删除目录下的所有子目录和文件。如linux下的rm命令</li>
</ul>
</li>
</ul>
</li>
<li><p>无环图目录：树状目录结构的一个扩展，允许目录含有<strong>共享子目录和文件</strong></p>
</li>
</ul>
<h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><ul>
<li>OS启动后，系统维护一个根目录(&#x2F;)，或根文件系统，或主文件系统</li>
<li>系统或用户可以根据自己的权限访问该根文件系统</li>
<li>其它文件系统必须挂载到该根文件系统，或挂载到一个可访问的文件系统中才能被访问</li>
</ul>
<h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><p>磁盘提供大量的外存空间来维持文件系统。磁盘的下述两个特点使得其成为存储多个文件的方便介质。</p>
<ul>
<li>可以原地重写；</li>
<li>可以直接访问磁盘上的任意一块信息。</li>
</ul>
<p>为了提供对磁盘的高效且便捷的访问，操作系统通过文件系统来轻松地存储、定位、提取数据。文件系统有两个设计问题。</p>
<ul>
<li>定义文件系统对用户的接口</li>
<li>创建数据结构和算法来将逻辑文件系统映射到物理外存设备上</li>
</ul>
<p>![img](E:\OneDrive - mail.sdu.edu.cn\md\image\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70.png)</p>
<ul>
<li>IO控制为最底层，提供设备驱动程序和中断处理程序。实现内存和磁盘之间的信息传输</li>
<li>基本文件系统发送命令，对磁盘上的物理块进行读写。  每个块通过磁盘地址标识（驱动器，柱面，磁道，扇区）</li>
<li>文件组织模块将逻辑地址转换为物理地址，管理文件的逻辑块。同时含有空闲空间管理器，跟踪未分配的块，并根据要求提供给文件组织模块。</li>
<li>逻辑文件系统管理元数据，管理目录结构，提供给文件组织模块必要的信息。以及通过文件控制块（file control block，FCB）维护文件结构</li>
</ul>
<p>![image-20211212220328828](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211212220328828.png)</p>
<p>左箭头为文件指针</p>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>把多个文件系统整合为一个目录结构</p>
<p>![img](E:\OneDrive - mail.sdu.edu.cn\md\image\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70.png)</p>
<p>虚拟文件系统(VFS)是物理文件系统与文件系统服务之间的一个接口层（VFS Interface），它对每个物理文件系统的所有细节进行抽象，并为这些不同的文件系统提供了一个统一的系统调用接口。</p>
<p><strong>VFS</strong></p>
<p>并不是一种实际的文件系统,只是系统核心的一个管理模块</p>
<p>它只存在于内存中，不存在于任何外存空间</p>
<p>VFS在系统启动时建立，在系统关闭时消亡。</p>
<p>VFS层有两个目的：</p>
<p>VFS层通过定义一个清晰的VFS接口，以将文件系统的通用操作和具体实现分开。多个VFS接口的实现可以共存在同一台机器上，他允许访问已安装在本地的多个类型的文件系统。<br>VFS提供了在网络上唯一标识一个文件的机制。VFS基于称为vnode的文件表示结构。UNIX内核中为每个活动节点（文件或目录）保存一个vnode结构</p>
<h2 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h2><ul>
<li><p>与数据块指向指针的文件名的线性列表。</p>
<ul>
<li>易于编程</li>
<li>耗时的执行，查找文件需要线性搜索。</li>
</ul>
</li>
<li><p>哈希表 - 具有哈希数据结构的线性列表。</p>
<ul>
<li>减少目录搜索时间</li>
<li>碰撞 - 两个或多个文件名散列到同一位置的情况</li>
<li>固定尺寸，以及哈希函数对该大小的依赖性</li>
</ul>
</li>
</ul>
<h2 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h2><p>如何为文件分配空间，一遍有效的访问和索引文件</p>
<p>有效地利用外存空间（额外的磁盘空间、碎片）</p>
<p>提高对文件的访问速度（随机存取）</p>
<p>保证可靠性（是否容易导致文件的损坏）</p>
<p>易于文件扩展</p>
<p>实现难度</p>
<p>•文件名-&gt;文件目录表-&gt;FCB-&gt;存储文件内容的磁盘块</p>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>要求每个文件在磁盘上占有一系列连续的块。</p>
<p><strong>优点：</strong></p>
<ul>
<li>在访问块b后访问块b+1通常不需要移动磁头，当需要移动时（读到当前磁道末），只需要移动一个磁道。因此访问连续分配文件需要的寻道数最小。性能较好。</li>
<li>访问容易，连续分配支持<strong>顺序访问和直接访问</strong>。</li>
</ul>
<p>缺点：</p>
<ul>
<li>如何为新文件找到空间，这是一个动态存储分配问题（第八章提到过），相关的算法会产生外部碎片问题</li>
</ul>
<p>外部碎片的一个解决方案是合并（compact），即将小的空闲空间合并起来，而将其他存储的数据变成连续数据。显而易见这种方式的主要开销是时间，因为需要很多的IO操作。不能扩展<br>另一方面，这种方式还需要确定一个文件占用多少空间。文件的大小有时候可能比较好确定，但通常比较难以确定。</p>
<h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><p>每个文件都是一个磁盘块的链表:磁盘块可以分散在磁盘的任何地方。</p>
<p>优点：</p>
<p>没有外部碎片，空闲空间的任何一块都可以满足要求。<br>创建文件时，不需要说明文件大小。<br>不需要合并磁盘空间</p>
<p>可以说链接分配解决了连续分配的所有问题。</p>
<p>缺点：</p>
<p>只能用于顺序访问，要找到中间位置，必须跟随指针一块一块的移动。<br>指针需要空间。<br>可靠性较低。如果硬盘损坏，若损坏的是指针，那么这可能导致链接到错误的位置。</p>
<p>FAT文件分配表</p>
<p>将前面介绍的隐式链接中的Linked域独立出来，构成一个FAT表，专门用于实现磁盘块之间的链接。</p>
<ul>
<li>为磁盘的每一个磁盘块建立一个表项，称为FAT表</li>
<li>对于一个文件，其FCB中存储该文件的第一个磁盘块的块号</li>
<li>每个FAT表项存储该文件的下一个磁盘块的块号</li>
<li>每个文件的最后一个磁盘块的FAT表项中存储一个特殊的结尾符</li>
</ul>
<p>FAT中通常称一个磁盘为一个簇</p>
<h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><ul>
<li>随机访问</li>
<li>创建文件时不需要声明文件大小</li>
<li>没有外部碎片</li>
</ul>
<p>浪费空间</p>
<ul>
<li>动态访问无需外部分片，但有索引块开销。</li>
<li>索引块的指针开销通常比链接分配的大</li>
</ul>
<p>针对缺点的解决方案：</p>
<pre><code>链接方案：一个索引块通常为一个磁盘块，因此，它本身能直接读写。为了处理大文件，可以将多个索引块链接起来多层索引：用第一层索引块指向一组第二层的索引块，第二层索引块再指向文件块，这是链接表示的一种变种。组合方案：将索引块的头15个指针存在文件的inode中。这其中的前12个指针指向直接块。其他的3个指针指向间接块。第一个间接块为一级间接块的地址，第二个间接块为二级间接块的指针，第三个间接块为三级间接块指针
</code></pre>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p>系统需要维护一个空闲空间链表（free-space list），该链表记录了所有的空闲磁盘空间，并在创建文件时，能够从该链表搜索并返回一段空闲空间。</p>
<p>  虽然名字称为链表，但实现形式不一定表现为链表。这一点要注意</p>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>采用位图（bit map）或位向量（bit vector），每块用一位表示，分配表示1，未分配表示0</p>
<p>优点：</p>
<p>查找空闲块和n个连续空闲块相对简单和高效。</p>
<p>缺点：</p>
<p>除非将整个位图都放在内存中方便及时查询，否则其效率就不是很高。这对于小型磁盘是完全可以的，但对大型磁盘，就需要相对较多的内存。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>将空闲磁盘块用链表连接起来，并将指向第一个空闲磁盘块的指针保存在磁盘的特殊位置，并同时放置到内存中。</p>
<p>这种方案的效率不高，因为遍历一遍链表需要大量的IO，但通常分配空闲空间不需要遍历，只需要将第一块分配即可。</p>
<h3 id="组group"><a href="#组group" class="headerlink" title="组group"></a>组group</h3><p>专门设置一些磁盘块临时存储多个空闲磁盘块的块号；</p>
<p>磁盘块号保存在同一个磁盘块中的那些空闲磁盘块，构成一组。</p>
<p>是为成组链接法；</p>
<p>将n个空闲块分成一组，每组中的第一块或最后一块保存下一组的空闲块地址，依次类推；</p>
<p>第一组的块地址保存在一个特殊空闲块中；</p>
<h3 id="Counting"><a href="#Counting" class="headerlink" title="Counting"></a>Counting</h3><p>建立一个类似于分区内存管理中的分区表；</p>
<p>每个表项记录第一块的块号和与第一块连续的空闲块的数量；</p>
<p>容易找到连续的空间</p>
<p>需要额外的空间</p>
<h2 id="效率和性能"><a href="#效率和性能" class="headerlink" title="效率和性能"></a>效率和性能</h2><p>效率取决于：</p>
<p>磁盘分配和目录算法</p>
<p>在文件的目录条目中保存的数据类型</p>
<p>表现</p>
<p>磁盘缓存 - 用于常用块的单独部分主内存</p>
<p>释放和预读 - 优化顺序访问的技术</p>
<p>通过将内存部分作为虚拟磁盘或RAM磁盘致敬，提高PC性能</p>
<h1 id="大容量存储器"><a href="#大容量存储器" class="headerlink" title="大容量存储器"></a>大容量存储器</h1><p>![img](E:\OneDrive - mail.sdu.edu.cn\md\image\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70.png)</p>
<ul>
<li>传输速率：驱动器和计算机之间的数据传输速率</li>
<li>定位时间&#x2F;随机访问时间：由寻道时间和旋转等待时间组成</li>
<li>寻道时间：移动磁臂到所有的柱面的时间</li>
<li>旋转等待时间：等待所要的扇区旋转到磁臂下所用的时间</li>
</ul>
<h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><p>现代磁盘驱动器可以看为是一个一维的逻辑块的数组，</p>
<p>其按顺序映射到磁盘的扇区</p>
<ul>
<li><p>扇区0是最外柱面的第一个磁道的第一个扇区。</p>
</li>
<li><p>逻辑块是最小的传输单位</p>
</li>
</ul>
<p>映射顺序：磁道内的扇区顺序$\Rightarrow$柱面内磁道顺序$\Rightarrow$柱面从外到内的顺序</p>
<p>磁道划分扇区，扇区存储容量相同、半径不同</p>
<p>柱面：于同一个垂直区域的磁道称为柱面</p>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>寻道时间：磁臂将磁头移动到包含目标扇区的柱面的时间。<br>旋转延迟：磁盘将目标扇区移动到磁头下的时间。<br>磁盘带宽：传递的总字节数 ÷ 从服务请求开始到结束的时间</p>
<p>时间&#x3D;寻道时间+旋转延迟+扇区存取时间</p>
<p>旋转延迟可以用半圈时间近似</p>
<p>调度柱面</p>
<h3 id="FCFS调度"><a href="#FCFS调度" class="headerlink" title="FCFS调度"></a>FCFS调度</h3><p>先到先服务算法</p>
<p>平均寻道距离大</p>
<ul>
<li>磁臂来回摆动</li>
<li>效率低</li>
</ul>
<p>会出现大摆动问题</p>
<h3 id="SSTF调度"><a href="#SSTF调度" class="headerlink" title="SSTF调度"></a>SSTF调度</h3><p>最短寻道时间优先算法</p>
<p>选择距离当前磁头位置判定的最短寻道的位置</p>
<p>![image-20211213203748163](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211213203748163.png)</p>
<p>可能会导致饥饿现象</p>
<p>不能保证平均寻道时间最短</p>
<h3 id="SCAN调度"><a href="#SCAN调度" class="headerlink" title="SCAN调度"></a>SCAN调度</h3><p>也被称为电梯调度</p>
<p>磁臂从一端到另一端移动，处理经过的所有请求，随后改变移动方向，继续处理。</p>
<ul>
<li>磁头当前位置</li>
<li>磁头当前移动方向</li>
</ul>
<p>避免饥饿现象</p>
<p>另一端等待服务的请求可能很多，等待时间也可能很长</p>
<h3 id="C-SCAN调度"><a href="#C-SCAN调度" class="headerlink" title="C-SCAN调度"></a>C-SCAN调度</h3><p>规定磁头单向移动。系统沿着一个方向（例如由内向外），依次对请求进行服务，到达最外端后，磁头立即返回到最内端，然后再由里向外依次对请求进行服务。</p>
<p>公平</p>
<h3 id="LOOK调度"><a href="#LOOK调度" class="headerlink" title="LOOK调度"></a>LOOK调度</h3><p>SCAN和C-SCAN是在整个磁盘范围内移动，但实际上只需要在有请求的最大区间范围内移动即可。</p>
<p>在向一个方向移动时判断是否有请求，并根据请求的边界来放置磁头，这种形式的SCAN调度被称为LOOK调度（同样C-LOOK对应C-SCAN）</p>
<h3 id="选择调度算法"><a href="#选择调度算法" class="headerlink" title="选择调度算法"></a>选择调度算法</h3><ul>
<li>SSTF最常见</li>
<li>SCAN和C-SCAN对于负载沉重的系统执行更好</li>
<li>性能取决于请求的数量和类型<ul>
<li>可能受到文件分配方法的影响</li>
</ul>
</li>
</ul>
<p>对于FLASH等半导体存储器，不需要考虑寻到和旋转延迟，FCFS效率最高</p>
<h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><p>SFT-I低级磁盘容错技术</p>
<ul>
<li>防止磁盘表面发生缺陷所引起的数据丢失；</li>
</ul>
<p>SFT-II中级磁盘容错技术 （RAID</p>
<ul>
<li>防止磁盘驱动器和磁盘控制器故障所引起的系统不能正常工作；</li>
</ul>
<p>SFT-III高级磁盘容错技术</p>
<ul>
<li>机器或系统出现故障；</li>
</ul>
<h3 id="低级磁盘容错技术"><a href="#低级磁盘容错技术" class="headerlink" title="低级磁盘容错技术"></a>低级磁盘容错技术</h3><p>容错：一般都是采用数据冗余。<br>防止磁盘表面发生缺陷所引起的数据丢失；<br>双备份目录表、双备份FCB表、双备份文件分配表等有关文件系统所需数据结构<br>热修复重定向和写后读校验<br>     ￭ 热修复重定向<br>        磁盘格式化时系统一般都预留一部分扇区，用于存放当写入数据发现坏扇区时，用于替换坏扇区；（不属于任何分区, bad sector mapping）<br>     ￭ 写后读校验<br>      写入数据后立即读出进行比较，判断是否因磁盘表面损坏而导致的写入错误</p>
<h3 id="中级磁盘容错技术"><a href="#中级磁盘容错技术" class="headerlink" title="中级磁盘容错技术"></a>中级磁盘容错技术</h3><p>防止磁盘驱动器和磁盘控制器故障所引起的系统不能正常工作</p>
<p>RAID技术—Redundant arrays of inexpensive disks (早期：廉价磁盘冗余阵列)<br>RAID— Redundant arrays of independent  disks (现在：独立磁盘冗余阵列)</p>
<h3 id="高级磁盘容错技术"><a href="#高级磁盘容错技术" class="headerlink" title="高级磁盘容错技术"></a>高级磁盘容错技术</h3><p>防止机器或系统出现故障，造成数据丢失</p>
<p>系统热备份（机器热备份）</p>
<h3 id="RAID结构"><a href="#RAID结构" class="headerlink" title="RAID结构"></a>RAID结构</h3><p>Redundant Arrays of Inexpensive Disks </p>
<ul>
<li>廉价磁盘冗余阵列</li>
</ul>
<p>Redundant Array of Independent Disks</p>
<ul>
<li>独立磁盘冗余阵列</li>
</ul>
<p>多个磁盘驱动器通过冗余提供可靠性和性能。</p>
<p>RAID分为六个不同的级别。</p>
<p>每个分区上的文件系统称为一个卷（volume）<br>卷集：多个磁盘分区组合成一个卷集，数据按分区顺序存取<br>带区集：多个磁盘分区组合成一个卷集，多个卷交叉存取</p>
<p>RAID方案通过存储冗余数据，提高存储系统的性能和可靠性。</p>
<p>镜像或阴影保留每个磁盘的副本。</p>
<p>块交错奇偶校验使用更少的冗余。</p>
<p>并行交叉存取技术</p>
<p>￭ 改善系统的可靠性－数据冗余及 校验+容错技术<br>￭ 提高系统的性能－并行交叉存取（位级或块级分散）</p>
<p>将数据按位级或者按块级分散写入到多个磁盘上，多个磁盘可以同时读写存取操作，实现数据的并行存取－提高了系统的性能；<br>如果再结合数据冗余技术及校验技术，例如磁盘镜像、其它校验技术（CRC、Hamming等），还可以提高系统的可靠性；</p>
<h1 id="I-x2F-O系统"><a href="#I-x2F-O系统" class="headerlink" title="I&#x2F;O系统"></a>I&#x2F;O系统</h1><p>I&#x2F;O管理是操作系统设计和操作的一个重要组成部分</p>
<ul>
<li>计算机操作的重要方面</li>
<li>I&#x2F;O设备差异很大</li>
<li>控制它们的有很多方法</li>
<li>性能管理</li>
<li>新型设备层出不穷</li>
</ul>
<p>端口，总线，设备控制器连接到各种设备</p>
<p>设备驱动程序封装设备细节</p>
<ul>
<li>为I&#x2F;O子系统提供统一的设备访问接口</li>
</ul>
<p>控制I&#x2F;O设备需要多种方法，因为它们在功能和速度上差异很大。</p>
<p>这些方法形成了内核的I&#x2F;O子系统，它将内核的其余部分从I&#x2F;O设备的复杂性中分离出来。</p>
<p>I&#x2F; o设备技术呈现出两种相互矛盾的趋势</p>
<ul>
<li><p>软硬件接口标准化;</p>
</li>
<li><p>I&#x2F;O设备更广泛;</p>
</li>
</ul>
<h2 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h2><p>为各种不同的I&#x2F;O设备提供到I&#x2F;O子系统的统一的设备访问接口</p>
<p>系统为不同的设备设计了不同的设备驱动程序</p>
<ul>
<li><p>对于不同硬件设备，为I&#x2F;O子系统提供了统一的设备访问接口</p>
</li>
<li><p>根据I&#x2F;O子系统的要求完成对硬件设备的具体访问</p>
</li>
<li><p>是硬件设备和系统之间的桥梁</p>
</li>
<li><p>简化了I&#x2F;O子系统的设计</p>
</li>
</ul>
<p>类似于VFS中的虚拟文件接口层(VFS Interface)，为不同的文件系统提供了统一的文件系统调用接口</p>
<p>例如系统调用提供了应用程序和操作系统之间的标准接口。</p>
<p>统一访问接口的使用，方便了内核及应用程序的设计与编码，但也导致应用程序无法使用设备的具体特性，降低了设备的性能；<br>UNIX为此提供了一个系统调用Ioctl()， 用户可以通过该系统调用直接通过设备驱动程序操纵I&#x2F;O设备；</p>
<p>I&#x2F;O系统调用为应用程序提供了统一的调用接口，隐含了硬件设备的不同</p>
<ul>
<li>由I&#x2F;O子系统负责处理对不同设备的访问）</li>
</ul>
<p>设备驱动程序层为I&#x2F;O子系统提供统一的访问接口，隐含了I&#x2F;O控制器的不同</p>
<p>使I&#x2F;O子系统独立于硬件可以简化操作系统开发人员的工作。</p>
<p>![image-20211214002540664](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211214002540664.png)</p>
<h2 id="阻塞和非阻塞I-x2F-O"><a href="#阻塞和非阻塞I-x2F-O" class="headerlink" title="阻塞和非阻塞I&#x2F;O"></a>阻塞和非阻塞I&#x2F;O</h2><ul>
<li><p>阻塞：进程挂起（阻塞）直到I&#x2F;O完成</p>
<ul>
<li>易于使用和理解</li>
<li>不足以满足某些需求</li>
<li>进程必须等待某一个时间发生后才能继续执行；<br>如登录某个系统，系统需要等待用户输入用户名、密码等信息才能继续执行；</li>
</ul>
</li>
<li><p>非阻塞：I&#x2F;O尽可能返回可用</p>
<ul>
<li>用户界面，数据复制（I&#x2F;O缓冲）在两个设备之间</li>
<li>通过多线程实现</li>
<li>快速返回读取或写入的字节计数</li>
<li>非阻塞的read()立即返回可用的数据——请求的全部字节数、更少的字节数或根本没有字节数。</li>
</ul>
</li>
<li><p>异步：进程在执行I&#x2F;O时同步运行</p>
<ul>
<li>另一种非阻塞I&#x2F;O</li>
<li>一个异步读调用请求一个传输，传输将在未来的某个时间点完成执行</li>
<li>IO完成时，IO子系统通知进程</li>
<li>难以使用</li>
</ul>
</li>
</ul>
<p>非阻塞IO</p>
<ul>
<li>当I&#x2F;O可能来自多个来源，并且I&#x2F;O到达的顺序没有预先确定时，非阻塞I&#x2F;O是有用的;</li>
<li>当进程或线程同时处理多个I&#x2F;O时，有些I&#x2F;O可以不需要等待其完成即可继续执行</li>
<li>多线程环境下，有的线程采用blocking I&#x2F;O，其它线程可继续执行，整体上看是非阻塞方式</li>
</ul>
<p>IO调度</p>
<p>目的：提高系统效率、降低平均等待时间</p>
<p>对于大部分的设备独占是设备，一般采用非优先级+先来先服务的调度算法</p>
<p>缓冲</p>
<p>缓冲区是在两个设备之间或一个设备和一个应用程序之间传输数据时存储数据的内存区域。</p>
<p>缓冲-在设备之间传输时将数据存储在内存中</p>
<p>为什么缓冲?</p>
<ul>
<li>解决设备速度不匹配的问题</li>
<li>解决传输尺寸不匹配的问题</li>
<li>维护复制语义<ul>
<li>应用程序缓冲区和内核缓冲区</li>
<li>当一个进程调用write()将buffer中的数据写入磁盘，在核心将buffer中的数据写磁盘的过程中，进程对buffer中的数据进行了修改。<br>根据“复制语义”的要求，本次写入磁盘的数据应该是在发出系统调用write()时buffer中的数据，其后的修改与本次write()调用无关。<br>如果采用互斥，对buffer加锁，会降低系统的性能。</li>
</ul>
</li>
</ul>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>高速缓存：更高速的保存数据的存储器，访问cache比访问原始副本更快</p>
<p>缓冲区和缓存的曲别</p>
<ul>
<li>缓冲区保存一个数据项的唯一现有副本</li>
<li>缓存只是在更快的存储空间中保存的存储项的副本</li>
</ul>
<p>缓存和缓冲是截然不同的功能，但有时内存区域可以同时用于这两种目的。</p>
<ul>
<li><p>(Unix中的磁盘缓存)操作系统在主内存中使用缓冲区来保存磁盘数据。</p>
</li>
<li><p>这些缓冲区还被用作缓存，以提高由应用程序共享的文件或正在快速写入和重读的文件的文件I&#x2F;O效率。</p>
</li>
</ul>
<p>目的：解决独占设备的并发访问问题，以提高设备的利用率</p>
<h2 id="SPOOLing技术"><a href="#SPOOLing技术" class="headerlink" title="SPOOLing技术"></a>SPOOLing技术</h2><p>Simultaneous Peripheral Operations On Line<br>外部设备联机并行操作</p>
<p>又称为假脱机</p>
<p>脱机输入是利用专门的外围控制机将低速I&#x2F;O设备上的数据预先输入到磁盘上，然后主机从磁盘上直接读取输入数据；<br>脱机输出是主机先将输出数据写入到磁盘上，然后利用专门的外围控制机将磁盘上的数据在低速I&#x2F;O设备上输出；<br>脱机I&#x2F;O的采用提高了主机的输入输出速度；</p>
<p>SPOOLing技术利用一台可共享的、高速大容量的块设备（通常是硬盘）来模拟独享设备的操作，使一台独享设备变为多台可并行使用的虚拟设备，即把独享设备变为逻辑上的共享设备；</p>
<ul>
<li>当用户提交一个文档给打印机时，系统为该打印请求在磁盘上创建了一个文件，然后将欲打印的文档内容写入该文件中；</li>
<li>同时在系统的打印队列中建立一张打印表；<br>系统依次将打印对列中的打印请求提交打印机打印；</li>
<li>可以理解为：基于SPOOLing技术，OS将物理打印机虚拟为磁盘上的一个文件；</li>
</ul>
<p>输入井与输出井<br>      ￭ 在磁盘上开辟的两块存储空间；<br>       ￭ 输入井模拟脱机输入时的磁盘，收容输入数据；<br>       ￭ 输出井模拟脱机输出时的磁盘，收容输出数据；<br>输入缓冲区与输出缓冲区（buffer）<br>      ￭ 在内存中开辟的两个缓冲区<br>        ￭ 输入缓冲区用于暂存输入设备输入的数据，然后传送到输入井；<br>        ￭ 输出缓冲区用于暂存从输出井来的数据，然后传送给输出设备；<br>输入进程与输出进程<br>       ￭ 输入进程将用户要求的数据从输入设备通过输入缓冲区送到输入井；当CPU需要输入数据时，直接从输入井中读入；<br>      ￭ 输出进程将用户需要输出的数据送入输出井；当输出设备空闲时，从输出井读出数据，通过输出缓冲区送入输出设备上；<br>请求输出队列<br>      ￭ 系统为每个请求输出的进程建立一张请求输出表；若干张请求输出表形成一个请求输出队列；当输出设备空闲时，按该队列的顺序依次输出； </p>
<p>特点</p>
<p>￭ 提高了I&#x2F;O的速度；<br>    ￭ 将独占设备改造成共享设备；<br>    ￭ 实现了虚拟设备；</p>
<h3 id="IO保护"><a href="#IO保护" class="headerlink" title="IO保护"></a>IO保护</h3><p>用户进程可能会意外或故意试图通过非法的I&#x2F;O指令来中断正常的操作</p>
<ul>
<li><p>所有I&#x2F;O指令被定义为特权</p>
</li>
<li><p>I&#x2F;O必须通过系统调用来执行</p>
<ul>
<li>内存映射和I&#x2F;O端口内存位置也必须受到保护</li>
</ul>
</li>
</ul>
<h2 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h2><p>也称为设备的无关性：应用程序独立于具体使用的物理设备<br>逻辑设备与物理设备 </p>
<ul>
<li>在应用程序中使用逻辑设备名称来请求使用某类设备；</li>
<li>进程在申请设备时，请求的是逻辑设备，操作系统会将系统中目前空闲可用的物理设备分配给该进程</li>
<li>操作系统需要借助逻辑设备表（LUT）完成从逻辑设备到物理设备的映射</li>
</ul>
<p>优点</p>
<ul>
<li>设备分配时的灵活性；</li>
<li>易于实现I&#x2F;O重定向(借助于LUT)；</li>
</ul>
<p>实现</p>
<ul>
<li>在设备驱动程序之上设置一层“设备独立性软件”，以执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换（为此应设置一张逻辑设备表）并向用户层（或文件层）软件提供统一接口，从而实现设备的独立性。</li>
<li>操作系统把所有外部设备统一当作成文件来看待，任何用户都可以象使用文件一样操纵、使用这些设备，而不必知道它们的具体存在形式。</li>
</ul>
<h1 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h1><p>保护 (Protection)</p>
<ul>
<li>保护系统的资源不被合法用户滥用（误用）；</li>
<li>保护系统的资源被合法的用户正确使用，不被用户有意或恶意地违反相应的约束；</li>
<li>保证系统中活动的程序组件只能以规定的策略、一致的方式使用系统的资源；</li>
<li>保护的主要手段<ul>
<li>授权；(如不同用户建立相应的登录帐户，并授予相应的权限)</li>
</ul>
</li>
</ul>
<p>安全(Security)</p>
<ul>
<li>防止非法用户侵入计算机系统而使信息泄密或造成系统的损坏</li>
<li>安全的主要手段<ul>
<li>用户身份认证</li>
<li>入侵检测（IDS）</li>
<li>病毒检测；</li>
<li>数据加密等；</li>
</ul>
</li>
</ul>
<h2 id="全局保护"><a href="#全局保护" class="headerlink" title="全局保护"></a>全局保护</h2><p>操作系统由一组对象、硬件或软件组成</p>
<p>每个对象都有一个唯一的名称，可以通过一组定义良好的操作来访问。</p>
<p>保护问题,</p>
<ul>
<li><p>确保正确访问每个对象，</p>
</li>
<li><p>只有那些被允许进程可以访问。</p>
</li>
</ul>
<p>保护指导原则-最低特权原则</p>
<p>程序、用户和系统应该被给予足够的特权来执行它们的任务</p>
<p>须知原则</p>
<ul>
<li><p>一个流程应该能够访问它当前完成其任务所需的资源。</p>
</li>
<li><p>它在限制故障进程对系统造成的损害程度方面非常有用。</p>
</li>
</ul>
<p>保护域</p>
<ul>
<li><p>指定进程可以访问的资源。</p>
</li>
<li><p>每个域定义了一组对象和可能在每个对象上调用的操作类型。</p>
</li>
<li><p>存取权</p>
<ul>
<li>在对象上执行操作的能力;</li>
<li>Access-right &#x3D; &lt;object-name, rights-set&gt;</li>
<li>其中，rights-set是可以在该对象上执行的所有有效操作的子集。</li>
</ul>
</li>
</ul>
<p>域是访问权限的集合，每个域都是有序的一对&lt;object-name, rights-set&gt;。</p>
<p>对象可能是</p>
<ul>
<li>硬件对象和软件对象</li>
</ul>
<p>![image-20211214154907544](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211214154907544.png)</p>
<p>每个用户可以是一个域</p>
<ul>
<li><p>可以访问的对象集取决于用户的身份。(对象,例如。文件。设备等)</p>
</li>
<li><p>域切换发生在用户更改时——通常是在一个用户注销而另一个用户登录时。</p>
</li>
</ul>
<p>每个进程可以是一个域</p>
<ul>
<li><p>可以访问的对象集取决于进程的标识。</p>
</li>
<li><p>当一个进程向另一个进程发送消息，然后等待响应时，就会发生域切换。</p>
</li>
</ul>
<p>每个过程可以是一个域</p>
<ul>
<li><p>一个过程可以被评价为一种方法</p>
</li>
<li><p>可以访问的对象集对应于过程中定义的局部变量。</p>
</li>
<li><p>在进行过程调用时发生域切换。</p>
</li>
</ul>
<h2 id="访问矩阵"><a href="#访问矩阵" class="headerlink" title="访问矩阵"></a>访问矩阵</h2><p>将保护视为一个矩阵(访问矩阵)</p>
<ul>
<li><p>行代表域</p>
</li>
<li><p>列代表对象</p>
</li>
</ul>
<p>入口访问(i, j)是在Domain Di中执行的进程可以对Object Oj调用的一组操作</p>
<p>![image-20211214160328490](E:\OneDrive - mail.sdu.edu.cn\md\image\image-20211214160328490.png)</p>
<p>实现</p>
<p>全局表</p>
<p>每列&#x3D;一个对象的访问控制列表(ACL,AL)</p>
<p>每行&#x3D;能力列表(就像一个键)</p>
<p>全局表</p>
<ul>
<li><p>由一组有序三元组&lt;domain, object, right set&gt;组成;</p>
</li>
<li><p>每当对对象Oj执行操作M时，就会在全局表中搜索具有M$\in$Rk的三元组&lt;Di,Oj,Rk&gt;</p>
<ul>
<li>如果找到这个三元组，则允许继续操作;</li>
<li>否则，将引发一个异常条件。</li>
</ul>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>表通常较长，因此不能保存在主存中，需要额外的I&#x2F;O;</p>
</li>
<li><p>很难利用对象或域的特殊分组。</p>
</li>
<li><p>(例如，如果每个人都可以读取一个特定的对象，那么它必须在每个域中有一个单独的条目)</p>
</li>
</ul>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>保护可以应用于非文件资源</p>
<p>Solaris 10提供了基于角色的访问控制(RBAC)来实现最小权限</p>
<ul>
<li><p>特权是执行系统调用或在系统调用中使用选项的权利</p>
</li>
<li><p>可以分配给进程</p>
</li>
<li><p>用户分配角色，授权访问特权和程序</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/07/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/09/lab3/" rel="next" title="lab3">
      lab3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OS%E7%9A%84%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2"><span class="nav-number">1.</span> <span class="nav-text">OS的发展简史</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A9%E6%9C%9F%E7%9A%84OS-%E7%AE%80%E5%8D%95%E7%9A%84%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F-%E4%BA%BA%E5%B7%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">早期的OS-简单的监控程序+人工操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.</span> <span class="nav-text">批处理系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E5%B0%8F%E7%BB%93"><span class="nav-number">1.2.1.</span> <span class="nav-text">单道批处理系统小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">多道批处理系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.</span> <span class="nav-text">分时系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX%EF%BC%9A%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%A3%E8%A1%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">UNIX：现代操作系统的代表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.4.</span> <span class="nav-text">桌面系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.5.</span> <span class="nav-text">并行系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.6.</span> <span class="nav-text">集群系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.7.</span> <span class="nav-text">实时系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">操作系统介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.</span> <span class="nav-text">计算机系统操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">2.1.2.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.3.</span> <span class="nav-text">存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-x2F-O%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">I&#x2F;O结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">计算机体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.</span> <span class="nav-text">操作系统结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.</span> <span class="nav-text">操作系统的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.5.1.</span> <span class="nav-text">系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-1"><span class="nav-number">2.6.</span> <span class="nav-text">操作系统结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1"><span class="nav-number">2.7.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.8.</span> <span class="nav-text">系统调用的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.9.</span> <span class="nav-text">系统调用的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2"><span class="nav-number">2.10.</span> <span class="nav-text">操作系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84"><span class="nav-number">2.10.1.</span> <span class="nav-text">简单结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95"><span class="nav-number">2.10.2.</span> <span class="nav-text">分层方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="nav-number">2.10.3.</span> <span class="nav-text">微内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">2.10.4.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">2.10.5.</span> <span class="nav-text">虚拟机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">3.1.</span> <span class="nav-text">进程的五个基本特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">3.2.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PCB"><span class="nav-number">3.3.</span> <span class="nav-text">PCB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB%E8%A1%A8"><span class="nav-number">3.3.1.</span> <span class="nav-text">PCB表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">3.4.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="nav-number">3.4.1.</span> <span class="nav-text">调度队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.4.2.</span> <span class="nav-text">调度程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">3.4.3.</span> <span class="nav-text">上下文切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="nav-number">3.5.</span> <span class="nav-text">进程操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">3.5.1.</span> <span class="nav-text">进程创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">3.5.2.</span> <span class="nav-text">进程终止</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">3.6.</span> <span class="nav-text">进程间通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">多线程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="nav-number">4.2.</span> <span class="nav-text">线程库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.</span> <span class="nav-text">多线程问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">4.3.1.</span> <span class="nav-text">线程池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU%E8%B0%83%E5%BA%A6"><span class="nav-number">5.</span> <span class="nav-text">CPU调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU%E7%A8%8B%E5%BA%8F%E8%B0%83%E5%BA%A6"><span class="nav-number">5.0.1.</span> <span class="nav-text">CPU程序调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6"><span class="nav-number">5.0.2.</span> <span class="nav-text">抢占调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B4%BE%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.0.3.</span> <span class="nav-text">分派程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="nav-number">5.1.</span> <span class="nav-text">调度准则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E5%88%B0%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6-First-Come%EF%BC%8CFirst-Served-scheduling"><span class="nav-number">5.2.1.</span> <span class="nav-text">先到先服务调度(First-Come，First-Served scheduling)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88shortest-job-first-scheduling-SJF"><span class="nav-number">5.2.2.</span> <span class="nav-text">最短作业优先算法（shortest-job-first scheduling,SJF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6-priority-scheduling-algorithm"><span class="nav-number">5.2.3.</span> <span class="nav-text">优先级调度(priority scheduling algorithm)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AE%E8%BD%AC%E6%B3%95%E8%B0%83%E5%BA%A6-round-robin-RR"><span class="nav-number">5.2.4.</span> <span class="nav-text">轮转法调度(round-robin,RR)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6-Multilevel-Queue-Scheduling"><span class="nav-number">5.2.5.</span> <span class="nav-text">多级队列调度(Multilevel Queue Scheduling)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6-Multilevel-Feedback-Queue-Scheduling"><span class="nav-number">5.2.6.</span> <span class="nav-text">多级反馈队列调度(Multilevel Feedback-Queue Scheduling)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">5.3.</span> <span class="nav-text">线程调度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">6.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98"><span class="nav-number">6.1.1.</span> <span class="nav-text">解决临界区问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Peterson%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">Peterson算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="nav-number">6.3.</span> <span class="nav-text">硬件同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88semaphore%EF%BC%89"><span class="nav-number">6.4.</span> <span class="nav-text">信号量（semaphore）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF"><span class="nav-number">6.4.1.</span> <span class="nav-text">死锁与饥饿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.</span> <span class="nav-text">经典同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.1.</span> <span class="nav-text">生产者消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.2.</span> <span class="nav-text">哲学家就餐问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9D%A1%E7%9C%A0%E7%9A%84%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.3.</span> <span class="nav-text">睡眠的理发师问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.4.</span> <span class="nav-text">吸烟者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%A1%E6%A3%8B%E5%AD%90%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.5.</span> <span class="nav-text">捡棋子问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%BA%A6%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E4%BA%92%E6%96%A5"><span class="nav-number">6.5.6.</span> <span class="nav-text">保证并发度的情况下实现临界资源互斥</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">6.6.</span> <span class="nav-text">管程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">7.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.1.</span> <span class="nav-text">系统模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">7.2.</span> <span class="nav-text">死锁的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="nav-number">7.2.1.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="nav-number">7.2.2.</span> <span class="nav-text">死锁避免</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="nav-number">7.3.</span> <span class="nav-text">死锁的检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-number">7.4.</span> <span class="nav-text">死锁的恢复</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">8.1.</span> <span class="nav-text">逻辑地址与物理地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83MMU"><span class="nav-number">8.2.</span> <span class="nav-text">内存管理单元MMU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="nav-number">8.3.</span> <span class="nav-text">用户程序的运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E6%B3%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">8.4.</span> <span class="nav-text">关注的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">8.5.</span> <span class="nav-text">连续内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A2%8E%E7%89%87"><span class="nav-number">8.5.1.</span> <span class="nav-text">碎片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">8.5.2.</span> <span class="nav-text">分区式存储管理的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5"><span class="nav-number">8.6.</span> <span class="nav-text">分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B%E4%B8%ADOS%E4%B8%8ECPU%E7%9A%84%E5%88%86%E5%B7%A5"><span class="nav-number">8.6.1.</span> <span class="nav-text">地址变换过程中OS与CPU的分工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-number">8.6.2.</span> <span class="nav-text">内存保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%A1%B5"><span class="nav-number">8.6.3.</span> <span class="nav-text">共享页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E9%A1%B5%E8%A1%A8"><span class="nav-number">8.6.4.</span> <span class="nav-text">层次页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash%E9%A1%B5%E8%A1%A8"><span class="nav-number">8.6.5.</span> <span class="nav-text">hash页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8"><span class="nav-number">8.6.6.</span> <span class="nav-text">反向页表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%AE%B5"><span class="nav-number">8.7.</span> <span class="nav-text">分段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.8.</span> <span class="nav-text">分段与分页的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="nav-number">8.9.</span> <span class="nav-text">段页式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">9.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.1.</span> <span class="nav-text">虚拟内存的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E9%9C%80%E8%B0%83%E9%A1%B5"><span class="nav-number">9.1.1.</span> <span class="nav-text">按需调页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">9.1.2.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-number">9.1.3.</span> <span class="nav-text">写时复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">9.2.</span> <span class="nav-text">页面置换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">9.2.1.</span> <span class="nav-text">页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">9.2.2.</span> <span class="nav-text">先进先出页面置换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E7%BD%AE%E6%8D%A2"><span class="nav-number">9.2.3.</span> <span class="nav-text">最优置换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8LRU"><span class="nav-number">9.2.4.</span> <span class="nav-text">最近最少使用LRU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%91%E4%BC%BCLRU%E9%A1%B5%E7%BD%AE%E6%8D%A2"><span class="nav-number">9.2.5.</span> <span class="nav-text">近似LRU页置换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%AE%A1%E6%95%B0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">9.2.6.</span> <span class="nav-text">基于计数的算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D"><span class="nav-number">9.3.</span> <span class="nav-text">页框分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%A2%A0%E7%B0%B8"><span class="nav-number">9.4.</span> <span class="nav-text">系统颠簸</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-number">9.5.</span> <span class="nav-text">内存映射文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">9.6.</span> <span class="nav-text">内核内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E4%BA%8B%E6%83%85"><span class="nav-number">9.7.</span> <span class="nav-text">其他需要考虑的事情</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">10.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">10.1.</span> <span class="nav-text">文件的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">10.2.</span> <span class="nav-text">目录结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">10.3.</span> <span class="nav-text">挂载文件系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.</span> <span class="nav-text">文件系统实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">11.1.</span> <span class="nav-text">虚拟文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.2.</span> <span class="nav-text">目录实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">11.3.</span> <span class="nav-text">分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-number">11.3.1.</span> <span class="nav-text">连续分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="nav-number">11.3.2.</span> <span class="nav-text">链接分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="nav-number">11.3.3.</span> <span class="nav-text">索引分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">11.4.</span> <span class="nav-text">空闲空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%9B%BE"><span class="nav-number">11.4.1.</span> <span class="nav-text">位图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">11.4.2.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84group"><span class="nav-number">11.4.3.</span> <span class="nav-text">组group</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Counting"><span class="nav-number">11.4.4.</span> <span class="nav-text">Counting</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%88%E7%8E%87%E5%92%8C%E6%80%A7%E8%83%BD"><span class="nav-number">11.5.</span> <span class="nav-text">效率和性能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">12.</span> <span class="nav-text">大容量存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="nav-number">12.1.</span> <span class="nav-text">磁盘结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="nav-number">12.2.</span> <span class="nav-text">磁盘调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FCFS%E8%B0%83%E5%BA%A6"><span class="nav-number">12.2.1.</span> <span class="nav-text">FCFS调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSTF%E8%B0%83%E5%BA%A6"><span class="nav-number">12.2.2.</span> <span class="nav-text">SSTF调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCAN%E8%B0%83%E5%BA%A6"><span class="nav-number">12.2.3.</span> <span class="nav-text">SCAN调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-SCAN%E8%B0%83%E5%BA%A6"><span class="nav-number">12.2.4.</span> <span class="nav-text">C-SCAN调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LOOK%E8%B0%83%E5%BA%A6"><span class="nav-number">12.2.5.</span> <span class="nav-text">LOOK调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">12.2.6.</span> <span class="nav-text">选择调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E9%94%99"><span class="nav-number">12.3.</span> <span class="nav-text">容错</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8E%E7%BA%A7%E7%A3%81%E7%9B%98%E5%AE%B9%E9%94%99%E6%8A%80%E6%9C%AF"><span class="nav-number">12.3.1.</span> <span class="nav-text">低级磁盘容错技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E7%BA%A7%E7%A3%81%E7%9B%98%E5%AE%B9%E9%94%99%E6%8A%80%E6%9C%AF"><span class="nav-number">12.3.2.</span> <span class="nav-text">中级磁盘容错技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%A3%81%E7%9B%98%E5%AE%B9%E9%94%99%E6%8A%80%E6%9C%AF"><span class="nav-number">12.3.3.</span> <span class="nav-text">高级磁盘容错技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID%E7%BB%93%E6%9E%84"><span class="nav-number">12.3.4.</span> <span class="nav-text">RAID结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-x2F-O%E7%B3%BB%E7%BB%9F"><span class="nav-number">13.</span> <span class="nav-text">I&#x2F;O系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="nav-number">13.1.</span> <span class="nav-text">设备驱动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9EI-x2F-O"><span class="nav-number">13.2.</span> <span class="nav-text">阻塞和非阻塞I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache"><span class="nav-number">13.2.1.</span> <span class="nav-text">Cache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPOOLing%E6%8A%80%E6%9C%AF"><span class="nav-number">13.3.</span> <span class="nav-text">SPOOLing技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E4%BF%9D%E6%8A%A4"><span class="nav-number">13.3.1.</span> <span class="nav-text">IO保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="nav-number">13.4.</span> <span class="nav-text">设备独立性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4"><span class="nav-number">14.</span> <span class="nav-text">保护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%BF%9D%E6%8A%A4"><span class="nav-number">14.1.</span> <span class="nav-text">全局保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%9F%A9%E9%98%B5"><span class="nav-number">14.2.</span> <span class="nav-text">访问矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">14.3.</span> <span class="nav-text">访问控制</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="一枚常指针"
      src="/images/profile_photo.jpg">
  <p class="site-author-name" itemprop="name">一枚常指针</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/pipixia23333" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pipixia23333" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">一枚常指针</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
