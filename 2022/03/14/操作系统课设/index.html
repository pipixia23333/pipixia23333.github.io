<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="操作系统课设Nachos系统总结中断控制器1、几个供外部程序使用的调用接口；  （1）Interrupt::SetLevel(IntOff)：用于关中断；  （2）Interrupt::SetLevel(IntOn)：用于开中断，并返回原中断的开关状态；外部程 序可通过调用这两个接口实现一些原子操作；  （3）Interrupt::Halt()：实现停机操作；  （4）Interrupt::Idl">
<meta property="og:type" content="article">
<meta property="og:title" content="Const_Point">
<meta property="og:url" content="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/index.html">
<meta property="og:site_name" content="Const_Point">
<meta property="og:description" content="操作系统课设Nachos系统总结中断控制器1、几个供外部程序使用的调用接口；  （1）Interrupt::SetLevel(IntOff)：用于关中断；  （2）Interrupt::SetLevel(IntOn)：用于开中断，并返回原中断的开关状态；外部程 序可通过调用这两个接口实现一些原子操作；  （3）Interrupt::Halt()：实现停机操作；  （4）Interrupt::Idl">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220312173117116.png">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220312220345657.png">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220313005518934.png">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314004009009.png">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314005505549.png">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314010620035.png">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314010126127.png">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314011027327.png">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314010728426.png">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314194850745.png">
<meta property="og:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220315235407884.png">
<meta property="article:published_time" content="2022-03-13T17:16:49.399Z">
<meta property="article:modified_time" content="2022-03-18T12:11:14.679Z">
<meta property="article:author" content="一枚常指针">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220312173117116.png">

<link rel="canonical" href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | Const_Point</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Const_Point</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile_photo.jpg">
      <meta itemprop="name" content="一枚常指针">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Const_Point">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-14 01:16:49" itemprop="dateCreated datePublished" datetime="2022-03-14T01:16:49+08:00">2022-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 20:11:14" itemprop="dateModified" datetime="2022-03-18T20:11:14+08:00">2022-03-18</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="操作系统课设"><a href="#操作系统课设" class="headerlink" title="操作系统课设"></a>操作系统课设</h1><h1 id="Nachos系统总结"><a href="#Nachos系统总结" class="headerlink" title="Nachos系统总结"></a>Nachos系统总结</h1><h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><p>1、几个供外部程序使用的调用接口； </p>
<p>（1）Interrupt::SetLevel(IntOff)：用于关中断； </p>
<p>（2）Interrupt::SetLevel(IntOn)：用于开中断，并返回原中断的开关状态；外部程 序可通过调用这两个接口实现一些原子操作； </p>
<p>（3）Interrupt::Halt()：实现停机操作； </p>
<p>（4）Interrupt::Idle()：相当于一般操作系统中的 idle 进程；</p>
<h3 id="中断响应时机"><a href="#中断响应时机" class="headerlink" title="中断响应时机"></a>中断响应时机</h3><p>（1）中断状态从关到开； </p>
<p>（2）Nachos 的 CPU 执行完一条应用程序指令； </p>
<p>因为只有上述两种情况发生时，系统时钟才增量（Interrupt::OneTick()，对于第一 种情况，增 10 个 ticks，第二种情况增 1 个 ticks），这时 Nachos 中断控制器才检查是 否有中断到期，如果有，则响应之；</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Nachos的进程在生命其中包括5个状态</p>
<p>JUST_CREADT：刚new</p>
<p>RUNNING：</p>
<p>READY：</p>
<p>BLOCKED：</p>
<p>JUST_CREAT-&gt;READY</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReadyToRun()</span><br></pre></td></tr></table></figure>

<p>BLOCKED-&gt;READY</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore::V()</span><br></pre></td></tr></table></figure>

<p>RUNNING-&gt;READY</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread::Yield()</span><br></pre></td></tr></table></figure>



<p>RUNNING-&gt;BOLOCKED</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread::Sleep()</span><br></pre></td></tr></table></figure>





<h1 id="实验一-Nachos系统的安装与调试"><a href="#实验一-Nachos系统的安装与调试" class="headerlink" title="实验一 Nachos系统的安装与调试"></a>实验一 Nachos系统的安装与调试</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>（1）安装编译 Nachos 系统，理解 Nachos 系统的组织结构与安装过程； </p>
<p>（2）安装测试 gcc MIPS 交叉编译器； </p>
<p>（3）掌握利用 Linux 调试工具 GDB 调试跟踪 Nachos 的执行过程； </p>
<p>（4）安装成功后，根据 Nachos 的输出结果，分析分析跟踪 Nachos 的 C++程序及汇编代码，理解 Nachos 中线程的创建方法以及上下文切换的过程。 </p>
<p>（5）阅读 Nachos 的相关源代码，理解 Nachos 内核的启动与停机过程。 </p>
<p>（6）理解 Nachos 的运行参数的含义与使用。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>（1） 安装 Linux 操作系统； </p>
<p>（2） 安装 Nachos 及 gcc mips 交叉编译程序； </p>
<p>（3） 编译测试 Nacho，并理解 Nachos 的运行参数的含义与使用； </p>
<p>（4） 运行 Nachos，根据 Nachos 的输出，理解 Nachos 中第一个线程是如何产生的。理解并掌握 Nachos 中其它内核线程的创建方法；理解 idle 线程的创建与作用。 进而理解一个实际的操作系统（如 Windows、Linux 等）的第一个进程是 如何产生的，以及 ideler 进程的创建与使用。 </p>
<p>（5） 理解 Nachos 中的上下文切换过程； </p>
<p>（6） 熟悉 gdb 调试工具；</p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="安装nachos"><a href="#安装nachos" class="headerlink" title="安装nachos"></a>安装nachos</h3><p>根据指导书操作</p>
<p>最终结果</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220312173117116.png" alt="image-20220312173117116"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>（1）在你所生成的 Nachos 系统中，下述函数的地址是多少？并说明找到这些函<br>数地址的过程及方法。<br>i. InterruptEnable()<br>ii. SimpleThread()<br>iii. ThreadFinish()<br>iv. ThreadRoot()</p>
<p>（2）下述线程对象的地址是多少？并说明找到这些对象地址的过程及方法。<br>i. the main thread of the Nachos<br>ii. the forked thread created by the main thread</p>
<p>（3）当主线程第一次运行 SWITCH()函数，执行到函数 SWITCH()的最后一条指<br>令 ret 时，CPU 返回的地址是多少？ 该地址对应程序的什么位置？</p>
<p>（4）当调用 Fork()新建的线程首次运行 SWITCH()函数时，当执行到函数<br>SWITCH()的最后一条指令 ret 时，CPU 返回的地址是多少？ 该地址对应程序的什么<br>位置？</p>
<h3 id="查询函数地址"><a href="#查询函数地址" class="headerlink" title="查询函数地址"></a>查询函数地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b InterruptEnable</span><br><span class="line">Breakpoint 1 at 0x3027: file thread.cc, line 242.</span><br><span class="line">(gdb) b SimpleThread</span><br><span class="line">Breakpoint 2 at 0x3275: file threadtest.cc, line 26.</span><br><span class="line">(gdb) b ThreadFinish</span><br><span class="line">Breakpoint 3 at 0x2ffc: file thread.cc, line 241.</span><br><span class="line">(gdb) b ThreadRoot</span><br><span class="line">Breakpoint 4 at 0x4e7c</span><br></pre></td></tr></table></figure>



<h3 id="查询对象地址"><a href="#查询对象地址" class="headerlink" title="查询对象地址"></a>查询对象地址</h3><p>主线程对象的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p currentThread</span><br><span class="line">$1 = (Thread *) 0x56563ca0</span><br></pre></td></tr></table></figure>



<p>主线程 fork的线程地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">42	ThreadTest()</span><br><span class="line">43	&#123;</span><br><span class="line">44	    DEBUG(&#x27;t&#x27;, &quot;Entering SimpleTest&quot;);</span><br><span class="line">45	</span><br><span class="line">46	    Thread *t = new Thread(&quot;forked thread&quot;);</span><br><span class="line">47	</span><br><span class="line">(gdb) l</span><br><span class="line">48	    t-&gt;Fork(SimpleThread, 1);</span><br><span class="line">49	    SimpleThread(0);</span><br><span class="line">50	&#125;</span><br><span class="line">51	</span><br><span class="line">(gdb) b 48</span><br><span class="line">Breakpoint 9 at 0x56558327: file threadtest.cc, line 48.</span><br><span class="line">(gdb) print *t</span><br><span class="line">$2 = &#123;stackTop = 0x8e30, machineState = &#123;0, 0, -137625168, -135911936, </span><br><span class="line">    -137581328, -137541952, -137580576, -137789584, -137623792, -137623952, </span><br><span class="line">    -138281536, -135921024, -137160944, -135911792, -138496512, -138170064, </span><br><span class="line">    -138392816, -137958928&#125;, stack = 0xf7e60250 &lt;operator delete(void*)&gt;, </span><br><span class="line">  status = 4156468720, </span><br><span class="line">  name = 0xf7c01220 &lt;ssignal&gt; &quot;\363\017\036\373S\213D$\b\350K&quot;&#125;</span><br><span class="line">(gdb) p t</span><br><span class="line">$3 = (Thread *) 0x5655df40</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="查询SWITCH函数返回地址"><a href="#查询SWITCH函数返回地址" class="headerlink" title="查询SWITCH函数返回地址"></a>查询SWITCH函数返回地址</h3><p>SWITCH汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass SWITCH</span><br><span class="line">Dump of assembler code for function SWITCH:</span><br><span class="line">=&gt; 0x56559e86 &lt;+0&gt;:	mov    %eax,0x5655e054</span><br><span class="line">   0x56559e8b &lt;+5&gt;:	mov    0x4(%esp),%eax</span><br><span class="line">   0x56559e8f &lt;+9&gt;:	mov    %ebx,0x8(%eax)</span><br><span class="line">   0x56559e92 &lt;+12&gt;:	mov    %ecx,0xc(%eax)</span><br><span class="line">   0x56559e95 &lt;+15&gt;:	mov    %edx,0x10(%eax)</span><br><span class="line">   0x56559e98 &lt;+18&gt;:	mov    %esi,0x18(%eax)</span><br><span class="line">   0x56559e9b &lt;+21&gt;:	mov    %edi,0x1c(%eax)</span><br><span class="line">   0x56559e9e &lt;+24&gt;:	mov    %ebp,0x14(%eax)</span><br><span class="line">   0x56559ea1 &lt;+27&gt;:	mov    %esp,(%eax)</span><br><span class="line">   0x56559ea3 &lt;+29&gt;:	mov    0x5655e054,%ebx</span><br><span class="line">   0x56559ea9 &lt;+35&gt;:	mov    %ebx,0x4(%eax)</span><br><span class="line">   0x56559eac &lt;+38&gt;:	mov    (%esp),%ebx</span><br><span class="line">   0x56559eaf &lt;+41&gt;:	mov    %ebx,0x20(%eax)</span><br><span class="line">   0x56559eb2 &lt;+44&gt;:	mov    0x8(%esp),%eax</span><br><span class="line">   0x56559eb6 &lt;+48&gt;:	mov    0x4(%eax),%ebx</span><br><span class="line">   0x56559eb9 &lt;+51&gt;:	mov    %ebx,0x5655e054</span><br><span class="line">   0x56559ebf &lt;+57&gt;:	mov    0x8(%eax),%ebx</span><br><span class="line">   0x56559ec2 &lt;+60&gt;:	mov    0xc(%eax),%ecx</span><br><span class="line">   0x56559ec5 &lt;+63&gt;:	mov    0x10(%eax),%edx</span><br><span class="line">   0x56559ec8 &lt;+66&gt;:	mov    0x18(%eax),%esi</span><br><span class="line">   0x56559ecb &lt;+69&gt;:	mov    0x1c(%eax),%edi</span><br><span class="line">   0x56559ece &lt;+72&gt;:	mov    0x14(%eax),%ebp</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--ret</span><br><span class="line">   0x56559ed1 &lt;+75&gt;:	mov    (%eax),%esp</span><br><span class="line">   0x56559ed3 &lt;+77&gt;:	mov    0x20(%eax),%eax</span><br><span class="line">   0x56559ed6 &lt;+80&gt;:	mov    %eax,(%esp)</span><br><span class="line">   0x56559ed9 &lt;+83&gt;:	mov    0x5655e054,%eax</span><br><span class="line">   0x56559ede &lt;+88&gt;:	ret    </span><br><span class="line">   0x56559edf &lt;+89&gt;:	nop</span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eax中存储着新旧线程地址</p>
<p>在&lt;5&gt;之后查看寄存器内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">0x56559e8f in SWITCH ()</span><br><span class="line">(gdb) info r</span><br><span class="line">eax            0x56563ca0          1448492192</span><br><span class="line">ecx            0xc                 12</span><br><span class="line">edx            0x9                 9</span><br><span class="line">ebx            0x5655df40          1448468288</span><br><span class="line">esp            0xffffce6c          0xffffce6c</span><br><span class="line">ebp            0xffffce98          0xffffce98</span><br><span class="line">esi            0x5655a2e3          1448452835</span><br><span class="line">edi            0x56563d00          1448492288</span><br><span class="line">eip            0x56559e8f          0x56559e8f &lt;SWITCH+9&gt;</span><br><span class="line">eflags         0x296               [ PF AF SF IF ]</span><br><span class="line">cs             0x23                35</span><br><span class="line">ss             0x2b                43</span><br><span class="line">ds             0x2b                43</span><br><span class="line">es             0x2b                43</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x63                99</span><br></pre></td></tr></table></figure>





<p>在&lt;44&gt;之后查看寄存器信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">0x56559eb6 in SWITCH ()</span><br><span class="line">(gdb) info r</span><br><span class="line">eax            0x56563d00          1448492288</span><br><span class="line">ecx            0xc                 12</span><br><span class="line">edx            0x9                 9</span><br><span class="line">ebx            0x56556a26          1448438310</span><br><span class="line">esp            0xffffce6c          0xffffce6c</span><br><span class="line">ebp            0xffffce98          0xffffce98</span><br><span class="line">esi            0x5655a2e3          1448452835</span><br><span class="line">edi            0x56563d00          1448492288</span><br><span class="line">eip            0x56559eb6          0x56559eb6 &lt;SWITCH+48&gt;</span><br><span class="line">eflags         0x296               [ PF AF SF IF ]</span><br><span class="line">cs             0x23                35</span><br><span class="line">ss             0x2b                43</span><br><span class="line">ds             0x2b                43</span><br><span class="line">es             0x2b                43</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x63                99</span><br></pre></td></tr></table></figure>



<p>&lt;77&gt;行后查看寄存器信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">0x56559ed6 in SWITCH ()</span><br><span class="line">(gdb) info r</span><br><span class="line">eax            0x56559e78          1448451704</span><br><span class="line">ecx            0x56558027          1448443943</span><br><span class="line">edx            0x1                 1</span><br><span class="line">ebx            0x0                 0</span><br><span class="line">esp            0x56568d50          0x56568d50</span><br><span class="line">ebp            0x0                 0x0</span><br><span class="line">esi            0x56558275          1448444533</span><br><span class="line">edi            0x56557ffc          1448443900</span><br><span class="line">eip            0x56559ed6          0x56559ed6 &lt;SWITCH+80&gt;</span><br><span class="line">eflags         0x296               [ PF AF SF IF ]</span><br><span class="line">cs             0x23                35</span><br><span class="line">ss             0x2b                43</span><br><span class="line">ds             0x2b                43</span><br><span class="line">es             0x2b                43</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x63                99</span><br></pre></td></tr></table></figure>



<p>在&lt;88&gt;后查看下一条指令执行的地址，与&lt;77&gt;中eax存储的地址相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">0x56559e78 in ThreadRoot ()</span><br></pre></td></tr></table></figure>

<p>该地址为函数ThreadRoot的第一条汇编指令地址</p>
<h3 id="Fork后运行SWICH的返回地址"><a href="#Fork后运行SWICH的返回地址" class="headerlink" title="Fork后运行SWICH的返回地址"></a>Fork后运行SWICH的返回地址</h3><p>输入c后继续运行，查看第二次switch函数的返回地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x56559ede in SWITCH ()</span><br><span class="line">(gdb) ni</span><br><span class="line">0x56556a26 in Scheduler::Run (this=0x56563c80, nextThread=0x56563d00)</span><br><span class="line">    at scheduler.cc:116</span><br><span class="line">116	    SWITCH(oldThread, nextThread);</span><br><span class="line">(gdb) l</span><br><span class="line">111	    // This is a machine-dependent assembly language routine defined </span><br><span class="line">112	    // in switch.s.  You may have to think</span><br><span class="line">113	    // a bit to figure out what happens after this, both from the point</span><br><span class="line">114	    // of view of the thread and from the perspective of the &quot;outside world&quot;.</span><br><span class="line">115	</span><br><span class="line">116	    SWITCH(oldThread, nextThread);</span><br><span class="line">117	    </span><br><span class="line">118	    DEBUG(&#x27;t&#x27;, &quot;Now in thread \&quot;%s\&quot;\n&quot;, currentThread-&gt;getName());</span><br><span class="line">119	</span><br><span class="line">120	    // If the old thread gave up the processor because it was finishing,</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看run的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">disass Run</span><br><span class="line">Dump of assembler code for function Scheduler::Run(Thread*):</span><br><span class="line">   0x56556996 &lt;+0&gt;:	endbr32 </span><br><span class="line">   0x5655699a &lt;+4&gt;:	push   %ebp</span><br><span class="line">   0x5655699b &lt;+5&gt;:	mov    %esp,%ebp</span><br><span class="line">   0x5655699d &lt;+7&gt;:	push   %esi</span><br><span class="line">   0x5655699e &lt;+8&gt;:	push   %ebx</span><br><span class="line">   0x5655699f &lt;+9&gt;:	sub    $0x10,%esp</span><br><span class="line">   0x565569a2 &lt;+12&gt;:	call   0x565562f0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x565569a7 &lt;+17&gt;:	add    $0x7599,%ebx</span><br><span class="line">   0x565569ad &lt;+23&gt;:	lea    0xf4(%ebx),%eax</span><br><span class="line">   0x565569b3 &lt;+29&gt;:	mov    (%eax),%eax</span><br><span class="line">   0x565569b5 &lt;+31&gt;:	mov    %eax,-0xc(%ebp)</span><br><span class="line">   0x565569b8 &lt;+34&gt;:	sub    $0xc,%esp</span><br><span class="line">   0x565569bb &lt;+37&gt;:	pushl  -0xc(%ebp)</span><br><span class="line">   0x565569be &lt;+40&gt;:	call   0x56557c8c &lt;Thread::CheckOverflow()&gt;</span><br><span class="line">   0x565569c3 &lt;+45&gt;:	add    $0x10,%esp</span><br><span class="line">   0x565569c6 &lt;+48&gt;:	lea    0xf4(%ebx),%eax</span><br><span class="line">   0x565569cc &lt;+54&gt;:	mov    0xc(%ebp),%edx</span><br><span class="line">   0x565569cf &lt;+57&gt;:	mov    %edx,(%eax)</span><br><span class="line">   0x565569d1 &lt;+59&gt;:	lea    0xf4(%ebx),%eax</span><br><span class="line">   0x565569d7 &lt;+65&gt;:	mov    (%eax),%eax</span><br><span class="line">   0x565569d9 &lt;+67&gt;:	sub    $0x8,%esp</span><br><span class="line">   0x565569dc &lt;+70&gt;:	push   $0x1</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--ret</span><br><span class="line">   0x565569de &lt;+72&gt;:	push   %eax</span><br><span class="line">   0x565569df &lt;+73&gt;:	call   0x56556ade &lt;Thread::setStatus(ThreadStatus)&gt;</span><br><span class="line">   0x565569e4 &lt;+78&gt;:	add    $0x10,%esp</span><br><span class="line">   0x565569e7 &lt;+81&gt;:	sub    $0xc,%esp</span><br><span class="line">   0x565569ea &lt;+84&gt;:	pushl  0xc(%ebp)</span><br><span class="line">   0x565569ed &lt;+87&gt;:	call   0x56556afc &lt;Thread::getName()&gt;</span><br><span class="line">   0x565569f2 &lt;+92&gt;:	add    $0x10,%esp</span><br><span class="line">   0x565569f5 &lt;+95&gt;:	mov    %eax,%esi</span><br><span class="line">   0x565569f7 &lt;+97&gt;:	sub    $0xc,%esp</span><br><span class="line">   0x565569fa &lt;+100&gt;:	pushl  -0xc(%ebp)</span><br><span class="line">   0x565569fd &lt;+103&gt;:	call   0x56556afc &lt;Thread::getName()&gt;</span><br><span class="line">   0x56556a02 &lt;+108&gt;:	add    $0x10,%esp</span><br><span class="line">   0x56556a05 &lt;+111&gt;:	push   %esi</span><br><span class="line">   0x56556a06 &lt;+112&gt;:	push   %eax</span><br><span class="line">   0x56556a07 &lt;+113&gt;:	lea    -0x3e7c(%ebx),%eax</span><br><span class="line">   0x56556a0d &lt;+119&gt;:	push   %eax</span><br><span class="line">   0x56556a0e &lt;+120&gt;:	push   $0x74</span><br><span class="line">   0x56556a10 &lt;+122&gt;:	call   0x565581e8 &lt;DEBUG(char, char const*, ...)&gt;</span><br><span class="line">   0x56556a15 &lt;+127&gt;:	add    $0x10,%esp</span><br><span class="line">   0x56556a18 &lt;+130&gt;:	sub    $0x8,%esp</span><br><span class="line">   0x56556a1b &lt;+133&gt;:	pushl  0xc(%ebp)</span><br><span class="line">   0x56556a1e &lt;+136&gt;:	pushl  -0xc(%ebp)</span><br><span class="line">   0x56556a21 &lt;+139&gt;:	call   0x56559e86 &lt;SWITCH&gt;</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--ret</span><br><span class="line">=&gt; 0x56556a26 &lt;+144&gt;:	add    $0x10,%esp</span><br><span class="line">   0x56556a29 &lt;+147&gt;:	lea    0xf4(%ebx),%eax</span><br><span class="line">   0x56556a2f &lt;+153&gt;:	mov    (%eax),%eax</span><br><span class="line">   0x56556a31 &lt;+155&gt;:	sub    $0xc,%esp</span><br><span class="line">   0x56556a34 &lt;+158&gt;:	push   %eax</span><br><span class="line">   0x56556a35 &lt;+159&gt;:	call   0x56556afc &lt;Thread::getName()&gt;</span><br><span class="line">   0x56556a3a &lt;+164&gt;:	add    $0x10,%esp</span><br><span class="line">   0x56556a3d &lt;+167&gt;:	sub    $0x4,%esp</span><br><span class="line">   0x56556a40 &lt;+170&gt;:	push   %eax</span><br><span class="line">   0x56556a41 &lt;+171&gt;:	lea    -0x3e51(%ebx),%eax</span><br><span class="line">   0x56556a47 &lt;+177&gt;:	push   %eax</span><br><span class="line">   0x56556a48 &lt;+178&gt;:	push   $0x74</span><br><span class="line">   0x56556a4a &lt;+180&gt;:	call   0x565581e8 &lt;DEBUG(char, char const*, ...)&gt;</span><br><span class="line">   0x56556a4f &lt;+185&gt;:	add    $0x10,%esp</span><br><span class="line">   0x56556a52 &lt;+188&gt;:	lea    0xf8(%ebx),%eax</span><br><span class="line">   0x56556a58 &lt;+194&gt;:	mov    (%eax),%eax</span><br><span class="line">   0x56556a5a &lt;+196&gt;:	test   %eax,%eax</span><br><span class="line">   0x56556a5c &lt;+198&gt;:	je     0x56556a90 &lt;Scheduler::Run(Thread*)+250&gt;</span><br><span class="line">   0x56556a5e &lt;+200&gt;:	lea    0xf8(%ebx),%eax</span><br><span class="line">   0x56556a64 &lt;+206&gt;:	mov    (%eax),%esi</span><br><span class="line">   0x56556a66 &lt;+208&gt;:	test   %esi,%esi</span><br><span class="line">   0x56556a68 &lt;+210&gt;:	je     0x56556a84 &lt;Scheduler::Run(Thread*)+238&gt;</span><br><span class="line">   0x56556a6a &lt;+212&gt;:	sub    $0xc,%esp</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现返回地址对应于run中调用函数SWITCH后紧跟着的一条指令</p>
<p>重复上述过程发现，SWITCH返回地址均与第二次运行后结果相同</p>
<p>通过阅读源码可知</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleThread(_int which)</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    </span><br><span class="line">    for (num = 0; num &lt; 5; num++) &#123;</span><br><span class="line">	printf(&quot;*** thread %d looped %d times\n&quot;, (int) which, num);</span><br><span class="line">        currentThread-&gt;Yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SWITCH函数用于交替执行这个函数</p>
<p>子线程第一次返回时，返回进入函数头部</p>
<p>之后交替执行</p>
<h1 id="实验二-Nachos的MAKEFILES"><a href="#实验二-Nachos的MAKEFILES" class="headerlink" title="实验二 Nachos的MAKEFILES"></a>实验二 Nachos的MAKEFILES</h1><p>目的与任务<br>该实验在目录 lab2 中完成。<br>（1）熟悉 Nachos 的 makefiles 的结构；<br>（2）熟悉如何在几个 lab 文件目录中构造相应的 Nachos 系统；</p>
<h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><ol>
<li><p>code&#x2F;下子目录中的Makefile文件主要内容</p>
<ul>
<li><p>include Makefile.local</p>
</li>
<li><p>include ..&#x2F;Makefile.common</p>
<p>将父目录下的 Makefile.common 包含了进来</p>
</li>
</ul>
</li>
<li><p>makefile.local文件</p>
<ul>
<li>主要作用：对一些编译、链接及运行时所使用的宏进行定义</li>
<li>CCFILES：指明在该目录下生成Nachos时所涉及到的C++源文件</li>
<li>INCPATH：指明所涉及的C++源程序中的头文件（.h文件）所在路径</li>
<li>DEFINES：传递g++的一些标号或宏</li>
</ul>
</li>
<li><p>Makefile.dep文件</p>
<ul>
<li>获取操作平台</li>
<li>给出gcc mips交叉编译器所在的路径及前缀</li>
<li>arch文件下三个文件夹分别存放<ul>
<li>可执行文件（nachos）</li>
<li>依赖文件（dependence files，如xxxx.d）</li>
<li>目标文件（object files，如xxx.o）</li>
</ul>
</li>
<li>code&#x2F;子目录下生成可执行文件的链接文件</li>
</ul>
</li>
<li><p>Makfile.common文件，定义了编译链接生成一个完整的Nachos可执行文件所需要的所有规则</p>
</li>
</ol>
<h3 id="在其他目录中修改Nachos代码并生成系统"><a href="#在其他目录中修改Nachos代码并生成系统" class="headerlink" title="在其他目录中修改Nachos代码并生成系统"></a>在其他目录中修改Nachos代码并生成系统</h3><p>lab1和lab2在code&#x2F;thread下完成</p>
<p>lab3在code&#x2F;monitor下完成</p>
<p>lab4和lab5在code&#x2F;filesys下完成</p>
<p>lab、lab7和lab8在code&#x2F;userprog下完成</p>
<h3 id="修改INPATH"><a href="#修改INPATH" class="headerlink" title="修改INPATH"></a>修改INPATH</h3><p>如若不修改INPATH</p>
<p>若修改xxxx.h文件，重新编译后只有同文件夹下的xxxx.cc文件会关联</p>
<p>其他文件中的头文件若包含xxxx.h文件，会优先寻找本文件夹下的xxxx.h文件</p>
<p>然后从 -I..&#x2F;threads -I..&#x2F;machine  两个文件夹下寻找</p>
<p>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCPATH += -I../&lt;文件夹名&gt; -I../threads -I../machine</span><br></pre></td></tr></table></figure>

<p>找不到文件就从该路径左至右寻找。</p>
<p>但该方法仍会导致只有目录lab2下的scheduler.cc使用lab2下的scheduler.h，其他目录中的.cc源文件仍然使用目录..&#x2F;threads下的scheduler.h</p>
<h3 id="寻找包含修改的-h文件的最小文件集"><a href="#寻找包含修改的-h文件的最小文件集" class="headerlink" title="寻找包含修改的.h文件的最小文件集"></a>寻找包含修改的.h文件的最小文件集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep scheduler.h *</span><br><span class="line">Grep选项：</span><br><span class="line">* : 表示当前目录所有文件，也可以是某个文件名</span><br><span class="line">-r 是递归查找</span><br><span class="line">-n 是显示行号</span><br><span class="line">-R 查找所有文件包含子目录</span><br><span class="line">-i 忽略大小写</span><br></pre></td></tr></table></figure>

<p>可以检查哪些文件中包含字符串</p>
<p>查找出包含修改后的.h文件的所有文件放入新建的文件夹中</p>
<p>使用touch命令更新所修改的的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1．命令格式：</span><br><span class="line">touch [选项]... 文件...</span><br><span class="line">2．命令参数：</span><br><span class="line">-a   或--time=atime或--time=access或--time=use 　只更改存取时间。</span><br><span class="line">-c   或--no-create 　不建立任何文档。</span><br><span class="line">-d 　使用指定的日期时间，而非现在的时间。</span><br><span class="line">-f 　此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。</span><br><span class="line">-m   或--time=mtime或--time=modify 　只更改变动时间。</span><br><span class="line">-r 　把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。</span><br><span class="line">-t 　使用指定的日期时间，而非现在的时间。</span><br><span class="line">3．命令功能：</span><br><span class="line">touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。 </span><br></pre></td></tr></table></figure>

<p>make</p>
<p>再touch未修改的其他文件目录下的原文件</p>
<p>重新make，观察nachos是否会被更新</p>
<h1 id="实验三-利用信号量实现线程同步"><a href="#实验三-利用信号量实现线程同步" class="headerlink" title="实验三 利用信号量实现线程同步"></a>实验三 利用信号量实现线程同步</h1><h2 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h2><p>（1）进一步理解 Nachos 中如何创建线程； </p>
<p>（2）理解 Nachos 中信号量与 P、V 操作是如何实现的 </p>
<p>（3）如何创建与使用 Nachos 的信号量 </p>
<p>（4）理解 Nachos 中是如何利用信号量实现 producer&#x2F;consumer problem；</p>
<p>（5）理解 Nachos 中如何测试与调试程序； </p>
<p>（6）理解 Nachos 中轮转法（RR）线程调度的实现；</p>
<h2 id="设计步骤与要求"><a href="#设计步骤与要求" class="headerlink" title="设计步骤与要求"></a>设计步骤与要求</h2><ol>
<li><p>在 code&#x2F;lab3 目录中， </p>
<ul>
<li>详细阅读并深刻理解 ring.h 及 ring.cc 中的所有代码； </li>
<li>阅读并理解 main.cc 的功能；</li>
<li>详细阅读并深刻理解 prodcons++.cc 的程序结构，在 prodcons++.cc 中添加或 修改相应的代码，满足设计要求。（可依据其中的注释添加相应的代码） </li>
<li>利用 make 编译生成新的 Nachos，并测试其功能是否满足设计要求；</li>
</ul>
</li>
<li><p>分析..&#x2F;threads&#x2F;threadtest.cc，理解利用 Thread::Fork()创建线程的方法； </p>
<p>分析 Thread::Fork() ，理解内核创建线程的过程</p>
<p>分析..&#x2F;threads&#x2F;synch.cc，理解 Nachos 中信号量是如何实现的； </p>
<p>分析..&#x2F;monitor&#x2F;prodcons++.cc，理解信号量的创建与使用方法； </p>
<p>分析 Thread::Fork() , Thread::Yiled(), Thread::Sleep(), Thread::Finish() ,, Scheduler::  Scheduler::ReadyToRun(), Scheduler::FindNextToRun(), Scheduler::Run()等相关函数，理解线程调度及上下文切换的工作过程；</p>
</li>
<li><p>在理解上述 Nachos 工作机理的基础上，补充或修改目录 lab3 中 prodcons++.cc 中的代码，利用 Nachos 实现的线程与信号量机制完善一个 producer&#x2F;consumer problem 测试程序。 </p>
</li>
<li><p>根据生产者&#x2F;消费者问题的功能定义，你的实现应该满足如下条件:</p>
</li>
</ol>
<ul>
<li>生产者线程所产生的所有的消息，都应该被消费者接收并保存到输出文件 中（tem_0，temp_1，…） </li>
<li>每个消息只能被接收一次且在文件保存一次 </li>
<li>来自于同一个生产者的消息，以及被同一个消费者接收到的消息，在文件保存的顺序应该按其序号升序排列；</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define BUFF_SIZE 3  // the size of the round buffer</span><br><span class="line">#define N_PROD    2  // the number of producers </span><br><span class="line">#define N_CONS    2  // the number of consumers</span><br><span class="line">#define N_MESSG   4  // the number of messages produced by each producer</span><br></pre></td></tr></table></figure>

<p>阅读代码可得</p>
<ul>
<li>缓冲区大小为：3</li>
<li>生产者个数：2</li>
<li>消费者个数：2</li>
<li>每个生产者发送信息数：4</li>
</ul>
<h3 id="理解信号量的实现"><a href="#理解信号量的实现" class="headerlink" title="理解信号量的实现"></a>理解信号量的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Semaphore &#123;</span><br><span class="line">  public:</span><br><span class="line">    Semaphore(char* debugName, int initialValue);	// 设置初值</span><br><span class="line">    ~Semaphore();   					// de-allocate semaphore</span><br><span class="line">    char* getName() &#123; return name;&#125;			// debugging assist</span><br><span class="line">    </span><br><span class="line">    void P();	 // 判断value是否大于0，否则加入queue队尾，睡眠当前线程</span><br><span class="line">    void V();	 // 返回队首线程，并设置状态为ready</span><br><span class="line">    </span><br><span class="line">  private:</span><br><span class="line">    char* name;        // debug的名字</span><br><span class="line">    int value;         // 信号量的值</span><br><span class="line">    List *queue;       // value为0时的等待队列</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>信号量的实现</p>
<p>关键操作为P、V操作</p>
<ul>
<li>P()的实现<ul>
<li>判断value是否为0</li>
<li>若为0，则将当前线程加入queue队尾，并调用sleep函数睡眠</li>
<li>不为0，value–</li>
</ul>
</li>
<li>v()的实现<ul>
<li>从queue队首拿出一个线程</li>
<li>若线程不为空，将其状态设置为READY</li>
<li>value++</li>
</ul>
</li>
</ul>
<h3 id="修改prodcons-cc的程序"><a href="#修改prodcons-cc的程序" class="headerlink" title="修改prodcons++.cc的程序"></a>修改prodcons++.cc的程序</h3><ul>
<li><p>参照monitor文件下prodcons++.cc文件的内容</p>
</li>
<li><p>根据生产者消费者模型</p>
</li>
</ul>
<p>修改程序如下（简要显示）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">nempty = new Semaphore(&quot;nempty&quot;,BUFF_SIZE);</span><br><span class="line">nfull = new Semaphore(&quot;nfull&quot;,0);</span><br><span class="line">mutex = new Semaphore(&quot;mutex&quot;,1);</span><br><span class="line">    </span><br><span class="line">ring = new Ring(BUFF_SIZE);</span><br><span class="line"></span><br><span class="line">producer &#123;</span><br><span class="line">    for (num = 0; num &lt; N_MESSG ; num++) &#123;</span><br><span class="line">    </span><br><span class="line">      message-&gt;thread_id = which;</span><br><span class="line">      message-&gt;value = num;</span><br><span class="line">      </span><br><span class="line">      nempty-&gt;P();</span><br><span class="line">      mutex-&gt;P();</span><br><span class="line"></span><br><span class="line">      ring-&gt;Put(message);</span><br><span class="line">      printf(&quot;producer %d produce thread %d ---&gt; valude d\n&quot;,which,which,num);</span><br><span class="line"></span><br><span class="line">      mutex-&gt;V();</span><br><span class="line">      nfull-&gt;V();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">      nfull-&gt;P();</span><br><span class="line">      mutex-&gt;P();</span><br><span class="line"></span><br><span class="line">      ring-&gt;Get(message);</span><br><span class="line">      printf(&quot;consumer %d get thread %d ---&gt; value %d\n&quot;,which,message-&gt;thread_id,message-&gt;value);</span><br><span class="line"></span><br><span class="line">      mutex-&gt;V();</span><br><span class="line">      nempty-&gt;V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改文件</p>
<p>可得实验结果</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220312220345657.png" alt="image-20220312220345657"></p>
<h3 id="分析并理解，Thread-Fork-创建线程的方法"><a href="#分析并理解，Thread-Fork-创建线程的方法" class="headerlink" title="分析并理解，Thread::Fork()创建线程的方法"></a>分析并理解，Thread::Fork()创建线程的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Thread::Fork(VoidFunctionPtr func, _int arg)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Forking thread \&quot;%s\&quot; with func = 0x%x, arg = %d\n&quot;,  name, (int) func, arg);//设置debug信息</span><br><span class="line">    </span><br><span class="line">    StackAllocate(func, arg);//为线程分配栈</span><br><span class="line"></span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);//关中断</span><br><span class="line">    scheduler-&gt;ReadyToRun(this);	// 将线程状态设置为ready并加入就绪队列</span><br><span class="line">    </span><br><span class="line">    (void) interrupt-&gt;SetLevel(oldLevel);//开中断</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>fork()</p>
<p>新建一个线程并设置状态为ready（放入准备就绪队列）</p>
<p>StackAllocate(func, arg);&#x2F;&#x2F;为线程分配栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">machineState[PCState] = (_int) ThreadRoot;//函数入口</span><br><span class="line">   machineState[StartupPCState] = (_int) InterruptEnable;</span><br><span class="line">   machineState[InitialPCState] = (_int) func;//函数运行体</span><br><span class="line">   machineState[InitialArgState] = arg;</span><br><span class="line">   machineState[WhenDonePCState] = (_int) ThreadFinish;//函数结束出口</span><br></pre></td></tr></table></figure>



<p>其他Thread和scheduler的函数分析请见备注</p>
<h3 id="rs轮转调度"><a href="#rs轮转调度" class="headerlink" title="-rs轮转调度"></a>-rs轮转调度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if (!strcmp(*argv, &quot;-rs&quot;)) &#123;</span><br><span class="line">	    ASSERT(argc &gt; 1);</span><br><span class="line">	    RandomInit(atoi(*(argv + 1)));	// initialize pseudo-random</span><br><span class="line">						// number generator</span><br><span class="line">	    randomYield = TRUE;</span><br><span class="line">	    argCount = 2;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>-rs后可跟数字，作为随机数初始化种子</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220313005518934.png" alt="image-20220313005518934"></p>
<p>可以看到与上次运行结果确实不同，在producer0产生的消息未填满缓冲区时就发生了调度</p>
<p>通过阅读Interrupt的源码可知，nachos中断响应的时机</p>
<ul>
<li>中断状态从关到开</li>
<li>Nachos的CPU执行完一条应用程序指令</li>
</ul>
<p>上述两种情况发生时，系统时钟调用Interrupt::OneTick()。</p>
<p>同时检查是否有中断到期，有则响应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (yieldOnReturn) &#123;		// if the timer device handler asked </span><br><span class="line">					// for a context switch, ok to do it now</span><br><span class="line">	yieldOnReturn = FALSE;</span><br><span class="line"> 	status = SystemMode;		// yield is a kernel routine</span><br><span class="line">	currentThread-&gt;Yield();</span><br><span class="line">	status = old;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时发生程序调度，当前进程转为READY状态，运行下一个就绪进程</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><h3 id="C语言函数"><a href="#C语言函数" class="headerlink" title="C语言函数"></a>C语言函数</h3><p>sprintf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sprintf(char *str, const char *format, ...) </span><br><span class="line">发送格式化输出到 str 所指向的字符串</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char str[80];</span><br><span class="line"></span><br><span class="line">   sprintf(str, &quot;Pi 的值 = %f&quot;, M_PI);</span><br><span class="line">   puts(str);</span><br><span class="line">   </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pi 的值 = 3.141593</span><br></pre></td></tr></table></figure>



<p>atoi</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int atoi(const char *str)</span><br></pre></td></tr></table></figure>

<p>把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int val;</span><br><span class="line">   char str[20];</span><br><span class="line">   </span><br><span class="line">   strcpy(str, &quot;98993489&quot;);</span><br><span class="line">   val = atoi(str);</span><br><span class="line">   printf(&quot;字符串值 = %s, 整型值 = %d\n&quot;, str, val);</span><br><span class="line"></span><br><span class="line">   strcpy(str, &quot;runoob.com&quot;);</span><br><span class="line">   val = atoi(str);</span><br><span class="line">   printf(&quot;字符串值 = %s, 整型值 = %d\n&quot;, str, val);</span><br><span class="line"></span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">字符串值 = 98993489, 整型值 = 98993489</span><br><span class="line">字符串值 = runoob.com, 整型值 = 0</span><br></pre></td></tr></table></figure>



<h2 id="上下文切换相关函数实现的分析"><a href="#上下文切换相关函数实现的分析" class="headerlink" title="上下文切换相关函数实现的分析"></a>上下文切换相关函数实现的分析</h2><h3 id="Thread-Yield"><a href="#Thread-Yield" class="headerlink" title="Thread::Yield()"></a>Thread::Yield()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Thread::Yield ()</span><br><span class="line">&#123;</span><br><span class="line">    Thread *nextThread;</span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);//关中断</span><br><span class="line">    </span><br><span class="line">    ASSERT(this == currentThread);//判断本进程是否为当前进程</span><br><span class="line">    </span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Yielding thread \&quot;%s\&quot;\n&quot;, getName());//设置debug信息</span><br><span class="line">    </span><br><span class="line">    nextThread = scheduler-&gt;FindNextToRun();//在就绪队列中找到下一个可运行进程</span><br><span class="line">    if (nextThread != NULL) &#123;//若下一个可运行进程不为空</span><br><span class="line">		scheduler-&gt;ReadyToRun(this);//设置本进程状态为READY</span><br><span class="line">		scheduler-&gt;Run(nextThread);//运行下一个进程</span><br><span class="line">    &#125;</span><br><span class="line">    (void) interrupt-&gt;SetLevel(oldLevel);//开中断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Scheduler-Run-Thread-nextThread"><a href="#Scheduler-Run-Thread-nextThread" class="headerlink" title="Scheduler::Run (Thread *nextThread)"></a>Scheduler::Run (Thread *nextThread)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Scheduler::Run (Thread *nextThread)</span><br><span class="line">&#123;</span><br><span class="line">    Thread *oldThread = currentThread;</span><br><span class="line">    </span><br><span class="line">    oldThread-&gt;CheckOverflow();		    // 检查旧进程是否有不可删除的栈溢出</span><br><span class="line">					    // had an undetected stack overflow</span><br><span class="line"></span><br><span class="line">    currentThread = nextThread;		    // 宏变量当前进程设置为即将运行的进程</span><br><span class="line">    currentThread-&gt;setStatus(RUNNING);      // 设置本进程状态为RUNNING</span><br><span class="line">    </span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Switching from thread \&quot;%s\&quot; to thread \&quot;%s\&quot;\n&quot;,</span><br><span class="line">	  oldThread-&gt;getName(), nextThread-&gt;getName());</span><br><span class="line">    </span><br><span class="line">    //阅读汇编代码</span><br><span class="line">    SWITCH(oldThread, nextThread);//交换两个进程的状态</span><br><span class="line">    //返回nextThread的执行</span><br><span class="line">    </span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Now in thread \&quot;%s\&quot;\n&quot;, currentThread-&gt;getName());</span><br><span class="line"></span><br><span class="line">    // 处理完成运行的旧线程</span><br><span class="line">    if (threadToBeDestroyed != NULL) &#123;</span><br><span class="line">        delete threadToBeDestroyed;</span><br><span class="line">		threadToBeDestroyed = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Thread-finish"><a href="#Thread-finish" class="headerlink" title="Thread::finish()"></a>Thread::finish()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Thread::Finish ()</span><br><span class="line">&#123;</span><br><span class="line">    (void) interrupt-&gt;SetLevel(IntOff);		</span><br><span class="line">    ASSERT(this == currentThread);</span><br><span class="line">    </span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Finishing thread \&quot;%s\&quot;\n&quot;, getName());</span><br><span class="line">    </span><br><span class="line">    threadToBeDestroyed = currentThread;</span><br><span class="line">    Sleep();					// invokes SWITCH</span><br><span class="line">    // not reached</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread::sleep()"></a>Thread::sleep()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Thread::Sleep ()</span><br><span class="line">&#123;</span><br><span class="line">    Thread *nextThread;</span><br><span class="line">    </span><br><span class="line">    ASSERT(this == currentThread);</span><br><span class="line">    ASSERT(interrupt-&gt;getLevel() == IntOff);</span><br><span class="line">    </span><br><span class="line">    DEBUG(&#x27;t&#x27;, &quot;Sleeping thread \&quot;%s\&quot;\n&quot;, getName());</span><br><span class="line"></span><br><span class="line">    status = BLOCKED;</span><br><span class="line">    while ((nextThread = scheduler-&gt;FindNextToRun()) == NULL)</span><br><span class="line">	interrupt-&gt;Idle();	// no one to run, wait for an interrupt</span><br><span class="line">        </span><br><span class="line">    scheduler-&gt;Run(nextThread); // returns when we&#x27;ve been signalled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当前进程设置状态为 BLOCKED</p>
</li>
<li><p>寻找下一个可执行进程并运行</p>
</li>
<li><p>若找不到可执行进程，等待一个中断</p>
</li>
</ul>
<p>Thread::Sleep()只是将当前线程的状态设置为 BLOCKED，然后调度下一 个线程执行；</p>
<p>（目前 Sleep()在信号量的 P、V 操作、Thread::Finish()调用）；</p>
<h3 id="Thread-FindNextToRun"><a href="#Thread-FindNextToRun" class="headerlink" title="Thread::FindNextToRun()"></a>Thread::FindNextToRun()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread *</span><br><span class="line">Scheduler::FindNextToRun ()</span><br><span class="line">&#123;</span><br><span class="line">    return (Thread *)readyList-&gt;Remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在就绪队列中返回队首的就绪线程，并将该线程在就绪队列中移除</p>
<h1 id="实验四-Nachos-的文件系统"><a href="#实验四-Nachos-的文件系统" class="headerlink" title="实验四 Nachos 的文件系统"></a>实验四 Nachos 的文件系统</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol>
<li>理解 Nachos 硬盘是如何创建的； </li>
<li>熟悉查看 Nachos 硬盘上的内容的方法； </li>
<li>理解硬盘初始化的过程（如何在硬盘上创建一个文件系统）； </li>
<li>了解 Nachos 文件系统提供了哪些命令，哪些命令已经实现，哪些需要你自 己实现； </li>
<li>理解已经实现的文件系统命令的实现原理； </li>
<li>理解硬盘空闲块的管理方法； </li>
<li>理解目录文件的结构与管理；</li>
<li>理解文件的结构与文件数据块的分配方法； </li>
<li>了解一个文件系统命令执行后，硬盘的布局； </li>
<li>分析目前 Nachos 不能对文件进行扩展的原因，考虑解决方案；</li>
</ol>
<h2 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h2><p>Nachos实现了两个版本的文件系统</p>
<ul>
<li>FILESYS_STUB：直接利用UNIX所提供的系统调用实现</li>
<li>FILESYS：通过Openfile类对DISK上的文件进行操作，尽管最终也是使用系统调用</li>
</ul>
<h3 id="硬盘初始化"><a href="#硬盘初始化" class="headerlink" title="硬盘初始化"></a>硬盘初始化</h3><p>（1）..&#x2F;lab5&#x2F;main.cc 调用了..&#x2F;threads&#x2F;system.cc 中的 Initialize()创建了硬盘 DISK。 分析..&#x2F;threads&#x2F;synchdisk.cc 及..&#x2F;machine&#x2F;disk.cc，理解 Nachos 创建硬盘的过程与方法；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Disk::Disk(char* name, VoidFunctionPtr callWhenDone, _int callArg)</span><br><span class="line">&#123;</span><br><span class="line">    int magicNum;</span><br><span class="line">    int tmp = 0;</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;d&#x27;, &quot;Initializing the disk, 0x%x 0x%x\n&quot;, callWhenDone, callArg);</span><br><span class="line">    handler = callWhenDone;</span><br><span class="line">    handlerArg = callArg;</span><br><span class="line">    lastSector = 0;</span><br><span class="line">    bufferInit = 0;</span><br><span class="line">    </span><br><span class="line">    fileno = OpenForReadWrite(name, FALSE);</span><br><span class="line">    if (fileno &gt;= 0) &#123;		 	// 文件存在，检查magicNum</span><br><span class="line">		Read(fileno, (char *) &amp;magicNum, MagicSize);//获取前四个字节 Sizeof(int)</span><br><span class="line">		ASSERT(magicNum == MagicNumber);</span><br><span class="line">    &#125; else &#123;				// 文件不存在，创建文件</span><br><span class="line">        fileno = OpenForWrite(name);</span><br><span class="line">		magicNum = MagicNumber;  </span><br><span class="line">		WriteFile(fileno, (char *) &amp;magicNum, MagicSize); // 写入magicNum</span><br><span class="line"></span><br><span class="line">	// need to write at end of file, so that reads will not return EOF</span><br><span class="line">        Lseek(fileno, DiskSize - sizeof(int), 0);	</span><br><span class="line">		WriteFile(fileno, (char *)&amp;tmp, sizeof(int));  </span><br><span class="line">    &#125;</span><br><span class="line">    active = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个文件用来当硬盘</p>
<ul>
<li>若文件存在，检查magicNum</li>
<li>若文件不存在，创建文件</li>
</ul>
<h3 id="硬盘大小"><a href="#硬盘大小" class="headerlink" title="硬盘大小"></a>硬盘大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define SectorSize 		128	// 每个扇区的字节数</span><br><span class="line">#define SectorsPerTrack 	32	// 每道的扇区数</span><br><span class="line">#define NumTracks 		32	// 硬盘的道数</span><br><span class="line">#define NumSectors 		(SectorsPerTrack * NumTracks)</span><br><span class="line"></span><br><span class="line">#define MagicNumber 	0x456789ab</span><br><span class="line">#define MagicSize 	sizeof(int) //4字节大小</span><br><span class="line"></span><br><span class="line">#define DiskSize 	(MagicSize + (NumSectors * SectorSize))</span><br></pre></td></tr></table></figure>

<p>总扇区数：32*32&#x3D;1024</p>
<p>硬盘大小：（4+32<em>32</em>128）B&#x2F;1024&#x3D;0x80KB</p>
<h3 id="Nachos的文件系统命令"><a href="#Nachos的文件系统命令" class="headerlink" title="Nachos的文件系统命令"></a>Nachos的文件系统命令</h3><p>（2）分析..&#x2F;lab5&#x2F;main.cc，了解 Nachos 文件系统提供了哪些命令，对每个命令进行测试，根据执行结果观察哪些命令已经实现（正确运行），哪些无法正确运行（尚未 完全实现，需要你自己完善）；</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-d f</td>
<td>可选参数[-d f]的作用是打印出所有与文件系统有关的调试信息。</td>
</tr>
<tr>
<td>nachos –cp UNIX_filename nachos_filename</td>
<td>将一个 Unix 文件系统中的文 件 UNIX_filename 复制到 Nachos 文件系统中，重新命名为 nachos_filename</td>
</tr>
<tr>
<td>nachos [-d f] –p nachos_filename</td>
<td>该命令输出 nachos 文件 nachos_filename 的内容，类似于 UNIX 中的 cat 命令</td>
</tr>
<tr>
<td>nachos [-d f] –r nachos_filename</td>
<td>删除 Nachos 文件 nachos_filename，类似于 UNIX 中的 rm 命令</td>
</tr>
<tr>
<td>nachos [-d f] -l</td>
<td>输出当前目录中的文件名，类似于 DOS 中的 dir，UNIX 中的 ls</td>
</tr>
<tr>
<td>nachos [-d f] -t</td>
<td>测试 Nachos 文件系统的性能（目前尚未实现）</td>
</tr>
<tr>
<td>nachos [-d f] -D</td>
<td>输出 Nachos 的文件系统在磁盘上的组织。打印出整个文件系统 的所有内容，包括位图文件（bitmap）、文件头（file header）、目录文件（directory） 和普通文件（file）</td>
</tr>
</tbody></table>
<h3 id="文件系统FileSystem的初始化"><a href="#文件系统FileSystem的初始化" class="headerlink" title="文件系统FileSystem的初始化"></a>文件系统FileSystem的初始化</h3><p>（3）分析..&#x2F;filesys&#x2F;filessys.cc，特别是构造函数 FileSystem::FileSystem(..)，理解 Nachos 硬盘”DISK”的创建及硬盘格式化（创建文件系统）的处理过程；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 通过宏定义确定位示图文件头和文件目录表文件头的扇区位置</span><br><span class="line">#define FreeMapSector 		0</span><br><span class="line">#define DirectorySector 	1</span><br><span class="line"></span><br><span class="line">FileSystem::FileSystem(bool format)</span><br><span class="line">&#123; </span><br><span class="line">    DEBUG(&#x27;f&#x27;, &quot;Initializing the file system.\n&quot;);</span><br><span class="line">    if (format) &#123;</span><br><span class="line">        BitMap *freeMap = new BitMap(NumSectors); //位示图</span><br><span class="line">        Directory *directory = new Directory(NumDirEntries); //文件目录表</span><br><span class="line">		FileHeader *mapHdr = new FileHeader; //位示图的文件头</span><br><span class="line">		FileHeader *dirHdr = new FileHeader; //文件目录表的文件头</span><br><span class="line"></span><br><span class="line">        DEBUG(&#x27;f&#x27;, &quot;Formatting the file system.\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 首先，标记0号和1号扇区已被使用</span><br><span class="line">		freeMap-&gt;Mark(FreeMapSector);	    </span><br><span class="line">		freeMap-&gt;Mark(DirectorySector);</span><br><span class="line"></span><br><span class="line">	// 然后，为位示图数据块和根目录表分配空间，确保有足够的空间</span><br><span class="line">		ASSERT(mapHdr-&gt;Allocate(freeMap, FreeMapFileSize));</span><br><span class="line">		ASSERT(dirHdr-&gt;Allocate(freeMap, DirectoryFileSize));</span><br><span class="line"></span><br><span class="line">    // 将位图和文件目录表的文件头刷新回磁盘</span><br><span class="line">    // 在打开文件前就需要做这一步，否则在打开文件时，磁盘是脏的</span><br><span class="line">        DEBUG(&#x27;f&#x27;, &quot;Writing headers back to disk.\n&quot;);</span><br><span class="line">		mapHdr-&gt;WriteBack(FreeMapSector);    </span><br><span class="line">		dirHdr-&gt;WriteBack(DirectorySector);</span><br><span class="line"></span><br><span class="line">    // 现在可以打开位示图和文件目录表</span><br><span class="line">    // 文件系统操作假设在Nachos运行时这两个文件是打开的</span><br><span class="line">        freeMapFile = new OpenFile(FreeMapSector); </span><br><span class="line">        directoryFile = new OpenFile(DirectorySector);</span><br><span class="line">     </span><br><span class="line">	// 当我们打开文件时，我们可以写每个文件的最初版本到硬盘上</span><br><span class="line">	// 此时文件目录表是空的，但位示图会被改变（由于扇区已经被分配给了文件头</span><br><span class="line">        DEBUG(&#x27;f&#x27;, &quot;Writing bitmap and directory back to disk.\n&quot;);</span><br><span class="line">		freeMap-&gt;WriteBack(freeMapFile);	 // 写回硬盘</span><br><span class="line">		directory-&gt;WriteBack(directoryFile);</span><br><span class="line"></span><br><span class="line">		if (DebugIsEnabled(&#x27;f&#x27;)) &#123;</span><br><span class="line">	    	freeMap-&gt;Print();</span><br><span class="line">	    	directory-&gt;Print();</span><br><span class="line"></span><br><span class="line">       		delete freeMap; </span><br><span class="line">			delete directory; </span><br><span class="line">			delete mapHdr; </span><br><span class="line">			delete dirHdr;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    // 如果不是在建立硬盘的话，我们只需要打开文件就好</span><br><span class="line">        freeMapFile = new OpenFile(FreeMapSector);</span><br><span class="line">        directoryFile = new OpenFile(DirectorySector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nachos文件系统布局"><a href="#Nachos文件系统布局" class="headerlink" title="Nachos文件系统布局"></a>Nachos文件系统布局</h3><p>（4）利用命令 hexdump –C DISK 查看硬盘格式化后硬盘的布局，理解格式化硬盘所完成的工作，以及文件系统管理涉及到的一些数据结构组织与使用，如文件头 （FCB）、目录表与目录项、空闲块管理位示图等；</p>
<p>​        结合输出结果，分析 FileSystem::FileSystem(..)初始化文件系统时涉及到的几个模 块 ， 如 ..&#x2F;filesys&#x2F;filehdr.h(filehdr.cc) ， directory.h(directory.cc) ， ..&#x2F;userprog&#x2F;bitmap.h （bitmap.cc），<strong>理解文件头（FCB）的结构与组织、硬盘空闲块管理使用的位示图文件、目录表文件及目录下的组织与结构</strong>，以及它们在硬盘上的位置；</p>
<table>
<thead>
<tr>
<th><strong>扇区号</strong></th>
<th><strong>起止字节</strong></th>
<th><strong>内容描述</strong></th>
<th><strong>内容</strong></th>
<th><strong>大小</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x0~0x3</td>
<td>磁盘标识（魔数）</td>
<td>0x456789ab</td>
<td>4字节</td>
</tr>
<tr>
<td>0</td>
<td>0x4~0x83</td>
<td>位示图文件头</td>
<td>Class FileHeader</td>
<td>128字节</td>
</tr>
<tr>
<td>1</td>
<td>0x84~0x103</td>
<td>目录表文件头</td>
<td>Class FileHeader</td>
<td>128字节</td>
</tr>
<tr>
<td>2</td>
<td>0x104~0x183</td>
<td>位示图文件数据块</td>
<td>Class BitMap</td>
<td>128字节</td>
</tr>
<tr>
<td>3</td>
<td>0x184~0x203</td>
<td>根目录表（目录文件）</td>
<td>Class Directory</td>
<td>128字节</td>
</tr>
<tr>
<td>4</td>
<td>0x204~0x283</td>
<td>根目录表（目录文件）</td>
<td>Class Directory</td>
<td>128字节</td>
</tr>
<tr>
<td>5</td>
<td>0x284~0x303</td>
<td>第一个文件的文件头</td>
<td>Class FileHeader</td>
<td>128字节</td>
</tr>
<tr>
<td>6</td>
<td>0x304~0x383</td>
<td>第一个文件的数据块</td>
<td></td>
<td>128字节</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>(文件需要的块数不定)</td>
<td>…….</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>第二个文件的文件头</td>
<td>Class FileHeader</td>
<td>128字节</td>
</tr>
<tr>
<td></td>
<td></td>
<td>第二个文件的数据块</td>
<td></td>
<td>128字节</td>
</tr>
<tr>
<td></td>
<td></td>
<td>……</td>
<td>……</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>第三个文件的文件头</td>
<td>Class FileHeader</td>
<td>128字节</td>
</tr>
<tr>
<td></td>
<td></td>
<td>第三个文件的数据块</td>
<td></td>
<td>128字节</td>
</tr>
<tr>
<td></td>
<td></td>
<td>…..</td>
<td>……</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>以此类推</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在系统初始化后查看硬盘内容</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314004009009.png" alt="image-20220314004009009"></p>
<p>此时对应查看</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314005505549.png" alt="image-20220314005505549"></p>
<p>与DISK文件内容一致</p>
<p>总结其布局</p>
<p>文件系统 FileSystem</p>
<ul>
<li>位示图 OpenFile* freeMapFile;</li>
<li>根目录 OpenFile* directoryFile;</li>
<li>打开文件 OpenFile 结构<ul>
<li>FileHeader *hdr;            &#x2F;&#x2F; 文件头</li>
<li>int seekPosition;            &#x2F;&#x2F; 文件内的当前位置</li>
<li>int hdrSector;                &#x2F;&#x2F; 文件头所在扇区<ul>
<li>FileHeader 文件头结构<ul>
<li>int numBytes;            &#x2F;&#x2F; 文件大小，单位：字节</li>
<li>int numSectors;            &#x2F;&#x2F; 文件的逻辑块数</li>
<li>int dataSectors[NumDirect];        &#x2F;&#x2F; 数据块所在扇区列表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="三元组信息"><a href="#三元组信息" class="headerlink" title="三元组信息"></a>三元组信息</h4><ul>
<li><p>文件头</p>
<ul>
<li>文件大小 int</li>
<li>占用扇区数 int</li>
<li>数据块所在扇区列表  int*30</li>
</ul>
</li>
<li><p>位示图</p>
</li>
<li><p>文件目录项</p>
<ul>
<li>inUse bool （但为了对齐，编译器分配了4字节</li>
<li>扇区号 int</li>
<li>名字 9+1&#x3D;10 字节</li>
<li>为了对齐 共20字节</li>
</ul>
</li>
</ul>
<h3 id="更多的验证"><a href="#更多的验证" class="headerlink" title="更多的验证"></a>更多的验证</h3><p>（5）利用命令 nachos –cp ..&#x2F;test&#x2F;small samll 复制文件..&#x2F;test&#x2F;small 到硬盘 DISK 中； </p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314010620035.png" alt="image-20220314010620035"></p>
<p>可以看到3号扇区增加一个文件目录项small</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>inUse</th>
<th>文件头（索引节点）所在的扇区号</th>
</tr>
</thead>
<tbody><tr>
<td>small</td>
<td>1</td>
<td>5</td>
</tr>
</tbody></table>
<p>5号扇区内保存small文件头内容</p>
<p>5号扇区文件头</p>
<ul>
<li>文件大小：54字节</li>
<li>分配扇区个数：1</li>
<li>扇区位置：6号扇区</li>
</ul>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314010126127.png" alt="image-20220314010126127"></p>
<p>验证可得相同内容</p>
<p>（6）利用命令 hexdump –C DISK 查看硬盘格式化后硬盘的布局，理解创建一个 文件后相关的结构在硬盘上的存储布局； </p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314011027327.png" alt="image-20220314011027327"></p>
<p>文件目录表、位示图全部初始化为初始信息。</p>
<p>（7）复制更多的文件到 DISK 中，然后删除一个文件，利用 hexdump –C DISK 查看文件的布局，分析文件系统的管理策略。</p>
<p>复制small、big文件到DISK中，删除small文件，查看DISK内容</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314010728426.png" alt="image-20220314010728426"></p>
<p>删除文件samll后</p>
<p>更改</p>
<ul>
<li>位示图中扇区变为空闲</li>
<li>目录项变为空闲  isUse置0</li>
</ul>
<p>未更改</p>
<ul>
<li>文件名、头文件所占扇区号均未清除</li>
<li>文件头信息、文件内容未清除</li>
</ul>
<p>分析文件管理策略：</p>
<ul>
<li>删除文件时，并非真的物理性初始化文件信息，只需修改位示图和文件目录表</li>
<li>文件所在扇区标记为空闲、文件目录表中被删除文件信息无效化便可视为文件已删除</li>
</ul>
<h2 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h2><h3 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h3><h4 id="od命令用于输出文件内容。"><a href="#od命令用于输出文件内容。" class="headerlink" title="od命令用于输出文件内容。"></a>od命令用于输出文件内容。</h4><p>od指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来。</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>格式规范</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>-t a</td>
<td>输出命名字符。</td>
</tr>
<tr>
<td>-b</td>
<td>-t o1</td>
<td>输出八进制字节。</td>
</tr>
<tr>
<td>-c</td>
<td>-t c</td>
<td>输出可打印的单字节字符，C反斜杠转义或3位八进制序列。</td>
</tr>
<tr>
<td>-d</td>
<td>-t u2</td>
<td>输出无符号十进制数（双字节）。</td>
</tr>
<tr>
<td>-f</td>
<td>-t fF</td>
<td>输出浮点型。</td>
</tr>
<tr>
<td>-i</td>
<td>-t dI（大写I）</td>
<td>输出十进制整数。</td>
</tr>
<tr>
<td>-l</td>
<td>-t dL</td>
<td>输出十进制长整型。</td>
</tr>
<tr>
<td>-o</td>
<td>-t o2</td>
<td>输出八进制字节（双字节）。</td>
</tr>
<tr>
<td>-s</td>
<td>-t d2</td>
<td>输出十进制数（双字节）。</td>
</tr>
<tr>
<td>-x</td>
<td>-t x2</td>
<td>输出十六进制数（双字节）。</td>
</tr>
</tbody></table>
<h4 id="hexdump命令主要用来查看“二进制”文件的十六进制编码"><a href="#hexdump命令主要用来查看“二进制”文件的十六进制编码" class="headerlink" title="hexdump命令主要用来查看“二进制”文件的十六进制编码"></a>hexdump命令<strong>主要用来查看“二进制”文件的十六进制编码</strong></h4><ul>
<li><p><strong>语法</strong></p>
<p><strong>hexdump [选项] [文件]…</strong></p>
</li>
<li><p><strong>选项</strong></p>
<ul>
<li>-<strong>n length</strong>：格式化输出文件的前length个字节</li>
<li>-<strong>C</strong>：输出规范的十六进制和ASCII码</li>
<li><strong>-b</strong>：单字节八进制显示</li>
<li><strong>-c</strong>：单字节字符显示</li>
<li><strong>-d</strong>：双字节十进制显示</li>
<li><strong>-o</strong>：双字节八进制显示</li>
<li><strong>-x</strong>：双字节十六进制显示</li>
<li><strong>-s</strong>：从偏移量开始输出</li>
</ul>
</li>
</ul>
<h3 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class BitMap &#123;</span><br><span class="line">  private:</span><br><span class="line">    int numBits;			// 扇区数 固定不变 初始化来的</span><br><span class="line">    int numWords;			// 位示图存储的字节数</span><br><span class="line">					// 不是字的倍数可以舍入</span><br><span class="line">    unsigned int *map;			// bit storage</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>标记whitch扇区被使用，左移赋值</p>
<p>BitsInWord&#x3D;32</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">BitMap::Mark(int which) </span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(which &gt;= 0 &amp;&amp; which &lt; numBits);</span><br><span class="line">    map[which / BitsInWord] |= 1 &lt;&lt; (which % BitsInWord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他函数的实现规则类似</p>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>文件目录的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Directory &#123;</span><br><span class="line">  private:</span><br><span class="line">    int tableSize;			// 目录项的数量</span><br><span class="line">    DirectoryEntry *table;		// 目录项数组</span><br><span class="line"></span><br><span class="line">    int FindIndex(char *name);		// 根据文件名寻找下标</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p>目录项的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class DirectoryEntry &#123;</span><br><span class="line">  public:</span><br><span class="line">    bool inUse;				// 该目录项是否已经分配 1字节  编译器出于对其原则分配4字节</span><br><span class="line">    int sector;				// 文件头所在的扇区号 4字节</span><br><span class="line">					//   文件头未FCB或i-node </span><br><span class="line">    char name[FileNameMaxLen + 1];	// 文件名 最长为9个字节</span><br><span class="line">					// +1 末尾 &#x27;\0&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>目录文件<ul>
<li>文件头</li>
<li>目录表</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>文件名</th>
<th>inUse</th>
<th>文件头（索引节点）所在的扇区号</th>
</tr>
</thead>
<tbody><tr>
<td>main.cc</td>
<td>1</td>
<td>4</td>
</tr>
</tbody></table>
<ul>
<li>文件<ul>
<li>文件头</li>
<li>数据块</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Sectors containing the file headers for the bitmap of free sectors,</span><br><span class="line">// and the directory of files.  These file headers are placed in well-known </span><br><span class="line">// sectors, so that they can be located on boot-up.</span><br><span class="line">#define FreeMapSector 		0</span><br><span class="line">#define DirectorySector 	1</span><br><span class="line"></span><br><span class="line">// Initial file sizes for the bitmap and directory; until the file system</span><br><span class="line">// supports extensible files, the directory size sets the maximum number </span><br><span class="line">// of files that can be loaded onto the disk.</span><br><span class="line">#define FreeMapFileSize 	(NumSectors / BitsInByte)</span><br><span class="line">#define NumDirEntries 		10</span><br><span class="line">#define DirectoryFileSize 	(sizeof(DirectoryEntry) * NumDirEntries)</span><br></pre></td></tr></table></figure>







<p>文件头相当于FCB</p>
<h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class FileHeader &#123;</span><br><span class="line">  public:</span><br><span class="line">    bool Allocate(BitMap *bitMap, int fileSize);// 初始化文件头</span><br><span class="line">						//  包括在硬盘上分配数据块</span><br><span class="line">    void Deallocate(BitMap *bitMap);  		// 回收数据块</span><br><span class="line"></span><br><span class="line">    void FetchFrom(int sectorNumber); 	// 在硬盘上初始化文件头</span><br><span class="line">    void WriteBack(int sectorNumber); 	// 向硬盘写回文件头的修改内容</span><br><span class="line"></span><br><span class="line">    int ByteToSector(int offset);	// Convert a byte offset into the file</span><br><span class="line">					// to the disk sector containing</span><br><span class="line">					// the byte</span><br><span class="line">					//将文件中的字节偏移量转换为包含该字节的扇区编号</span><br><span class="line"></span><br><span class="line">    int FileLength();			// 以字节为单位返回文件长度</span><br><span class="line"></span><br><span class="line">    void Print();			// 输出文件内容</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    int numBytes;			// 文件大小，单位：字节</span><br><span class="line">    int numSectors;			// 文件的逻辑块数</span><br><span class="line">    int dataSectors[NumDirect];		// 直接块数组，依次存储文件的每个数据块所对应的扇区号</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define NumDirect 	((SectorSize - 2 * sizeof(int)) / sizeof(int)) </span><br><span class="line">#define MaxFileSize 	(NumDirect * SectorSize)</span><br></pre></td></tr></table></figure>

<p>每个文件最多包含30个扇区，最大为3780字节（3KB&#x3D;30*128B）</p>
<p>确定方式</p>
<p>目标：使文件头大小刚好为一个数据块大小</p>
<p>文件头包含&#x3D;numBytes(int) + numSectores(int) + dataSectors[]</p>
<p>使得dataSectors数组大小填满剩下的区域</p>
<p>size&#x3D;(128-4*2)&#x2F;4&#x3D;30</p>
<h3 id="硬盘空闲块的管理"><a href="#硬盘空闲块的管理" class="headerlink" title="硬盘空闲块的管理"></a>硬盘空闲块的管理</h3><p>位示图（BitMap）</p>
<p>位示图也是一个文件，由文件头+数据块组成，文件头保存在第0号扇区中</p>
<p>1024个扇区对应   1024&#x2F;8&#x3D;128字节</p>
<p>目录文件（根目录）的文件头存储在第1号扇区</p>
<p>文件的大小在创建后无法改变</p>
<h1 id="实验五-扩展Nachos的文件系统"><a href="#实验五-扩展Nachos的文件系统" class="headerlink" title="实验五 扩展Nachos的文件系统"></a>实验五 扩展Nachos的文件系统</h1><h2 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h2><p>理解文件系统中文件操作的实现方法，如文件打开、读、写、扩展、定位、关闭等； </p>
<p>理解如何管理硬盘空闲块； </p>
<p>创建文件时，如何为文件分配目录项及文件头（FCB）；</p>
<p>理解文件扩展时，如何为要扩展的数据查找并分配空闲块； </p>
<p>理解文件扩展后，文件大小是如何记录与保存的； </p>
<p>文件被删除后，如何回收为其分配的资源，如文件头、目录项、硬盘块等； </p>
<p>拓展：有精力的同学可进一步尝试多级目录（目录树）的设计与实现方法。根据上述工作，总结操作系统（如 Nachos）读写文件，以及对文件追加数据的过程与步骤（如操作系统需要操作哪些文件系统的控制信息，如何操作的等）。</p>
<h2 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h2><p>让你修改 Nachos 的文件系统，以满足： </p>
<ol>
<li><p>文件创建时，其大小可初始化为 0； </p>
</li>
<li><p>当一个文件写入更多的数据时，其大小可随之增大； </p>
</li>
<li><p>要求能够在从一个文件的任何位置开始写入数据，即能够正确处理命令行参数 </p>
<p>-ap, -hap,及-nap；</p>
</li>
</ol>
<p>例子</p>
<p>如果一个文件的大小为 100 字节，当从其偏移量 50（第一个字节的偏移量 是 0）开始写入 100 个字节后，该文件的大小应该为 150 字节</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220314194850745.png" alt="image-20220314194850745"></p>
<h2 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>确定需要修改的文件和函数</p>
<p>首先阅读源码可知，</p>
<ul>
<li><p>OpenFile::WriteAt(char *from, int numBytes, int position)函数实现了从任意位置插入内容，但是并不可以扩展文件大小，修改其内部代码，增加扩展文件大小的函数调用</p>
</li>
<li><p>Openfile::WriteBack()  实现将新的文件头写回硬盘</p>
<ul>
<li>FileHeader::void WriteBack(int sectorNumber);FileHeader类本身拥有将自身写回硬盘sectorNumber扇区的函数，但是我们缺少原文件头所在扇区号的参数</li>
<li>Openfile增加私有变量hdrSector用于记录文件头所在扇区，并在初始化时更新</li>
</ul>
</li>
<li><p>新函数 Openfile::ExtendSpace(int NumByte) 增加NumByte的空间</p>
<ul>
<li>实现方式通过调用FileHeader *hdr;的内部函数实现</li>
<li>FileHeader::ExtendSpace(BitMap *bitMap,int NumByte)  增加NumByte的字节，并修改位示图</li>
</ul>
</li>
<li><p>OpenFile类的新函数</p>
<ul>
<li>BitMap* getBitMap();   获取位示图</li>
<li>void setBitMap(BitMap* freeMap);  写回位示图</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>修改OpenFile，增加初始化私有成员hdrSector</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OpenFile::OpenFile(int sector)</span><br><span class="line">&#123; </span><br><span class="line">    hdr = new FileHeader;</span><br><span class="line">    hdr-&gt;FetchFrom(sector);</span><br><span class="line">    seekPosition = 0;</span><br><span class="line">    hdrSector = sector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得扇区号后，增加函数WriteBack，将头文件写回硬盘</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int OpenFile::WriteBack()&#123;</span><br><span class="line">    hdr-&gt;WriteBack(hdrSector);</span><br><span class="line">    return hdrSector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展文件大小</p>
<p>函数实现模仿<code>bool Allocate(BitMap *bitMap, int fileSize);</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int FileHeader::ExtendSpace(BitMap *bitMap,int NewByteNum)&#123;</span><br><span class="line">    int NewSectorNum; //新扇区数量</span><br><span class="line">    int OriginalRemainingSpace = SectorSize*numSectors - numBytes; //原剩余空间</span><br><span class="line">    int ExtendByteNum = NewByteNum - OriginalRemainingSpace; </span><br><span class="line">    								//扩展空间= 新增字节数 - 原剩余空间</span><br><span class="line">    NewSectorNum = divRoundUp(ExtendByteNum,SectorSize); //新增扇区数</span><br><span class="line"></span><br><span class="line">	//若新增扇区数小于等于0，简单增加文件长度后直接返回</span><br><span class="line">    if (NewSectorNum &lt;= 0)&#123; </span><br><span class="line">        numBytes += NewByteNum;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 硬盘剩余扇区数小于新增扇区数，扩展失败，返回-1</span><br><span class="line">    if(bitMap-&gt;NumClear()&lt;NewSectorNum)&#123; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 超过可分配的最大扇区数量，扩展失败</span><br><span class="line">	if((NewSectorNum+numSectors)&gt;30)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//最初匹配，寻找第一个空闲扇区，放入文件头的扇区分配数组</span><br><span class="line">    for(int i = numSectors;i &lt; numSectors+NewSectorNum ; i++)&#123;</span><br><span class="line">        dataSectors[i] = bitMap-&gt;Find();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //更新文件头信息</span><br><span class="line">    numSectors += NewSectorNum;</span><br><span class="line">    numBytes += NewByteNum;</span><br><span class="line"></span><br><span class="line">    return NewSectorNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现OpenFile::ExtenByte(int)函数，这个函数主要是帮助FileHead::ExtendSpace()函数准备位示图并将更新后的位示图写回DISK</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">OpenFile::ExtendSpace(int NumByte)&#123;</span><br><span class="line">    </span><br><span class="line">    BitMap* bitMap = fileSystem-&gt;getBitMap();</span><br><span class="line"></span><br><span class="line">    int ExtendSectorNum = hdr-&gt;ExtendSpace(bitMap,NumByte);</span><br><span class="line">    </span><br><span class="line">    fileSystem-&gt;setBitMap(bitMap);</span><br><span class="line">    return ExtendSectorNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>更新WriteAt函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">OpenFile::WriteAt(char *from, int numBytes, int position)</span><br><span class="line">&#123;</span><br><span class="line">    int fileLength = hdr-&gt;FileLength();</span><br><span class="line">    int i, firstSector, lastSector, numSectors;</span><br><span class="line">    bool firstAligned, lastAligned;</span><br><span class="line">    char *buf;</span><br><span class="line"></span><br><span class="line">//以下修改的内容</span><br><span class="line">    if (numBytes &lt;= 0)</span><br><span class="line">	    return 0;				// 判断写入字节数</span><br><span class="line">    if ((position + numBytes) &gt; fileLength)&#123;</span><br><span class="line">        //判断写入后的位置是否大于文件长度</span><br><span class="line">        int incrementBytes = (position + numBytes) - fileLength;</span><br><span class="line">        int Extend = ExtendSpace(incrementBytes);</span><br><span class="line">        //扩展文件长度</span><br><span class="line">    &#125;</span><br><span class="line">//以上为修改内容</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;f&#x27;, &quot;Writing %d bytes at %d, from file of length %d.\n&quot;, 	</span><br><span class="line">			numBytes, position, fileLength);</span><br><span class="line"></span><br><span class="line">    firstSector = divRoundDown(position, SectorSize);</span><br><span class="line">    lastSector = divRoundDown(position + numBytes - 1, SectorSize);</span><br><span class="line">    numSectors = 1 + lastSector - firstSector;</span><br><span class="line"></span><br><span class="line">    buf = new char[numSectors * SectorSize];</span><br><span class="line"></span><br><span class="line">    firstAligned = (bool)(position == (firstSector * SectorSize));</span><br><span class="line">    lastAligned = (bool)((position + numBytes) == ((lastSector + 1) * SectorSize));</span><br><span class="line"></span><br><span class="line">// read in first and last sector, if they are to be partially modified</span><br><span class="line">    if (!firstAligned)</span><br><span class="line">        ReadAt(buf, SectorSize, firstSector * SectorSize);	</span><br><span class="line">    if (!lastAligned &amp;&amp; ((firstSector != lastSector) || firstAligned))</span><br><span class="line">        ReadAt(&amp;buf[(lastSector - firstSector) * SectorSize], </span><br><span class="line">				SectorSize, lastSector * SectorSize);	</span><br><span class="line"></span><br><span class="line">// copy in the bytes we want to change </span><br><span class="line">    bcopy(from, &amp;buf[position - (firstSector * SectorSize)], numBytes);</span><br><span class="line"></span><br><span class="line">// write modified sectors back    </span><br><span class="line">    for (i = firstSector; i &lt;= lastSector; i++)	</span><br><span class="line">        synchDisk-&gt;WriteSector(hdr-&gt;ByteToSector(i * SectorSize), </span><br><span class="line">					&amp;buf[(i - firstSector) * SectorSize]);</span><br><span class="line">    delete [] buf;</span><br><span class="line"></span><br><span class="line">    //printf(&quot;NumByte: %d\n&quot;,numBytes);</span><br><span class="line">    return numBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/image-20220315235407884.png" alt="image-20220315235407884"></p>
<p>可以看到big的文件内容被添加在了medium后面</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>&#x3D;&#x3D;目前 Nachos 文件系统仅仅实现了单级目录结构，只有一个根目录。可以尝试采用目录树对文件进行管理。&#x3D;&#x3D;</p>
<h2 id="备注-2"><a href="#备注-2" class="headerlink" title="备注"></a>备注</h2><p>fseek()<br>函数名: fseek<br>功 能: 重定位流上的文件指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fseek(FILE *stream, long offset, int fromwhere);</span><br></pre></td></tr></table></figure>

<p>描 述: 函数设置文件指针stream的位置。</p>
<ul>
<li><p>如果执行成功，stream将指向以fromwhere为基准，偏移offset个字节的位置。</p>
</li>
<li><p>如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置。</p>
</li>
<li><p>返回值: 成功，返回0，否则返回其他值。</p>
</li>
</ul>
<p>第一个参数stream为文件指针<br>第二个参数offset为偏移量，整数表示正向偏移，负数表示负向偏移<br>第三个参数origin设定从文件的哪里开始偏移,可能取值为：SEEK_CUR、 SEEK_END 或 SEEK_SET<br>SEEK_SET： 文件开头     0<br>SEEK_CUR： 当前位置   1<br>SEEK_END： 文件结尾   2<br>其中SEEK_SET,SEEK_CUR和SEEK_END和依次为0，1和2.</p>
<p>ftell()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long ftell(FILE *fp);</span><br></pre></td></tr></table></figure>

<p>函数功能：返回当前文件指针的位置。这个位置是指当前文件指针相对于文件开头的位移量</p>
<p>返回值：返回文件指针的位置，若出错则返回-1L</p>
<p>fread()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t  fread( void  *buffer, size_t  size, size_t  count, FILE  *stream  ) </span><br></pre></td></tr></table></figure>

<p>buffer  读取的数据存放的内存的指针，可以是数组，也可以是新开辟的空间，buffer就是一个索引</p>
<p>size    每次读取的字节数  </p>
<p>count   读取次数  </p>
<p>strean  要读取的文件的指针  </p>
<p>返回值为读取元素个数</p>
<p>bcopy()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern void bcopy(const void *src, void *dest, int n);</span><br></pre></td></tr></table></figure>

<p> 用法：#include &lt;string.h&gt;</p>
<p> 功能：将字符串src的前n个字节复制到dest中</p>
<p> 说明：bcopy不检查字符串中的空字节NULL，函数没有返回值。</p>
<p>类作用总结</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class OpenFile &#123;</span><br><span class="line">  public:</span><br><span class="line">    OpenFile(int sector);		// 根据扇区号打开文件 文件头</span><br><span class="line">    ~OpenFile();			// 关闭文件</span><br><span class="line"></span><br><span class="line">    void Seek(int position); 		// 文件内指针重定位</span><br><span class="line"></span><br><span class="line">    int Read(char *into, int numBytes); // 隐含位置开始读</span><br><span class="line">    int Write(char *from, int numBytes);// 隐含位置开始写</span><br><span class="line"></span><br><span class="line">    int ReadAt(char *into, int numBytes, int position);</span><br><span class="line">    					// 传递位置开始读</span><br><span class="line">    int WriteAt(char *from, int numBytes, int position);</span><br><span class="line"></span><br><span class="line">    int Length(); 			// 返回文件长度</span><br><span class="line">    </span><br><span class="line">  private:</span><br><span class="line">    FileHeader *hdr;			// Header for this file </span><br><span class="line">    int seekPosition;			// Current position within the file</span><br><span class="line">    int hdrSector;              // 文件头所在扇区</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class FileHeader &#123;</span><br><span class="line">  public:</span><br><span class="line">    bool Allocate(BitMap *bitMap, int fileSize);// 初始化文件头，在位示图中分配空间</span><br><span class="line">    void Deallocate(BitMap *bitMap);  		// 删除文件</span><br><span class="line"></span><br><span class="line">    void FetchFrom(int sectorNumber); 	// 根据扇区号初始化文件头</span><br><span class="line">    void WriteBack(int sectorNumber); 	// 写回修改后的文件头</span><br><span class="line"></span><br><span class="line">    int ByteToSector(int offset);	// 将字节偏移量转化为扇区号</span><br><span class="line"></span><br><span class="line">    int FileLength();			// 文件的字节长度</span><br><span class="line"></span><br><span class="line">    void Print();			// 打印文件内容</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    int numBytes;			// 字节数</span><br><span class="line">    int numSectors;			// 扇区数</span><br><span class="line">    int dataSectors[NumDirect];		// 扇区数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class FileSystem &#123;</span><br><span class="line">  public:</span><br><span class="line">    FileSystem(bool format);		// Initialize the file system.</span><br><span class="line">					// Must be called *after* &quot;synchDisk&quot; </span><br><span class="line">					// has been initialized.</span><br><span class="line">    					// If &quot;format&quot;, there is nothing on</span><br><span class="line">					// the disk, so initialize the directory</span><br><span class="line">    					// and the bitmap of free blocks.</span><br><span class="line"></span><br><span class="line">    bool Create(char *name, int initialSize);  	</span><br><span class="line">					// Create a file (UNIX creat)</span><br><span class="line"></span><br><span class="line">    OpenFile* Open(char *name); 	// 打开一个文件</span><br><span class="line"></span><br><span class="line">    bool Remove(char *name);  		// 删除一个文件</span><br><span class="line"></span><br><span class="line">    void List();			// 列出文件系统中的所有文件</span><br><span class="line">    void Print();			// 打印出所有文件及其内容</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">   OpenFile* freeMapFile;		// 位示图</span><br><span class="line">   OpenFile* directoryFile;		// 根部目录文件表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class BitMap &#123;</span><br><span class="line">  public:</span><br><span class="line">    BitMap(int nitems);		// 初始化位示图，参数：扇区数</span><br><span class="line">    ~BitMap();			// De-allocate bitmap</span><br><span class="line">    </span><br><span class="line">    void Mark(int which);   	// 标记which扇区</span><br><span class="line">    void Clear(int which);  	// 清楚whitch扇区</span><br><span class="line">    bool Test(int which);   	// witch扇区是否使用</span><br><span class="line">    int Find();            	// 寻找并分配第一个空闲扇区 失败返回-1</span><br><span class="line">    int NumClear();		// 返回未使用扇区数</span><br><span class="line"></span><br><span class="line">    void Print();		// 打印位示图信息</span><br><span class="line">    </span><br><span class="line">    // These aren&#x27;t needed until FILESYS, when we will need to read and </span><br><span class="line">    // write the bitmap to a file</span><br><span class="line">    void FetchFrom(OpenFile *file); 	// fetch contents from disk </span><br><span class="line">    void WriteBack(OpenFile *file); 	// write contents to disk</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    int numBits;			// number of bits in the bitmap</span><br><span class="line">    int numWords;			// number of words of bitmap storage</span><br><span class="line">					// (rounded up if numBits is not a</span><br><span class="line">					//  multiple of the number of bits in</span><br><span class="line">					//  a word)</span><br><span class="line">    unsigned int *map;			// bit storage</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="实验六-Nachos用户程序与系统调用"><a href="#实验六-Nachos用户程序与系统调用" class="headerlink" title="实验六 Nachos用户程序与系统调用"></a>实验六 Nachos用户程序与系统调用</h1><h2 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h2><p>为后续实验中实现系统调用 Exec()与 Exit()奠定基础 </p>
<p>理解 Nachos 可执行文件的格式与结构； </p>
<p>掌握 Nachos 应用程序的编程语法，了解用户进程是如何通过系统调用与操作系统内核进行交互的； 掌握如何利用交叉编译生成 Nachos 的可执行程序； </p>
<p>理解系统如何为应用程序创建进程，并启动进程； </p>
<p>理解如何将用户线程映射到核心线程，核心线程执行用户程序的原理与方法； </p>
<p>理解当前进程的页表是如何与 CPU 使用的页表进行关联的；</p>
<h3 id="任务-3"><a href="#任务-3" class="headerlink" title="任务"></a>任务</h3><p>该实验将体验 Nachos 的用户程序、应用进程进程及 Nachos 系统调用的相关概念；</p>
<p>（1）阅读..&#x2F;bin&#x2F;noff.h，分析 Nachos 可执行程序.noff 文件的格式组成； </p>
<p>（2）阅读..&#x2F;test 目录下的几个 Nachos 应用程序，理解 Nachos 应用程序的编程语法，了解用户进程是如何通过系统调用与操作系统内核进行交互的； </p>
<p>（3）阅读..&#x2F;test&#x2F;Makefile，掌握如何利用交叉编译生成 Nachos 的可执行程序； </p>
<p>（4）阅读..&#x2F;threads&#x2F;main.cc，..&#x2F;userprog&#x2F; progtest.cc，根据对命令行参数-x 的处理 过程，理解系统如何为应用程序创建进程，并启动进程的； </p>
<p>（5）阅读..&#x2F;userprog&#x2F; progtest.cc，..&#x2F;threads&#x2F;scheduler.cc（Run()），理解如何将用户线程映射到核心线程，以及核心线程执行用户程序的原理与方法；</p>
<p>（6）阅读..&#x2F;userprog&#x2F; progtest.cc，..&#x2F;machine&#x2F;translate.cc，理解当前进程的页表是如何与CPU使用的页表进行关联的；</p>
<h2 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>Nachos 实现的文件系统实现了两个版本，</p>
<ul>
<li>FILESYS_STUB：直接利用 UNIX 所提供的系统调用实现，操作的不是硬盘 DISK 上的文件</li>
<li>FILESYS：FILESYS 实现的文件系统是通过 OpenFile 类对 DISK 上的文件进行操作（尽管最终也是使用 UNIX 的系统调用实现）</li>
</ul>
<p>考察..&#x2F;userprog&#x2F;makefile 与 makefile.local 的内容可以看出，实验 6、7、8 默认使用的是 FILESYS_STUB 定义的相关实现，即不是对 DISK 上的文件进行操作，而是直接对 UNIX 文件进行操作；</p>
<h3 id="noff文件格式"><a href="#noff文件格式" class="headerlink" title=".noff文件格式"></a>.noff文件格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define NOFFMAGIC	0xbadfad 	/* 表示Nachos的魔数</span><br><span class="line">					 * object code file </span><br><span class="line">					 */</span><br><span class="line"></span><br><span class="line">typedef struct segment &#123;</span><br><span class="line">  int virtualAddr;		/* 虚拟空间的段地址 */</span><br><span class="line">  int inFileAddr;		/* 本文件的段地址 */</span><br><span class="line">  int size;			/* 段长度 */</span><br><span class="line">&#125; Segment;</span><br><span class="line"></span><br><span class="line">typedef struct noffHeader &#123;</span><br><span class="line">   int noffMagic;		/* 应为NOFFMAGIC */</span><br><span class="line">   Segment code;		/* 可执行段代码 */ </span><br><span class="line">   Segment initData;		/* 初始化过的数据段 */</span><br><span class="line">   Segment uninitData;		/* 未初始化过的数据段 --</span><br><span class="line">				 * should be zero&#x27;ed before use </span><br><span class="line">				 */</span><br><span class="line">&#125; NoffHeader;</span><br></pre></td></tr></table></figure>

<p>分析：Nachos 的应用程序是作者自己定义的一种文件类型，文件头部分结构相对简单，编程方便。</p>
<p>Nachos文件主要由3部分构成</p>
<ul>
<li>可执行代码段</li>
<li>初始化过的数据段：一般为初始化的全局变量等</li>
<li>未初始化的数据段：一般指程序运行时才会分配的动态内存、静态变量、未初始化的全局变量</li>
</ul>
<p>每个段有自己的信息</p>
<ul>
<li>文件中的位置</li>
<li>大小</li>
<li>程序入口地址</li>
</ul>
<h3 id="将noff文件装入内存"><a href="#将noff文件装入内存" class="headerlink" title="将noff文件装入内存"></a>将noff文件装入内存</h3><p>系统要运行一个应用程序，需要</p>
<ul>
<li>为该程序创建一个用户进程</li>
<li>为程序分配内存空间，将用户程序（代码段与数据段，数据段包括初始化的全局变量与未初始化的全局变量，以及静态变量）装入所分配的内存空间</li>
<li>创建相应的页表，建立虚页与实页（帧）的映射关系；（参见 AddressSpace:: AddressSpace()）；</li>
</ul>
<p>通过noff.h的各种信息，我们可以得知读取noff文件的规则，并定义好相关的数据结构</p>
<p>Address::Address()初始化将noff文件读入内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">AddrSpace::AddrSpace(OpenFile *executable)</span><br><span class="line">&#123;</span><br><span class="line">    NoffHeader noffH;</span><br><span class="line">    unsigned int i, size;</span><br><span class="line"></span><br><span class="line">// 检查魔数是否正确</span><br><span class="line">    executable-&gt;ReadAt((char *)&amp;noffH, sizeof(noffH), 0);</span><br><span class="line">    if ((noffH.noffMagic != NOFFMAGIC) &amp;&amp; </span><br><span class="line">		(WordToHost(noffH.noffMagic) == NOFFMAGIC))</span><br><span class="line">    	SwapHeader(&amp;noffH);</span><br><span class="line">    ASSERT(noffH.noffMagic == NOFFMAGIC);</span><br><span class="line"></span><br><span class="line">// 计算地址空间大小</span><br><span class="line">    size = noffH.code.size + noffH.initData.size + noffH.uninitData.size </span><br><span class="line">			+ UserStackSize;	// we need to increase the size   增加栈空间</span><br><span class="line">						// to leave room for the stack</span><br><span class="line">    numPages = divRoundUp(size, PageSize);</span><br><span class="line">    size = numPages * PageSize;</span><br><span class="line"></span><br><span class="line">    ASSERT(numPages &lt;= NumPhysPages);		// 检查所需页数不会超过实际内存页数 64页</span><br><span class="line"></span><br><span class="line">    DEBUG(&#x27;a&#x27;, &quot;Initializing address space, num pages %d, size %d\n&quot;, </span><br><span class="line">					numPages, size);</span><br><span class="line"></span><br><span class="line">// 设置页表</span><br><span class="line">    pageTable = new TranslationEntry[numPages];</span><br><span class="line">    for (i = 0; i &lt; numPages; i++) &#123;</span><br><span class="line">	    pageTable[i].virtualPage = i;	// 现在虚拟页号等于物理页号</span><br><span class="line">	    pageTable[i].physicalPage = i;</span><br><span class="line">	    pageTable[i].valid = TRUE;</span><br><span class="line">	    pageTable[i].use = FALSE;</span><br><span class="line">	    pageTable[i].dirty = FALSE;</span><br><span class="line">	    pageTable[i].readOnly = FALSE;  // 若代码段在独立的页中，设置为只读</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// 将整个地址空间置零, 未初始化数据段和栈段</span><br><span class="line">    bzero(machine-&gt;mainMemory, size);</span><br><span class="line"></span><br><span class="line">// 将代码和数据段复制进入内存</span><br><span class="line">    if (noffH.code.size &gt; 0) &#123;</span><br><span class="line">        DEBUG(&#x27;a&#x27;, &quot;Initializing code segment, at 0x%x, size %d\n&quot;, </span><br><span class="line">			noffH.code.virtualAddr, noffH.code.size);</span><br><span class="line">        executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[noffH.code.virtualAddr]),</span><br><span class="line">			noffH.code.size, noffH.code.inFileAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    if (noffH.initData.size &gt; 0) &#123;</span><br><span class="line">        DEBUG(&#x27;a&#x27;, &quot;Initializing data segment, at 0x%x, size %d\n&quot;, </span><br><span class="line">			noffH.initData.virtualAddr, noffH.initData.size);</span><br><span class="line">        executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[noffH.initData.virtualAddr]),</span><br><span class="line">			noffH.initData.size, noffH.initData.inFileAddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的执行流程为</p>
<ul>
<li><p>读入NoffHeader结构，获取文件的基本信息</p>
</li>
<li><p>检查noffMagic</p>
</li>
<li><p>计算所需空间大小</p>
<ul>
<li><p>size &#x3D; noffH.code.size + noffH.initData.size + noffH.uninitData.size + UserStackSize</p>
</li>
<li><p>代码段+初始化数据段+未初始化数据段+用户栈空间</p>
</li>
</ul>
</li>
<li><p>设置页表</p>
<ul>
<li>用于实现虚拟地址到物理地址的转换</li>
</ul>
</li>
<li><p>将整个地址空间置零, 包括未初始化数据段和栈段</p>
</li>
<li><p>将代码和数据段复制进入内存</p>
</li>
</ul>
<p>页表结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class TranslationEntry &#123;</span><br><span class="line">  public:</span><br><span class="line">    int virtualPage;  	// 虚拟页号</span><br><span class="line">    int physicalPage;  	// 物理页号</span><br><span class="line">    bool valid;         // 有效位</span><br><span class="line">			// 表示本页表项是否被初始化过</span><br><span class="line">    bool readOnly;	// 是否只读</span><br><span class="line">    bool use;           // 页被硬件引用或修改</span><br><span class="line">    bool dirty;         // 脏位</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要为页表项结构，记录本页的相关信息</p>
<h3 id="Nachos应用程序的启动过程"><a href="#Nachos应用程序的启动过程" class="headerlink" title="Nachos应用程序的启动过程"></a>Nachos应用程序的启动过程</h3><p>用户进程需要映射到核心进程才能得到执行：本质上是替换掉地址空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">StartProcess(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    OpenFile *executable = fileSystem-&gt;Open(filename);</span><br><span class="line">    AddrSpace *space;</span><br><span class="line"></span><br><span class="line">    if (executable == NULL) &#123;</span><br><span class="line">	    printf(&quot;Unable to open file %s\n&quot;, filename);</span><br><span class="line">	    return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将用户进程映射到核心进程</span><br><span class="line">    space = new AddrSpace(executable);    </span><br><span class="line">    currentThread-&gt;space = space;</span><br><span class="line"></span><br><span class="line">    delete executable;			// close file</span><br><span class="line"></span><br><span class="line">    space-&gt;InitRegisters();		// 设置初始寄存器值</span><br><span class="line">    space-&gt;RestoreState();		// 加载页表寄存器</span><br><span class="line"></span><br><span class="line">    machine-&gt;Run();			// 运行用户程序</span><br><span class="line">    ASSERT(FALSE);			// machine-&gt;Run 从不返回，若返回则必定错误</span><br><span class="line">					// the address space exits</span><br><span class="line">					// by doing the syscall &quot;exit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为使该核心线程能够执行用户进程的代码，需要核心在调度执行该线程时，根据用户进程的页表读取用户进程指令；</p>
<p>因此需要将用户页表首地址传递给核心的地址变换机构；（machine.h 中维护一个 pageTable 指针，指向当前正在 运行的 Nachos 应用 进程的页表）</p>
<p>如此一来，我们完成了</p>
<ul>
<li>文件的读取</li>
<li>内存的加载</li>
<li>用户进程映射到核心进程</li>
</ul>
<h3 id="上下文切换的完成"><a href="#上下文切换的完成" class="headerlink" title="上下文切换的完成"></a>上下文切换的完成</h3><p>为便于上下文切换时保存与恢复寄存器状态，Nachos 设置了两组寄存器，</p>
<ul>
<li>CPU 使用的寄存器 int registers[NumTotalRegs]（参见 Machine 类 in Machine.h），用于保存执行完一条机器指令时该指令的执行状态；</li>
<li>运行用户程序时使用的用户寄存器 int userRegisters[NumTotalRegs]，用户保存执行完一条用户程序指令后的寄存器状态（参见 Thread.h）；</li>
</ul>
<p>当用户进程进行上下文切换时（实质上是执行用户进程的核心线程发生上下文切换）</p>
<p>将老进程的 CPU 的寄存器状态保存到用户寄存器 userRegisters[]中</p>
<p>将新用户进程的寄存器状态恢复到 CPU 的寄存器中，以便 CPU 能够继续执行上次被中断的用户程序；参见 Scheduler::Run()中核心进程切换时对 CPU 寄存器与用户寄存器的保存与恢复；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Scheduler::Run (Thread *nextThread)</span><br><span class="line">&#123;</span><br><span class="line">    Thread *oldThread = currentThread;</span><br><span class="line">    </span><br><span class="line">#ifdef USER_PROGRAM			//单独对用户进程进行的额外处理</span><br><span class="line">    if (currentThread-&gt;space != NULL) &#123;	// 如果进程为用户进程,</span><br><span class="line">        currentThread-&gt;SaveUserState(); // 保存用户的CPU寄存器到用户寄存器</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>若是用户进程</p>
<h3 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h3><p>machine::Run() （ .&#x2F;machine&#x2F;mipssim.cc 中 实 现 ）</p>
<p> 循环调用 Machine::OneInstruction(Instruction *instr) 执行程序指令，直到程序退出或遇到一个异常；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">Machine::Run()</span><br><span class="line">&#123;</span><br><span class="line">    Instruction *instr = new Instruction;  // 存储指令</span><br><span class="line"></span><br><span class="line">    if(DebugIsEnabled(&#x27;m&#x27;))</span><br><span class="line">        printf(&quot;Starting thread \&quot;%s\&quot; at time %d\n&quot;,</span><br><span class="line">	       currentThread-&gt;getName(), stats-&gt;totalTicks);</span><br><span class="line">    	interrupt-&gt;setStatus(UserMode);</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        OneInstruction(instr); //运行一条指令</span><br><span class="line">		interrupt-&gt;OneTick(); // 中断完成一次跳动</span><br><span class="line">		if (singleStep &amp;&amp; (runUntilTime &lt;= stats-&gt;totalTicks))</span><br><span class="line">	  		Debugger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中指令的格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Instruction &#123;</span><br><span class="line">  public:</span><br><span class="line">    void Decode();	// 解码指令的二进制表示</span><br><span class="line"></span><br><span class="line">    unsigned int value; // 指令的二进制表示</span><br><span class="line"></span><br><span class="line">    char opCode;     // 指令类型  This is NOT the same as the 与opcode不同</span><br><span class="line">    		     // opcode field from the instruction: see defs in mips.h</span><br><span class="line">    char rs, rt, rd; // 指令的三个寄存器</span><br><span class="line">    int extra;       // Immediate or target or shamt field or offset.</span><br><span class="line">                     // Immediates are sign-extended.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="机器硬件设置"><a href="#机器硬件设置" class="headerlink" title="机器硬件设置"></a>机器硬件设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define PageSize 	SectorSize 	// y</span><br><span class="line"></span><br><span class="line">#define NumPhysPages    64 //32</span><br><span class="line">#define MemorySize 	(NumPhysPages * PageSize)</span><br><span class="line">#define TLBSize		4		// if there is a TLB, make it small</span><br></pre></td></tr></table></figure>







<h2 id="备注-3"><a href="#备注-3" class="headerlink" title="备注"></a>备注</h2><p>void bzero（void *s, int n）；</p>
<p>头文件：#include &lt;string.h&gt;</p>
<p>功能：将字符串s的前n个字节置为0，一般来说n通常取sizeof(s),将整块空间清零。</p>
<p>返回值：无返回值</p>
<h1 id="实验7-地址空间的扩展"><a href="#实验7-地址空间的扩展" class="headerlink" title="实验7 地址空间的扩展"></a>实验7 地址空间的扩展</h1><h2 id="目的-4"><a href="#目的-4" class="headerlink" title="目的"></a>目的</h2><p>通过考察系统加载应用程序过程，如何为其分配内存空间、创建页表并建立虚页与实页帧的映射关系，理解 Nachos 的内存管理方法； </p>
<p>理解如何系统对空闲帧的管理； </p>
<p>理解如何加载另一个应用程序并为其分配地址空间，以支持多进程机制； </p>
<p>理解进程的 pid； </p>
<p>理解进程退出所要完成的工作；</p>
<h2 id="任务-4"><a href="#任务-4" class="headerlink" title="任务"></a>任务</h2><p>该实验与下一个实验（实验 8）可在目录..&#x2F;lab7-8 中完成，参照实验 2 介绍的方法将该实验中需要修改的模块、头文件，以及依赖这些头文件的模块复制到该目录中。 如将需要的模块从..&#x2F;userprog 目录复制到该目录中，还要复制 arch 目录及其子目录、Makefile、Makefile.local 等文件，并对 Makefile 及 Makefile.local 做相应 的修改。 该实验中，你需要完成： </p>
<p>（1）阅读..&#x2F;prog&#x2F;protest.cc，深入理解 Nachos 创建应用程序进程的详细过程 </p>
<p>（2）阅读理解类 AddrSpace，然后对其进行修改，使 Nachos 能够支持多进 程机制，允许 Nachos 同时运行多个用户线程； </p>
<p>（3）在类 AddrSpace 中添加完善 Print()函数（在实验 6 中已经给出） </p>
<p>（4）在类 AddrSpace 中实例化类 Bitmap 的一个全局对象，用于管理空闲帧； </p>
<p>（5）如果将 SpaceId 直接作为进程号 Pid 是否合适？如果感觉不是很合适， 应该如何为进程分配相应的 pid？ </p>
<p>（6）为实现 Join(pid)，考虑如何在该进程相关联的核心线程中保存进程号； </p>
<p>（7）根据进程创建时系统为其所做的工作，考虑进程退出时应该做哪些工 作； </p>
<p>（8）考虑系统调用 Exec()与 Exit()的设计实现方案； </p>
<p>（9）拓 展 ： 可 以 进 一 步 考 虑 如 何 添 加 自 己 所 需 要 的 系 统 调 用 ，即..&#x2F;userprog&#x2F;syscall.h 中没有定义的系统调用，如 Time，以获取当前的系统时间。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/10/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/" rel="prev" title="博客的搭建">
      <i class="fa fa-chevron-left"></i> 博客的搭建
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A%E4%B8%80/" rel="next" title="云计算作业一">
      云计算作业一 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE"><span class="nav-number">1.</span> <span class="nav-text">操作系统课设</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nachos%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93"><span class="nav-number">2.</span> <span class="nav-text">Nachos系统总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">中断控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E6%97%B6%E6%9C%BA"><span class="nav-number">2.1.1.</span> <span class="nav-text">中断响应时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.2.</span> <span class="nav-text">线程的状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80-Nachos%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="nav-number">3.</span> <span class="nav-text">实验一 Nachos系统的安装与调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84"><span class="nav-number">3.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.2.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.3.</span> <span class="nav-text">实验步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85nachos"><span class="nav-number">3.3.1.</span> <span class="nav-text">安装nachos</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.1.</span> <span class="nav-text">查询函数地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.2.</span> <span class="nav-text">查询对象地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2SWITCH%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.3.</span> <span class="nav-text">查询SWITCH函数返回地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork%E5%90%8E%E8%BF%90%E8%A1%8CSWICH%E7%9A%84%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.4.</span> <span class="nav-text">Fork后运行SWICH的返回地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C-Nachos%E7%9A%84MAKEFILES"><span class="nav-number">4.</span> <span class="nav-text">实验二 Nachos的MAKEFILES</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="nav-number">4.1.</span> <span class="nav-text">学习总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%85%B6%E4%BB%96%E7%9B%AE%E5%BD%95%E4%B8%AD%E4%BF%AE%E6%94%B9Nachos%E4%BB%A3%E7%A0%81%E5%B9%B6%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.1.1.</span> <span class="nav-text">在其他目录中修改Nachos代码并生成系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9INPATH"><span class="nav-number">4.1.2.</span> <span class="nav-text">修改INPATH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E5%8C%85%E5%90%AB%E4%BF%AE%E6%94%B9%E7%9A%84-h%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E6%96%87%E4%BB%B6%E9%9B%86"><span class="nav-number">4.1.3.</span> <span class="nav-text">寻找包含修改的.h文件的最小文件集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89-%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">5.</span> <span class="nav-text">实验三 利用信号量实现线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-1"><span class="nav-number">5.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4%E4%B8%8E%E8%A6%81%E6%B1%82"><span class="nav-number">5.2.</span> <span class="nav-text">设计步骤与要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">实验过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.3.1.</span> <span class="nav-text">理解信号量的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9prodcons-cc%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.3.2.</span> <span class="nav-text">修改prodcons++.cc的程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E5%B9%B6%E7%90%86%E8%A7%A3%EF%BC%8CThread-Fork-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.3.</span> <span class="nav-text">分析并理解，Thread::Fork()创建线程的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rs%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6"><span class="nav-number">5.3.4.</span> <span class="nav-text">-rs轮转调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">5.4.</span> <span class="nav-text">备注</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.1.</span> <span class="nav-text">C语言函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E6%9E%90"><span class="nav-number">5.5.</span> <span class="nav-text">上下文切换相关函数实现的分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-Yield"><span class="nav-number">5.5.1.</span> <span class="nav-text">Thread::Yield()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scheduler-Run-Thread-nextThread"><span class="nav-number">5.5.2.</span> <span class="nav-text">Scheduler::Run (Thread *nextThread)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-finish"><span class="nav-number">5.5.3.</span> <span class="nav-text">Thread::finish()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-sleep"><span class="nav-number">5.5.4.</span> <span class="nav-text">Thread::sleep()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-FindNextToRun"><span class="nav-number">5.5.5.</span> <span class="nav-text">Thread::FindNextToRun()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B-Nachos-%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.</span> <span class="nav-text">实验四 Nachos 的文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="nav-number">6.1.</span> <span class="nav-text">实验目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-1"><span class="nav-number">6.2.</span> <span class="nav-text">任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.2.1.</span> <span class="nav-text">硬盘初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">6.2.2.</span> <span class="nav-text">硬盘大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nachos%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4"><span class="nav-number">6.2.3.</span> <span class="nav-text">Nachos的文件系统命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FFileSystem%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.2.4.</span> <span class="nav-text">文件系统FileSystem的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nachos%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80"><span class="nav-number">6.2.5.</span> <span class="nav-text">Nachos文件系统布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E7%BB%84%E4%BF%A1%E6%81%AF"><span class="nav-number">6.2.5.1.</span> <span class="nav-text">三元组信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="nav-number">6.2.6.</span> <span class="nav-text">更多的验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8-1"><span class="nav-number">6.3.</span> <span class="nav-text">备注</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%91%BD%E4%BB%A4"><span class="nav-number">6.3.1.</span> <span class="nav-text">Linux命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#od%E5%91%BD%E4%BB%A4%E7%94%A8%E4%BA%8E%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E3%80%82"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">od命令用于输出文件内容。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hexdump%E5%91%BD%E4%BB%A4%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E6%9F%A5%E7%9C%8B%E2%80%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E2%80%9D%E6%96%87%E4%BB%B6%E7%9A%84%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81"><span class="nav-number">6.3.1.2.</span> <span class="nav-text">hexdump命令主要用来查看“二进制”文件的十六进制编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E7%A4%BA%E5%9B%BE"><span class="nav-number">6.3.2.</span> <span class="nav-text">位示图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="nav-number">6.3.3.</span> <span class="nav-text">文件目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="nav-number">6.3.4.</span> <span class="nav-text">文件头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="nav-number">6.3.5.</span> <span class="nav-text">文件大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E7%A9%BA%E9%97%B2%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">6.3.6.</span> <span class="nav-text">硬盘空闲块的管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94-%E6%89%A9%E5%B1%95Nachos%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">7.</span> <span class="nav-text">实验五 扩展Nachos的文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-2"><span class="nav-number">7.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-2"><span class="nav-number">7.2.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-1"><span class="nav-number">7.3.</span> <span class="nav-text">实验过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">7.3.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.3.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">7.4.</span> <span class="nav-text">实验结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">7.5.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8-2"><span class="nav-number">7.6.</span> <span class="nav-text">备注</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%85%AD-Nachos%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">实验六 Nachos用户程序与系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-3"><span class="nav-number">8.1.</span> <span class="nav-text">目的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-3"><span class="nav-number">8.1.1.</span> <span class="nav-text">任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">8.2.</span> <span class="nav-text">实验步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#noff%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.2.1.</span> <span class="nav-text">.noff文件格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86noff%E6%96%87%E4%BB%B6%E8%A3%85%E5%85%A5%E5%86%85%E5%AD%98"><span class="nav-number">8.2.2.</span> <span class="nav-text">将noff文件装入内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nachos%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.2.3.</span> <span class="nav-text">Nachos应用程序的启动过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%8C%E6%88%90"><span class="nav-number">8.2.4.</span> <span class="nav-text">上下文切换的完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4"><span class="nav-number">8.2.5.</span> <span class="nav-text">运行指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E7%A1%AC%E4%BB%B6%E8%AE%BE%E7%BD%AE"><span class="nav-number">8.2.6.</span> <span class="nav-text">机器硬件设置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8-3"><span class="nav-number">8.3.</span> <span class="nav-text">备注</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C7-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">9.</span> <span class="nav-text">实验7 地址空间的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-4"><span class="nav-number">9.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-4"><span class="nav-number">9.2.</span> <span class="nav-text">任务</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="一枚常指针"
      src="/images/profile_photo.jpg">
  <p class="site-author-name" itemprop="name">一枚常指针</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">一枚常指针</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
